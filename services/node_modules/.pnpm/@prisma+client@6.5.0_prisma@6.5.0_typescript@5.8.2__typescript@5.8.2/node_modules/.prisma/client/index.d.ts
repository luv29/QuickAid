
/**
 * Client
**/

import * as runtime from '@prisma/client/runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model MechanicConfirmation
 * 
 */
export type MechanicConfirmation = $Result.DefaultSelection<Prisma.$MechanicConfirmationPayload>
/**
 * Model Mechanic
 * 
 */
export type Mechanic = $Result.DefaultSelection<Prisma.$MechanicPayload>
/**
 * Model Car
 * 
 */
export type Car = $Result.DefaultSelection<Prisma.$CarPayload>
/**
 * Model ServiceRequest
 * 
 */
export type ServiceRequest = $Result.DefaultSelection<Prisma.$ServiceRequestPayload>
/**
 * Model EmergencyContact
 * 
 */
export type EmergencyContact = $Result.DefaultSelection<Prisma.$EmergencyContactPayload>
/**
 * Model Review
 * 
 */
export type Review = $Result.DefaultSelection<Prisma.$ReviewPayload>
/**
 * Model Payment
 * 
 */
export type Payment = $Result.DefaultSelection<Prisma.$PaymentPayload>
/**
 * Model Chat
 * 
 */
export type Chat = $Result.DefaultSelection<Prisma.$ChatPayload>
/**
 * Model Message
 * 
 */
export type Message = $Result.DefaultSelection<Prisma.$MessagePayload>
/**
 * Model SOS
 * 
 */
export type SOS = $Result.DefaultSelection<Prisma.$SOSPayload>

/**
 * Enums
 */
export namespace $Enums {
  export const ServiceType: {
  TOW: 'TOW',
  LOCKOUT: 'LOCKOUT',
  BATTERY_JUMP: 'BATTERY_JUMP',
  FUEL_DELIVERY: 'FUEL_DELIVERY',
  TIRE_CHANGE: 'TIRE_CHANGE',
  JUMP_START: 'JUMP_START',
  ELECTRIC_CHARGING: 'ELECTRIC_CHARGING',
  CAR_REPAIR: 'CAR_REPAIR',
  CUSTOM_SERVICE: 'CUSTOM_SERVICE'
};

export type ServiceType = (typeof ServiceType)[keyof typeof ServiceType]


export const BookingStatus: {
  BOOKED: 'BOOKED',
  CANCELLED: 'CANCELLED',
  CONFIRMED: 'CONFIRMED',
  COMPLETED: 'COMPLETED'
};

export type BookingStatus = (typeof BookingStatus)[keyof typeof BookingStatus]


export const PaymentStatus: {
  PENDING: 'PENDING',
  COMPLETED: 'COMPLETED',
  FAILED: 'FAILED'
};

export type PaymentStatus = (typeof PaymentStatus)[keyof typeof PaymentStatus]


export const SenderType: {
  USER: 'USER',
  MECHANIC: 'MECHANIC'
};

export type SenderType = (typeof SenderType)[keyof typeof SenderType]


export const SOSStatus: {
  ACTIVE: 'ACTIVE',
  RESOLVED: 'RESOLVED'
};

export type SOSStatus = (typeof SOSStatus)[keyof typeof SOSStatus]


export const ServiceStatus: {
  REQUESTED: 'REQUESTED',
  NO_MECHANICS_FOUND: 'NO_MECHANICS_FOUND',
  CONFIRMED: 'CONFIRMED',
  IN_PROGRESS: 'IN_PROGRESS',
  COMPLETED: 'COMPLETED',
  CANCELLED: 'CANCELLED'
};

export type ServiceStatus = (typeof ServiceStatus)[keyof typeof ServiceStatus]


export const ConfirmationStatus: {
  PENDING: 'PENDING',
  CONFIRMED: 'CONFIRMED',
  REJECTED: 'REJECTED',
  STARTED: 'STARTED'
};

export type ConfirmationStatus = (typeof ConfirmationStatus)[keyof typeof ConfirmationStatus]

}

export type ServiceType = $Enums.ServiceType

export const ServiceType: typeof $Enums.ServiceType

export type BookingStatus = $Enums.BookingStatus

export const BookingStatus: typeof $Enums.BookingStatus

export type PaymentStatus = $Enums.PaymentStatus

export const PaymentStatus: typeof $Enums.PaymentStatus

export type SenderType = $Enums.SenderType

export const SenderType: typeof $Enums.SenderType

export type SOSStatus = $Enums.SOSStatus

export const SOSStatus: typeof $Enums.SOSStatus

export type ServiceStatus = $Enums.ServiceStatus

export const ServiceStatus: typeof $Enums.ServiceStatus

export type ConfirmationStatus = $Enums.ConfirmationStatus

export const ConfirmationStatus: typeof $Enums.ConfirmationStatus

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Users
 * const users = await prisma.user.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Users
   * const users = await prisma.user.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P]): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number }): $Utils.JsPromise<R>

  /**
   * Executes a raw MongoDB command and returns the result of it.
   * @example
   * ```
   * const user = await prisma.$runCommandRaw({
   *   aggregate: 'User',
   *   pipeline: [{ $match: { name: 'Bob' } }, { $project: { email: true, _id: false } }],
   *   explain: false,
   * })
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $runCommandRaw(command: Prisma.InputJsonObject): Prisma.PrismaPromise<Prisma.JsonObject>

  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb<ClientOptions>, ExtArgs, $Utils.Call<Prisma.TypeMapCb<ClientOptions>, {
    extArgs: ExtArgs
  }>>

      /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.mechanicConfirmation`: Exposes CRUD operations for the **MechanicConfirmation** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more MechanicConfirmations
    * const mechanicConfirmations = await prisma.mechanicConfirmation.findMany()
    * ```
    */
  get mechanicConfirmation(): Prisma.MechanicConfirmationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.mechanic`: Exposes CRUD operations for the **Mechanic** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Mechanics
    * const mechanics = await prisma.mechanic.findMany()
    * ```
    */
  get mechanic(): Prisma.MechanicDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.car`: Exposes CRUD operations for the **Car** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Cars
    * const cars = await prisma.car.findMany()
    * ```
    */
  get car(): Prisma.CarDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.serviceRequest`: Exposes CRUD operations for the **ServiceRequest** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ServiceRequests
    * const serviceRequests = await prisma.serviceRequest.findMany()
    * ```
    */
  get serviceRequest(): Prisma.ServiceRequestDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.emergencyContact`: Exposes CRUD operations for the **EmergencyContact** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more EmergencyContacts
    * const emergencyContacts = await prisma.emergencyContact.findMany()
    * ```
    */
  get emergencyContact(): Prisma.EmergencyContactDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.review`: Exposes CRUD operations for the **Review** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Reviews
    * const reviews = await prisma.review.findMany()
    * ```
    */
  get review(): Prisma.ReviewDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.payment`: Exposes CRUD operations for the **Payment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Payments
    * const payments = await prisma.payment.findMany()
    * ```
    */
  get payment(): Prisma.PaymentDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.chat`: Exposes CRUD operations for the **Chat** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Chats
    * const chats = await prisma.chat.findMany()
    * ```
    */
  get chat(): Prisma.ChatDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.message`: Exposes CRUD operations for the **Message** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Messages
    * const messages = await prisma.message.findMany()
    * ```
    */
  get message(): Prisma.MessageDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.sOS`: Exposes CRUD operations for the **SOS** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SOS
    * const sOS = await prisma.sOS.findMany()
    * ```
    */
  get sOS(): Prisma.SOSDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 6.5.0
   * Query Engine version: 173f8d54f8d52e692c7e27e72a88314ec7aeff60
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    User: 'User',
    MechanicConfirmation: 'MechanicConfirmation',
    Mechanic: 'Mechanic',
    Car: 'Car',
    ServiceRequest: 'ServiceRequest',
    EmergencyContact: 'EmergencyContact',
    Review: 'Review',
    Payment: 'Payment',
    Chat: 'Chat',
    Message: 'Message',
    SOS: 'SOS'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<{extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
    globalOmitOptions: {
      omit: GlobalOmitOptions
    }
    meta: {
      modelProps: "user" | "mechanicConfirmation" | "mechanic" | "car" | "serviceRequest" | "emergencyContact" | "review" | "payment" | "chat" | "message" | "sOS"
      txIsolationLevel: never
    }
    model: {
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.UserFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.UserAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      MechanicConfirmation: {
        payload: Prisma.$MechanicConfirmationPayload<ExtArgs>
        fields: Prisma.MechanicConfirmationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MechanicConfirmationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MechanicConfirmationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MechanicConfirmationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MechanicConfirmationPayload>
          }
          findFirst: {
            args: Prisma.MechanicConfirmationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MechanicConfirmationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MechanicConfirmationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MechanicConfirmationPayload>
          }
          findMany: {
            args: Prisma.MechanicConfirmationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MechanicConfirmationPayload>[]
          }
          create: {
            args: Prisma.MechanicConfirmationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MechanicConfirmationPayload>
          }
          createMany: {
            args: Prisma.MechanicConfirmationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.MechanicConfirmationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MechanicConfirmationPayload>
          }
          update: {
            args: Prisma.MechanicConfirmationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MechanicConfirmationPayload>
          }
          deleteMany: {
            args: Prisma.MechanicConfirmationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MechanicConfirmationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.MechanicConfirmationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MechanicConfirmationPayload>
          }
          aggregate: {
            args: Prisma.MechanicConfirmationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMechanicConfirmation>
          }
          groupBy: {
            args: Prisma.MechanicConfirmationGroupByArgs<ExtArgs>
            result: $Utils.Optional<MechanicConfirmationGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.MechanicConfirmationFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.MechanicConfirmationAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.MechanicConfirmationCountArgs<ExtArgs>
            result: $Utils.Optional<MechanicConfirmationCountAggregateOutputType> | number
          }
        }
      }
      Mechanic: {
        payload: Prisma.$MechanicPayload<ExtArgs>
        fields: Prisma.MechanicFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MechanicFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MechanicPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MechanicFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MechanicPayload>
          }
          findFirst: {
            args: Prisma.MechanicFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MechanicPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MechanicFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MechanicPayload>
          }
          findMany: {
            args: Prisma.MechanicFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MechanicPayload>[]
          }
          create: {
            args: Prisma.MechanicCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MechanicPayload>
          }
          createMany: {
            args: Prisma.MechanicCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.MechanicDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MechanicPayload>
          }
          update: {
            args: Prisma.MechanicUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MechanicPayload>
          }
          deleteMany: {
            args: Prisma.MechanicDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MechanicUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.MechanicUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MechanicPayload>
          }
          aggregate: {
            args: Prisma.MechanicAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMechanic>
          }
          groupBy: {
            args: Prisma.MechanicGroupByArgs<ExtArgs>
            result: $Utils.Optional<MechanicGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.MechanicFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.MechanicAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.MechanicCountArgs<ExtArgs>
            result: $Utils.Optional<MechanicCountAggregateOutputType> | number
          }
        }
      }
      Car: {
        payload: Prisma.$CarPayload<ExtArgs>
        fields: Prisma.CarFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CarFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CarPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CarFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CarPayload>
          }
          findFirst: {
            args: Prisma.CarFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CarPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CarFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CarPayload>
          }
          findMany: {
            args: Prisma.CarFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CarPayload>[]
          }
          create: {
            args: Prisma.CarCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CarPayload>
          }
          createMany: {
            args: Prisma.CarCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.CarDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CarPayload>
          }
          update: {
            args: Prisma.CarUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CarPayload>
          }
          deleteMany: {
            args: Prisma.CarDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CarUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.CarUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CarPayload>
          }
          aggregate: {
            args: Prisma.CarAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCar>
          }
          groupBy: {
            args: Prisma.CarGroupByArgs<ExtArgs>
            result: $Utils.Optional<CarGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.CarFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.CarAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.CarCountArgs<ExtArgs>
            result: $Utils.Optional<CarCountAggregateOutputType> | number
          }
        }
      }
      ServiceRequest: {
        payload: Prisma.$ServiceRequestPayload<ExtArgs>
        fields: Prisma.ServiceRequestFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ServiceRequestFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceRequestPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ServiceRequestFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceRequestPayload>
          }
          findFirst: {
            args: Prisma.ServiceRequestFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceRequestPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ServiceRequestFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceRequestPayload>
          }
          findMany: {
            args: Prisma.ServiceRequestFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceRequestPayload>[]
          }
          create: {
            args: Prisma.ServiceRequestCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceRequestPayload>
          }
          createMany: {
            args: Prisma.ServiceRequestCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.ServiceRequestDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceRequestPayload>
          }
          update: {
            args: Prisma.ServiceRequestUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceRequestPayload>
          }
          deleteMany: {
            args: Prisma.ServiceRequestDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ServiceRequestUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ServiceRequestUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceRequestPayload>
          }
          aggregate: {
            args: Prisma.ServiceRequestAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateServiceRequest>
          }
          groupBy: {
            args: Prisma.ServiceRequestGroupByArgs<ExtArgs>
            result: $Utils.Optional<ServiceRequestGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.ServiceRequestFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.ServiceRequestAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.ServiceRequestCountArgs<ExtArgs>
            result: $Utils.Optional<ServiceRequestCountAggregateOutputType> | number
          }
        }
      }
      EmergencyContact: {
        payload: Prisma.$EmergencyContactPayload<ExtArgs>
        fields: Prisma.EmergencyContactFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EmergencyContactFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmergencyContactPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EmergencyContactFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmergencyContactPayload>
          }
          findFirst: {
            args: Prisma.EmergencyContactFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmergencyContactPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EmergencyContactFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmergencyContactPayload>
          }
          findMany: {
            args: Prisma.EmergencyContactFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmergencyContactPayload>[]
          }
          create: {
            args: Prisma.EmergencyContactCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmergencyContactPayload>
          }
          createMany: {
            args: Prisma.EmergencyContactCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.EmergencyContactDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmergencyContactPayload>
          }
          update: {
            args: Prisma.EmergencyContactUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmergencyContactPayload>
          }
          deleteMany: {
            args: Prisma.EmergencyContactDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.EmergencyContactUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.EmergencyContactUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmergencyContactPayload>
          }
          aggregate: {
            args: Prisma.EmergencyContactAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEmergencyContact>
          }
          groupBy: {
            args: Prisma.EmergencyContactGroupByArgs<ExtArgs>
            result: $Utils.Optional<EmergencyContactGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.EmergencyContactFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.EmergencyContactAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.EmergencyContactCountArgs<ExtArgs>
            result: $Utils.Optional<EmergencyContactCountAggregateOutputType> | number
          }
        }
      }
      Review: {
        payload: Prisma.$ReviewPayload<ExtArgs>
        fields: Prisma.ReviewFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ReviewFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ReviewFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewPayload>
          }
          findFirst: {
            args: Prisma.ReviewFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ReviewFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewPayload>
          }
          findMany: {
            args: Prisma.ReviewFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewPayload>[]
          }
          create: {
            args: Prisma.ReviewCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewPayload>
          }
          createMany: {
            args: Prisma.ReviewCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.ReviewDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewPayload>
          }
          update: {
            args: Prisma.ReviewUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewPayload>
          }
          deleteMany: {
            args: Prisma.ReviewDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ReviewUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ReviewUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewPayload>
          }
          aggregate: {
            args: Prisma.ReviewAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateReview>
          }
          groupBy: {
            args: Prisma.ReviewGroupByArgs<ExtArgs>
            result: $Utils.Optional<ReviewGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.ReviewFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.ReviewAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.ReviewCountArgs<ExtArgs>
            result: $Utils.Optional<ReviewCountAggregateOutputType> | number
          }
        }
      }
      Payment: {
        payload: Prisma.$PaymentPayload<ExtArgs>
        fields: Prisma.PaymentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PaymentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PaymentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          findFirst: {
            args: Prisma.PaymentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PaymentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          findMany: {
            args: Prisma.PaymentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>[]
          }
          create: {
            args: Prisma.PaymentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          createMany: {
            args: Prisma.PaymentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.PaymentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          update: {
            args: Prisma.PaymentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          deleteMany: {
            args: Prisma.PaymentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PaymentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.PaymentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          aggregate: {
            args: Prisma.PaymentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePayment>
          }
          groupBy: {
            args: Prisma.PaymentGroupByArgs<ExtArgs>
            result: $Utils.Optional<PaymentGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.PaymentFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.PaymentAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.PaymentCountArgs<ExtArgs>
            result: $Utils.Optional<PaymentCountAggregateOutputType> | number
          }
        }
      }
      Chat: {
        payload: Prisma.$ChatPayload<ExtArgs>
        fields: Prisma.ChatFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ChatFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ChatFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatPayload>
          }
          findFirst: {
            args: Prisma.ChatFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ChatFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatPayload>
          }
          findMany: {
            args: Prisma.ChatFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatPayload>[]
          }
          create: {
            args: Prisma.ChatCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatPayload>
          }
          createMany: {
            args: Prisma.ChatCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.ChatDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatPayload>
          }
          update: {
            args: Prisma.ChatUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatPayload>
          }
          deleteMany: {
            args: Prisma.ChatDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ChatUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ChatUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatPayload>
          }
          aggregate: {
            args: Prisma.ChatAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateChat>
          }
          groupBy: {
            args: Prisma.ChatGroupByArgs<ExtArgs>
            result: $Utils.Optional<ChatGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.ChatFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.ChatAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.ChatCountArgs<ExtArgs>
            result: $Utils.Optional<ChatCountAggregateOutputType> | number
          }
        }
      }
      Message: {
        payload: Prisma.$MessagePayload<ExtArgs>
        fields: Prisma.MessageFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MessageFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MessageFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>
          }
          findFirst: {
            args: Prisma.MessageFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MessageFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>
          }
          findMany: {
            args: Prisma.MessageFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>[]
          }
          create: {
            args: Prisma.MessageCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>
          }
          createMany: {
            args: Prisma.MessageCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.MessageDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>
          }
          update: {
            args: Prisma.MessageUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>
          }
          deleteMany: {
            args: Prisma.MessageDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MessageUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.MessageUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>
          }
          aggregate: {
            args: Prisma.MessageAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMessage>
          }
          groupBy: {
            args: Prisma.MessageGroupByArgs<ExtArgs>
            result: $Utils.Optional<MessageGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.MessageFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.MessageAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.MessageCountArgs<ExtArgs>
            result: $Utils.Optional<MessageCountAggregateOutputType> | number
          }
        }
      }
      SOS: {
        payload: Prisma.$SOSPayload<ExtArgs>
        fields: Prisma.SOSFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SOSFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SOSPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SOSFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SOSPayload>
          }
          findFirst: {
            args: Prisma.SOSFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SOSPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SOSFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SOSPayload>
          }
          findMany: {
            args: Prisma.SOSFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SOSPayload>[]
          }
          create: {
            args: Prisma.SOSCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SOSPayload>
          }
          createMany: {
            args: Prisma.SOSCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.SOSDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SOSPayload>
          }
          update: {
            args: Prisma.SOSUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SOSPayload>
          }
          deleteMany: {
            args: Prisma.SOSDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SOSUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.SOSUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SOSPayload>
          }
          aggregate: {
            args: Prisma.SOSAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSOS>
          }
          groupBy: {
            args: Prisma.SOSGroupByArgs<ExtArgs>
            result: $Utils.Optional<SOSGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.SOSFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.SOSAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.SOSCountArgs<ExtArgs>
            result: $Utils.Optional<SOSCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $runCommandRaw: {
          args: Prisma.InputJsonObject,
          result: Prisma.JsonObject
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
    }
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
  }
  export type GlobalOmitConfig = {
    user?: UserOmit
    mechanicConfirmation?: MechanicConfirmationOmit
    mechanic?: MechanicOmit
    car?: CarOmit
    serviceRequest?: ServiceRequestOmit
    emergencyContact?: EmergencyContactOmit
    review?: ReviewOmit
    payment?: PaymentOmit
    chat?: ChatOmit
    message?: MessageOmit
    sOS?: SOSOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    cars: number
    serviceRequests: number
    emergencyContacts: number
    sentMessages: number
    sosEvents: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    cars?: boolean | UserCountOutputTypeCountCarsArgs
    serviceRequests?: boolean | UserCountOutputTypeCountServiceRequestsArgs
    emergencyContacts?: boolean | UserCountOutputTypeCountEmergencyContactsArgs
    sentMessages?: boolean | UserCountOutputTypeCountSentMessagesArgs
    sosEvents?: boolean | UserCountOutputTypeCountSosEventsArgs
  }

  // Custom InputTypes
  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountCarsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CarWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountServiceRequestsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ServiceRequestWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountEmergencyContactsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EmergencyContactWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountSentMessagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MessageWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountSosEventsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SOSWhereInput
  }


  /**
   * Count Type MechanicCountOutputType
   */

  export type MechanicCountOutputType = {
    serviceRequests: number
    reviews: number
    sentMessages: number
    MechanicConfirmation: number
  }

  export type MechanicCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    serviceRequests?: boolean | MechanicCountOutputTypeCountServiceRequestsArgs
    reviews?: boolean | MechanicCountOutputTypeCountReviewsArgs
    sentMessages?: boolean | MechanicCountOutputTypeCountSentMessagesArgs
    MechanicConfirmation?: boolean | MechanicCountOutputTypeCountMechanicConfirmationArgs
  }

  // Custom InputTypes
  /**
   * MechanicCountOutputType without action
   */
  export type MechanicCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MechanicCountOutputType
     */
    select?: MechanicCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * MechanicCountOutputType without action
   */
  export type MechanicCountOutputTypeCountServiceRequestsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ServiceRequestWhereInput
  }

  /**
   * MechanicCountOutputType without action
   */
  export type MechanicCountOutputTypeCountReviewsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReviewWhereInput
  }

  /**
   * MechanicCountOutputType without action
   */
  export type MechanicCountOutputTypeCountSentMessagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MessageWhereInput
  }

  /**
   * MechanicCountOutputType without action
   */
  export type MechanicCountOutputTypeCountMechanicConfirmationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MechanicConfirmationWhereInput
  }


  /**
   * Count Type ServiceRequestCountOutputType
   */

  export type ServiceRequestCountOutputType = {
    confirmations: number
    reviews: number
  }

  export type ServiceRequestCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    confirmations?: boolean | ServiceRequestCountOutputTypeCountConfirmationsArgs
    reviews?: boolean | ServiceRequestCountOutputTypeCountReviewsArgs
  }

  // Custom InputTypes
  /**
   * ServiceRequestCountOutputType without action
   */
  export type ServiceRequestCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceRequestCountOutputType
     */
    select?: ServiceRequestCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ServiceRequestCountOutputType without action
   */
  export type ServiceRequestCountOutputTypeCountConfirmationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MechanicConfirmationWhereInput
  }

  /**
   * ServiceRequestCountOutputType without action
   */
  export type ServiceRequestCountOutputTypeCountReviewsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReviewWhereInput
  }


  /**
   * Count Type EmergencyContactCountOutputType
   */

  export type EmergencyContactCountOutputType = {
    sosEvents: number
  }

  export type EmergencyContactCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sosEvents?: boolean | EmergencyContactCountOutputTypeCountSosEventsArgs
  }

  // Custom InputTypes
  /**
   * EmergencyContactCountOutputType without action
   */
  export type EmergencyContactCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmergencyContactCountOutputType
     */
    select?: EmergencyContactCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * EmergencyContactCountOutputType without action
   */
  export type EmergencyContactCountOutputTypeCountSosEventsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SOSWhereInput
  }


  /**
   * Count Type ChatCountOutputType
   */

  export type ChatCountOutputType = {
    messages: number
  }

  export type ChatCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    messages?: boolean | ChatCountOutputTypeCountMessagesArgs
  }

  // Custom InputTypes
  /**
   * ChatCountOutputType without action
   */
  export type ChatCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatCountOutputType
     */
    select?: ChatCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ChatCountOutputType without action
   */
  export type ChatCountOutputTypeCountMessagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MessageWhereInput
  }


  /**
   * Models
   */

  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserMinAggregateOutputType = {
    id: string | null
    phoneNumber: string | null
    name: string | null
    email: string | null
    password: string | null
  }

  export type UserMaxAggregateOutputType = {
    id: string | null
    phoneNumber: string | null
    name: string | null
    email: string | null
    password: string | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    phoneNumber: number
    name: number
    email: number
    password: number
    _all: number
  }


  export type UserMinAggregateInputType = {
    id?: true
    phoneNumber?: true
    name?: true
    email?: true
    password?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    phoneNumber?: true
    name?: true
    email?: true
    password?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    phoneNumber?: true
    name?: true
    email?: true
    password?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: string
    phoneNumber: string
    name: string | null
    email: string | null
    password: string | null
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    phoneNumber?: boolean
    name?: boolean
    email?: boolean
    password?: boolean
    cars?: boolean | User$carsArgs<ExtArgs>
    serviceRequests?: boolean | User$serviceRequestsArgs<ExtArgs>
    emergencyContacts?: boolean | User$emergencyContactsArgs<ExtArgs>
    sentMessages?: boolean | User$sentMessagesArgs<ExtArgs>
    sosEvents?: boolean | User$sosEventsArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>



  export type UserSelectScalar = {
    id?: boolean
    phoneNumber?: boolean
    name?: boolean
    email?: boolean
    password?: boolean
  }

  export type UserOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "phoneNumber" | "name" | "email" | "password", ExtArgs["result"]["user"]>
  export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    cars?: boolean | User$carsArgs<ExtArgs>
    serviceRequests?: boolean | User$serviceRequestsArgs<ExtArgs>
    emergencyContacts?: boolean | User$emergencyContactsArgs<ExtArgs>
    sentMessages?: boolean | User$sentMessagesArgs<ExtArgs>
    sosEvents?: boolean | User$sosEventsArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {
      cars: Prisma.$CarPayload<ExtArgs>[]
      serviceRequests: Prisma.$ServiceRequestPayload<ExtArgs>[]
      emergencyContacts: Prisma.$EmergencyContactPayload<ExtArgs>[]
      sentMessages: Prisma.$MessagePayload<ExtArgs>[]
      sosEvents: Prisma.$SOSPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      phoneNumber: string
      name: string | null
      email: string | null
      password: string | null
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFindUniqueArgs>(args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFindFirstArgs>(args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserFindManyArgs>(args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends UserCreateArgs>(args: SelectSubset<T, UserCreateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserCreateManyArgs>(args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends UserDeleteArgs>(args: SelectSubset<T, UserDeleteArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserUpdateArgs>(args: SelectSubset<T, UserUpdateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserDeleteManyArgs>(args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserUpdateManyArgs>(args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends UserUpsertArgs>(args: SelectSubset<T, UserUpsertArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Users that matches the filter.
     * @param {UserFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const user = await prisma.user.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: UserFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a User.
     * @param {UserAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const user = await prisma.user.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: UserAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    cars<T extends User$carsArgs<ExtArgs> = {}>(args?: Subset<T, User$carsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CarPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    serviceRequests<T extends User$serviceRequestsArgs<ExtArgs> = {}>(args?: Subset<T, User$serviceRequestsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ServiceRequestPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    emergencyContacts<T extends User$emergencyContactsArgs<ExtArgs> = {}>(args?: Subset<T, User$emergencyContactsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmergencyContactPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    sentMessages<T extends User$sentMessagesArgs<ExtArgs> = {}>(args?: Subset<T, User$sentMessagesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    sosEvents<T extends User$sosEventsArgs<ExtArgs> = {}>(args?: Subset<T, User$sosEventsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SOSPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the User model
   */ 
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'String'>
    readonly phoneNumber: FieldRef<"User", 'String'>
    readonly name: FieldRef<"User", 'String'>
    readonly email: FieldRef<"User", 'String'>
    readonly password: FieldRef<"User", 'String'>
  }
    

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }

  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
  }

  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }

  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to delete.
     */
    limit?: number
  }

  /**
   * User findRaw
   */
  export type UserFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * User aggregateRaw
   */
  export type UserAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * User.cars
   */
  export type User$carsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Car
     */
    select?: CarSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Car
     */
    omit?: CarOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CarInclude<ExtArgs> | null
    where?: CarWhereInput
    orderBy?: CarOrderByWithRelationInput | CarOrderByWithRelationInput[]
    cursor?: CarWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CarScalarFieldEnum | CarScalarFieldEnum[]
  }

  /**
   * User.serviceRequests
   */
  export type User$serviceRequestsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceRequest
     */
    select?: ServiceRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceRequest
     */
    omit?: ServiceRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceRequestInclude<ExtArgs> | null
    where?: ServiceRequestWhereInput
    orderBy?: ServiceRequestOrderByWithRelationInput | ServiceRequestOrderByWithRelationInput[]
    cursor?: ServiceRequestWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ServiceRequestScalarFieldEnum | ServiceRequestScalarFieldEnum[]
  }

  /**
   * User.emergencyContacts
   */
  export type User$emergencyContactsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmergencyContact
     */
    select?: EmergencyContactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmergencyContact
     */
    omit?: EmergencyContactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmergencyContactInclude<ExtArgs> | null
    where?: EmergencyContactWhereInput
    orderBy?: EmergencyContactOrderByWithRelationInput | EmergencyContactOrderByWithRelationInput[]
    cursor?: EmergencyContactWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EmergencyContactScalarFieldEnum | EmergencyContactScalarFieldEnum[]
  }

  /**
   * User.sentMessages
   */
  export type User$sentMessagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    where?: MessageWhereInput
    orderBy?: MessageOrderByWithRelationInput | MessageOrderByWithRelationInput[]
    cursor?: MessageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MessageScalarFieldEnum | MessageScalarFieldEnum[]
  }

  /**
   * User.sosEvents
   */
  export type User$sosEventsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SOS
     */
    select?: SOSSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SOS
     */
    omit?: SOSOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SOSInclude<ExtArgs> | null
    where?: SOSWhereInput
    orderBy?: SOSOrderByWithRelationInput | SOSOrderByWithRelationInput[]
    cursor?: SOSWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SOSScalarFieldEnum | SOSScalarFieldEnum[]
  }

  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
  }


  /**
   * Model MechanicConfirmation
   */

  export type AggregateMechanicConfirmation = {
    _count: MechanicConfirmationCountAggregateOutputType | null
    _avg: MechanicConfirmationAvgAggregateOutputType | null
    _sum: MechanicConfirmationSumAggregateOutputType | null
    _min: MechanicConfirmationMinAggregateOutputType | null
    _max: MechanicConfirmationMaxAggregateOutputType | null
  }

  export type MechanicConfirmationAvgAggregateOutputType = {
    distanceValue: number | null
    durationValue: number | null
    estimatedCost: number | null
  }

  export type MechanicConfirmationSumAggregateOutputType = {
    distanceValue: number | null
    durationValue: number | null
    estimatedCost: number | null
  }

  export type MechanicConfirmationMinAggregateOutputType = {
    id: string | null
    mechanicId: string | null
    serviceRequestId: string | null
    status: $Enums.ConfirmationStatus | null
    distanceText: string | null
    distanceValue: number | null
    durationText: string | null
    durationValue: number | null
    estimatedCost: number | null
    respondedAt: Date | null
    createdAt: Date | null
  }

  export type MechanicConfirmationMaxAggregateOutputType = {
    id: string | null
    mechanicId: string | null
    serviceRequestId: string | null
    status: $Enums.ConfirmationStatus | null
    distanceText: string | null
    distanceValue: number | null
    durationText: string | null
    durationValue: number | null
    estimatedCost: number | null
    respondedAt: Date | null
    createdAt: Date | null
  }

  export type MechanicConfirmationCountAggregateOutputType = {
    id: number
    mechanicId: number
    serviceRequestId: number
    status: number
    distanceText: number
    distanceValue: number
    durationText: number
    durationValue: number
    estimatedCost: number
    respondedAt: number
    createdAt: number
    _all: number
  }


  export type MechanicConfirmationAvgAggregateInputType = {
    distanceValue?: true
    durationValue?: true
    estimatedCost?: true
  }

  export type MechanicConfirmationSumAggregateInputType = {
    distanceValue?: true
    durationValue?: true
    estimatedCost?: true
  }

  export type MechanicConfirmationMinAggregateInputType = {
    id?: true
    mechanicId?: true
    serviceRequestId?: true
    status?: true
    distanceText?: true
    distanceValue?: true
    durationText?: true
    durationValue?: true
    estimatedCost?: true
    respondedAt?: true
    createdAt?: true
  }

  export type MechanicConfirmationMaxAggregateInputType = {
    id?: true
    mechanicId?: true
    serviceRequestId?: true
    status?: true
    distanceText?: true
    distanceValue?: true
    durationText?: true
    durationValue?: true
    estimatedCost?: true
    respondedAt?: true
    createdAt?: true
  }

  export type MechanicConfirmationCountAggregateInputType = {
    id?: true
    mechanicId?: true
    serviceRequestId?: true
    status?: true
    distanceText?: true
    distanceValue?: true
    durationText?: true
    durationValue?: true
    estimatedCost?: true
    respondedAt?: true
    createdAt?: true
    _all?: true
  }

  export type MechanicConfirmationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MechanicConfirmation to aggregate.
     */
    where?: MechanicConfirmationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MechanicConfirmations to fetch.
     */
    orderBy?: MechanicConfirmationOrderByWithRelationInput | MechanicConfirmationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MechanicConfirmationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MechanicConfirmations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MechanicConfirmations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned MechanicConfirmations
    **/
    _count?: true | MechanicConfirmationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MechanicConfirmationAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MechanicConfirmationSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MechanicConfirmationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MechanicConfirmationMaxAggregateInputType
  }

  export type GetMechanicConfirmationAggregateType<T extends MechanicConfirmationAggregateArgs> = {
        [P in keyof T & keyof AggregateMechanicConfirmation]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMechanicConfirmation[P]>
      : GetScalarType<T[P], AggregateMechanicConfirmation[P]>
  }




  export type MechanicConfirmationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MechanicConfirmationWhereInput
    orderBy?: MechanicConfirmationOrderByWithAggregationInput | MechanicConfirmationOrderByWithAggregationInput[]
    by: MechanicConfirmationScalarFieldEnum[] | MechanicConfirmationScalarFieldEnum
    having?: MechanicConfirmationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MechanicConfirmationCountAggregateInputType | true
    _avg?: MechanicConfirmationAvgAggregateInputType
    _sum?: MechanicConfirmationSumAggregateInputType
    _min?: MechanicConfirmationMinAggregateInputType
    _max?: MechanicConfirmationMaxAggregateInputType
  }

  export type MechanicConfirmationGroupByOutputType = {
    id: string
    mechanicId: string
    serviceRequestId: string
    status: $Enums.ConfirmationStatus
    distanceText: string
    distanceValue: number
    durationText: string
    durationValue: number
    estimatedCost: number
    respondedAt: Date | null
    createdAt: Date
    _count: MechanicConfirmationCountAggregateOutputType | null
    _avg: MechanicConfirmationAvgAggregateOutputType | null
    _sum: MechanicConfirmationSumAggregateOutputType | null
    _min: MechanicConfirmationMinAggregateOutputType | null
    _max: MechanicConfirmationMaxAggregateOutputType | null
  }

  type GetMechanicConfirmationGroupByPayload<T extends MechanicConfirmationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MechanicConfirmationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MechanicConfirmationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MechanicConfirmationGroupByOutputType[P]>
            : GetScalarType<T[P], MechanicConfirmationGroupByOutputType[P]>
        }
      >
    >


  export type MechanicConfirmationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    mechanicId?: boolean
    serviceRequestId?: boolean
    status?: boolean
    distanceText?: boolean
    distanceValue?: boolean
    durationText?: boolean
    durationValue?: boolean
    estimatedCost?: boolean
    respondedAt?: boolean
    createdAt?: boolean
    mechanic?: boolean | MechanicDefaultArgs<ExtArgs>
    serviceRequest?: boolean | ServiceRequestDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["mechanicConfirmation"]>



  export type MechanicConfirmationSelectScalar = {
    id?: boolean
    mechanicId?: boolean
    serviceRequestId?: boolean
    status?: boolean
    distanceText?: boolean
    distanceValue?: boolean
    durationText?: boolean
    durationValue?: boolean
    estimatedCost?: boolean
    respondedAt?: boolean
    createdAt?: boolean
  }

  export type MechanicConfirmationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "mechanicId" | "serviceRequestId" | "status" | "distanceText" | "distanceValue" | "durationText" | "durationValue" | "estimatedCost" | "respondedAt" | "createdAt", ExtArgs["result"]["mechanicConfirmation"]>
  export type MechanicConfirmationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    mechanic?: boolean | MechanicDefaultArgs<ExtArgs>
    serviceRequest?: boolean | ServiceRequestDefaultArgs<ExtArgs>
  }

  export type $MechanicConfirmationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "MechanicConfirmation"
    objects: {
      mechanic: Prisma.$MechanicPayload<ExtArgs>
      serviceRequest: Prisma.$ServiceRequestPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      mechanicId: string
      serviceRequestId: string
      status: $Enums.ConfirmationStatus
      distanceText: string
      distanceValue: number
      durationText: string
      durationValue: number
      estimatedCost: number
      respondedAt: Date | null
      createdAt: Date
    }, ExtArgs["result"]["mechanicConfirmation"]>
    composites: {}
  }

  type MechanicConfirmationGetPayload<S extends boolean | null | undefined | MechanicConfirmationDefaultArgs> = $Result.GetResult<Prisma.$MechanicConfirmationPayload, S>

  type MechanicConfirmationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<MechanicConfirmationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: MechanicConfirmationCountAggregateInputType | true
    }

  export interface MechanicConfirmationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['MechanicConfirmation'], meta: { name: 'MechanicConfirmation' } }
    /**
     * Find zero or one MechanicConfirmation that matches the filter.
     * @param {MechanicConfirmationFindUniqueArgs} args - Arguments to find a MechanicConfirmation
     * @example
     * // Get one MechanicConfirmation
     * const mechanicConfirmation = await prisma.mechanicConfirmation.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MechanicConfirmationFindUniqueArgs>(args: SelectSubset<T, MechanicConfirmationFindUniqueArgs<ExtArgs>>): Prisma__MechanicConfirmationClient<$Result.GetResult<Prisma.$MechanicConfirmationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one MechanicConfirmation that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {MechanicConfirmationFindUniqueOrThrowArgs} args - Arguments to find a MechanicConfirmation
     * @example
     * // Get one MechanicConfirmation
     * const mechanicConfirmation = await prisma.mechanicConfirmation.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MechanicConfirmationFindUniqueOrThrowArgs>(args: SelectSubset<T, MechanicConfirmationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MechanicConfirmationClient<$Result.GetResult<Prisma.$MechanicConfirmationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first MechanicConfirmation that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MechanicConfirmationFindFirstArgs} args - Arguments to find a MechanicConfirmation
     * @example
     * // Get one MechanicConfirmation
     * const mechanicConfirmation = await prisma.mechanicConfirmation.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MechanicConfirmationFindFirstArgs>(args?: SelectSubset<T, MechanicConfirmationFindFirstArgs<ExtArgs>>): Prisma__MechanicConfirmationClient<$Result.GetResult<Prisma.$MechanicConfirmationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first MechanicConfirmation that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MechanicConfirmationFindFirstOrThrowArgs} args - Arguments to find a MechanicConfirmation
     * @example
     * // Get one MechanicConfirmation
     * const mechanicConfirmation = await prisma.mechanicConfirmation.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MechanicConfirmationFindFirstOrThrowArgs>(args?: SelectSubset<T, MechanicConfirmationFindFirstOrThrowArgs<ExtArgs>>): Prisma__MechanicConfirmationClient<$Result.GetResult<Prisma.$MechanicConfirmationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more MechanicConfirmations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MechanicConfirmationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all MechanicConfirmations
     * const mechanicConfirmations = await prisma.mechanicConfirmation.findMany()
     * 
     * // Get first 10 MechanicConfirmations
     * const mechanicConfirmations = await prisma.mechanicConfirmation.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const mechanicConfirmationWithIdOnly = await prisma.mechanicConfirmation.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MechanicConfirmationFindManyArgs>(args?: SelectSubset<T, MechanicConfirmationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MechanicConfirmationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a MechanicConfirmation.
     * @param {MechanicConfirmationCreateArgs} args - Arguments to create a MechanicConfirmation.
     * @example
     * // Create one MechanicConfirmation
     * const MechanicConfirmation = await prisma.mechanicConfirmation.create({
     *   data: {
     *     // ... data to create a MechanicConfirmation
     *   }
     * })
     * 
     */
    create<T extends MechanicConfirmationCreateArgs>(args: SelectSubset<T, MechanicConfirmationCreateArgs<ExtArgs>>): Prisma__MechanicConfirmationClient<$Result.GetResult<Prisma.$MechanicConfirmationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many MechanicConfirmations.
     * @param {MechanicConfirmationCreateManyArgs} args - Arguments to create many MechanicConfirmations.
     * @example
     * // Create many MechanicConfirmations
     * const mechanicConfirmation = await prisma.mechanicConfirmation.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MechanicConfirmationCreateManyArgs>(args?: SelectSubset<T, MechanicConfirmationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a MechanicConfirmation.
     * @param {MechanicConfirmationDeleteArgs} args - Arguments to delete one MechanicConfirmation.
     * @example
     * // Delete one MechanicConfirmation
     * const MechanicConfirmation = await prisma.mechanicConfirmation.delete({
     *   where: {
     *     // ... filter to delete one MechanicConfirmation
     *   }
     * })
     * 
     */
    delete<T extends MechanicConfirmationDeleteArgs>(args: SelectSubset<T, MechanicConfirmationDeleteArgs<ExtArgs>>): Prisma__MechanicConfirmationClient<$Result.GetResult<Prisma.$MechanicConfirmationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one MechanicConfirmation.
     * @param {MechanicConfirmationUpdateArgs} args - Arguments to update one MechanicConfirmation.
     * @example
     * // Update one MechanicConfirmation
     * const mechanicConfirmation = await prisma.mechanicConfirmation.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MechanicConfirmationUpdateArgs>(args: SelectSubset<T, MechanicConfirmationUpdateArgs<ExtArgs>>): Prisma__MechanicConfirmationClient<$Result.GetResult<Prisma.$MechanicConfirmationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more MechanicConfirmations.
     * @param {MechanicConfirmationDeleteManyArgs} args - Arguments to filter MechanicConfirmations to delete.
     * @example
     * // Delete a few MechanicConfirmations
     * const { count } = await prisma.mechanicConfirmation.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MechanicConfirmationDeleteManyArgs>(args?: SelectSubset<T, MechanicConfirmationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MechanicConfirmations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MechanicConfirmationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many MechanicConfirmations
     * const mechanicConfirmation = await prisma.mechanicConfirmation.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MechanicConfirmationUpdateManyArgs>(args: SelectSubset<T, MechanicConfirmationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one MechanicConfirmation.
     * @param {MechanicConfirmationUpsertArgs} args - Arguments to update or create a MechanicConfirmation.
     * @example
     * // Update or create a MechanicConfirmation
     * const mechanicConfirmation = await prisma.mechanicConfirmation.upsert({
     *   create: {
     *     // ... data to create a MechanicConfirmation
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the MechanicConfirmation we want to update
     *   }
     * })
     */
    upsert<T extends MechanicConfirmationUpsertArgs>(args: SelectSubset<T, MechanicConfirmationUpsertArgs<ExtArgs>>): Prisma__MechanicConfirmationClient<$Result.GetResult<Prisma.$MechanicConfirmationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more MechanicConfirmations that matches the filter.
     * @param {MechanicConfirmationFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const mechanicConfirmation = await prisma.mechanicConfirmation.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: MechanicConfirmationFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a MechanicConfirmation.
     * @param {MechanicConfirmationAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const mechanicConfirmation = await prisma.mechanicConfirmation.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: MechanicConfirmationAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of MechanicConfirmations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MechanicConfirmationCountArgs} args - Arguments to filter MechanicConfirmations to count.
     * @example
     * // Count the number of MechanicConfirmations
     * const count = await prisma.mechanicConfirmation.count({
     *   where: {
     *     // ... the filter for the MechanicConfirmations we want to count
     *   }
     * })
    **/
    count<T extends MechanicConfirmationCountArgs>(
      args?: Subset<T, MechanicConfirmationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MechanicConfirmationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a MechanicConfirmation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MechanicConfirmationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MechanicConfirmationAggregateArgs>(args: Subset<T, MechanicConfirmationAggregateArgs>): Prisma.PrismaPromise<GetMechanicConfirmationAggregateType<T>>

    /**
     * Group by MechanicConfirmation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MechanicConfirmationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MechanicConfirmationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MechanicConfirmationGroupByArgs['orderBy'] }
        : { orderBy?: MechanicConfirmationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MechanicConfirmationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMechanicConfirmationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the MechanicConfirmation model
   */
  readonly fields: MechanicConfirmationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for MechanicConfirmation.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MechanicConfirmationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    mechanic<T extends MechanicDefaultArgs<ExtArgs> = {}>(args?: Subset<T, MechanicDefaultArgs<ExtArgs>>): Prisma__MechanicClient<$Result.GetResult<Prisma.$MechanicPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    serviceRequest<T extends ServiceRequestDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ServiceRequestDefaultArgs<ExtArgs>>): Prisma__ServiceRequestClient<$Result.GetResult<Prisma.$ServiceRequestPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the MechanicConfirmation model
   */ 
  interface MechanicConfirmationFieldRefs {
    readonly id: FieldRef<"MechanicConfirmation", 'String'>
    readonly mechanicId: FieldRef<"MechanicConfirmation", 'String'>
    readonly serviceRequestId: FieldRef<"MechanicConfirmation", 'String'>
    readonly status: FieldRef<"MechanicConfirmation", 'ConfirmationStatus'>
    readonly distanceText: FieldRef<"MechanicConfirmation", 'String'>
    readonly distanceValue: FieldRef<"MechanicConfirmation", 'Int'>
    readonly durationText: FieldRef<"MechanicConfirmation", 'String'>
    readonly durationValue: FieldRef<"MechanicConfirmation", 'Int'>
    readonly estimatedCost: FieldRef<"MechanicConfirmation", 'Float'>
    readonly respondedAt: FieldRef<"MechanicConfirmation", 'DateTime'>
    readonly createdAt: FieldRef<"MechanicConfirmation", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * MechanicConfirmation findUnique
   */
  export type MechanicConfirmationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MechanicConfirmation
     */
    select?: MechanicConfirmationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MechanicConfirmation
     */
    omit?: MechanicConfirmationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MechanicConfirmationInclude<ExtArgs> | null
    /**
     * Filter, which MechanicConfirmation to fetch.
     */
    where: MechanicConfirmationWhereUniqueInput
  }

  /**
   * MechanicConfirmation findUniqueOrThrow
   */
  export type MechanicConfirmationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MechanicConfirmation
     */
    select?: MechanicConfirmationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MechanicConfirmation
     */
    omit?: MechanicConfirmationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MechanicConfirmationInclude<ExtArgs> | null
    /**
     * Filter, which MechanicConfirmation to fetch.
     */
    where: MechanicConfirmationWhereUniqueInput
  }

  /**
   * MechanicConfirmation findFirst
   */
  export type MechanicConfirmationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MechanicConfirmation
     */
    select?: MechanicConfirmationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MechanicConfirmation
     */
    omit?: MechanicConfirmationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MechanicConfirmationInclude<ExtArgs> | null
    /**
     * Filter, which MechanicConfirmation to fetch.
     */
    where?: MechanicConfirmationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MechanicConfirmations to fetch.
     */
    orderBy?: MechanicConfirmationOrderByWithRelationInput | MechanicConfirmationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MechanicConfirmations.
     */
    cursor?: MechanicConfirmationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MechanicConfirmations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MechanicConfirmations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MechanicConfirmations.
     */
    distinct?: MechanicConfirmationScalarFieldEnum | MechanicConfirmationScalarFieldEnum[]
  }

  /**
   * MechanicConfirmation findFirstOrThrow
   */
  export type MechanicConfirmationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MechanicConfirmation
     */
    select?: MechanicConfirmationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MechanicConfirmation
     */
    omit?: MechanicConfirmationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MechanicConfirmationInclude<ExtArgs> | null
    /**
     * Filter, which MechanicConfirmation to fetch.
     */
    where?: MechanicConfirmationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MechanicConfirmations to fetch.
     */
    orderBy?: MechanicConfirmationOrderByWithRelationInput | MechanicConfirmationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MechanicConfirmations.
     */
    cursor?: MechanicConfirmationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MechanicConfirmations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MechanicConfirmations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MechanicConfirmations.
     */
    distinct?: MechanicConfirmationScalarFieldEnum | MechanicConfirmationScalarFieldEnum[]
  }

  /**
   * MechanicConfirmation findMany
   */
  export type MechanicConfirmationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MechanicConfirmation
     */
    select?: MechanicConfirmationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MechanicConfirmation
     */
    omit?: MechanicConfirmationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MechanicConfirmationInclude<ExtArgs> | null
    /**
     * Filter, which MechanicConfirmations to fetch.
     */
    where?: MechanicConfirmationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MechanicConfirmations to fetch.
     */
    orderBy?: MechanicConfirmationOrderByWithRelationInput | MechanicConfirmationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing MechanicConfirmations.
     */
    cursor?: MechanicConfirmationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MechanicConfirmations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MechanicConfirmations.
     */
    skip?: number
    distinct?: MechanicConfirmationScalarFieldEnum | MechanicConfirmationScalarFieldEnum[]
  }

  /**
   * MechanicConfirmation create
   */
  export type MechanicConfirmationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MechanicConfirmation
     */
    select?: MechanicConfirmationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MechanicConfirmation
     */
    omit?: MechanicConfirmationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MechanicConfirmationInclude<ExtArgs> | null
    /**
     * The data needed to create a MechanicConfirmation.
     */
    data: XOR<MechanicConfirmationCreateInput, MechanicConfirmationUncheckedCreateInput>
  }

  /**
   * MechanicConfirmation createMany
   */
  export type MechanicConfirmationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many MechanicConfirmations.
     */
    data: MechanicConfirmationCreateManyInput | MechanicConfirmationCreateManyInput[]
  }

  /**
   * MechanicConfirmation update
   */
  export type MechanicConfirmationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MechanicConfirmation
     */
    select?: MechanicConfirmationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MechanicConfirmation
     */
    omit?: MechanicConfirmationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MechanicConfirmationInclude<ExtArgs> | null
    /**
     * The data needed to update a MechanicConfirmation.
     */
    data: XOR<MechanicConfirmationUpdateInput, MechanicConfirmationUncheckedUpdateInput>
    /**
     * Choose, which MechanicConfirmation to update.
     */
    where: MechanicConfirmationWhereUniqueInput
  }

  /**
   * MechanicConfirmation updateMany
   */
  export type MechanicConfirmationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update MechanicConfirmations.
     */
    data: XOR<MechanicConfirmationUpdateManyMutationInput, MechanicConfirmationUncheckedUpdateManyInput>
    /**
     * Filter which MechanicConfirmations to update
     */
    where?: MechanicConfirmationWhereInput
    /**
     * Limit how many MechanicConfirmations to update.
     */
    limit?: number
  }

  /**
   * MechanicConfirmation upsert
   */
  export type MechanicConfirmationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MechanicConfirmation
     */
    select?: MechanicConfirmationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MechanicConfirmation
     */
    omit?: MechanicConfirmationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MechanicConfirmationInclude<ExtArgs> | null
    /**
     * The filter to search for the MechanicConfirmation to update in case it exists.
     */
    where: MechanicConfirmationWhereUniqueInput
    /**
     * In case the MechanicConfirmation found by the `where` argument doesn't exist, create a new MechanicConfirmation with this data.
     */
    create: XOR<MechanicConfirmationCreateInput, MechanicConfirmationUncheckedCreateInput>
    /**
     * In case the MechanicConfirmation was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MechanicConfirmationUpdateInput, MechanicConfirmationUncheckedUpdateInput>
  }

  /**
   * MechanicConfirmation delete
   */
  export type MechanicConfirmationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MechanicConfirmation
     */
    select?: MechanicConfirmationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MechanicConfirmation
     */
    omit?: MechanicConfirmationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MechanicConfirmationInclude<ExtArgs> | null
    /**
     * Filter which MechanicConfirmation to delete.
     */
    where: MechanicConfirmationWhereUniqueInput
  }

  /**
   * MechanicConfirmation deleteMany
   */
  export type MechanicConfirmationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MechanicConfirmations to delete
     */
    where?: MechanicConfirmationWhereInput
    /**
     * Limit how many MechanicConfirmations to delete.
     */
    limit?: number
  }

  /**
   * MechanicConfirmation findRaw
   */
  export type MechanicConfirmationFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * MechanicConfirmation aggregateRaw
   */
  export type MechanicConfirmationAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * MechanicConfirmation without action
   */
  export type MechanicConfirmationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MechanicConfirmation
     */
    select?: MechanicConfirmationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MechanicConfirmation
     */
    omit?: MechanicConfirmationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MechanicConfirmationInclude<ExtArgs> | null
  }


  /**
   * Model Mechanic
   */

  export type AggregateMechanic = {
    _count: MechanicCountAggregateOutputType | null
    _avg: MechanicAvgAggregateOutputType | null
    _sum: MechanicSumAggregateOutputType | null
    _min: MechanicMinAggregateOutputType | null
    _max: MechanicMaxAggregateOutputType | null
  }

  export type MechanicAvgAggregateOutputType = {
    latitude: number | null
    longitude: number | null
  }

  export type MechanicSumAggregateOutputType = {
    latitude: number | null
    longitude: number | null
  }

  export type MechanicMinAggregateOutputType = {
    id: string | null
    name: string | null
    email: string | null
    phoneNumber: string | null
    latitude: number | null
    longitude: number | null
    expoToken: string | null
  }

  export type MechanicMaxAggregateOutputType = {
    id: string | null
    name: string | null
    email: string | null
    phoneNumber: string | null
    latitude: number | null
    longitude: number | null
    expoToken: string | null
  }

  export type MechanicCountAggregateOutputType = {
    id: number
    name: number
    email: number
    phoneNumber: number
    services: number
    latitude: number
    longitude: number
    location: number
    expoToken: number
    _all: number
  }


  export type MechanicAvgAggregateInputType = {
    latitude?: true
    longitude?: true
  }

  export type MechanicSumAggregateInputType = {
    latitude?: true
    longitude?: true
  }

  export type MechanicMinAggregateInputType = {
    id?: true
    name?: true
    email?: true
    phoneNumber?: true
    latitude?: true
    longitude?: true
    expoToken?: true
  }

  export type MechanicMaxAggregateInputType = {
    id?: true
    name?: true
    email?: true
    phoneNumber?: true
    latitude?: true
    longitude?: true
    expoToken?: true
  }

  export type MechanicCountAggregateInputType = {
    id?: true
    name?: true
    email?: true
    phoneNumber?: true
    services?: true
    latitude?: true
    longitude?: true
    location?: true
    expoToken?: true
    _all?: true
  }

  export type MechanicAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Mechanic to aggregate.
     */
    where?: MechanicWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Mechanics to fetch.
     */
    orderBy?: MechanicOrderByWithRelationInput | MechanicOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MechanicWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Mechanics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Mechanics.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Mechanics
    **/
    _count?: true | MechanicCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MechanicAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MechanicSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MechanicMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MechanicMaxAggregateInputType
  }

  export type GetMechanicAggregateType<T extends MechanicAggregateArgs> = {
        [P in keyof T & keyof AggregateMechanic]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMechanic[P]>
      : GetScalarType<T[P], AggregateMechanic[P]>
  }




  export type MechanicGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MechanicWhereInput
    orderBy?: MechanicOrderByWithAggregationInput | MechanicOrderByWithAggregationInput[]
    by: MechanicScalarFieldEnum[] | MechanicScalarFieldEnum
    having?: MechanicScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MechanicCountAggregateInputType | true
    _avg?: MechanicAvgAggregateInputType
    _sum?: MechanicSumAggregateInputType
    _min?: MechanicMinAggregateInputType
    _max?: MechanicMaxAggregateInputType
  }

  export type MechanicGroupByOutputType = {
    id: string
    name: string | null
    email: string | null
    phoneNumber: string
    services: $Enums.ServiceType[]
    latitude: number | null
    longitude: number | null
    location: JsonValue | null
    expoToken: string | null
    _count: MechanicCountAggregateOutputType | null
    _avg: MechanicAvgAggregateOutputType | null
    _sum: MechanicSumAggregateOutputType | null
    _min: MechanicMinAggregateOutputType | null
    _max: MechanicMaxAggregateOutputType | null
  }

  type GetMechanicGroupByPayload<T extends MechanicGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MechanicGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MechanicGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MechanicGroupByOutputType[P]>
            : GetScalarType<T[P], MechanicGroupByOutputType[P]>
        }
      >
    >


  export type MechanicSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    email?: boolean
    phoneNumber?: boolean
    services?: boolean
    latitude?: boolean
    longitude?: boolean
    location?: boolean
    expoToken?: boolean
    serviceRequests?: boolean | Mechanic$serviceRequestsArgs<ExtArgs>
    reviews?: boolean | Mechanic$reviewsArgs<ExtArgs>
    sentMessages?: boolean | Mechanic$sentMessagesArgs<ExtArgs>
    MechanicConfirmation?: boolean | Mechanic$MechanicConfirmationArgs<ExtArgs>
    _count?: boolean | MechanicCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["mechanic"]>



  export type MechanicSelectScalar = {
    id?: boolean
    name?: boolean
    email?: boolean
    phoneNumber?: boolean
    services?: boolean
    latitude?: boolean
    longitude?: boolean
    location?: boolean
    expoToken?: boolean
  }

  export type MechanicOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "email" | "phoneNumber" | "services" | "latitude" | "longitude" | "location" | "expoToken", ExtArgs["result"]["mechanic"]>
  export type MechanicInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    serviceRequests?: boolean | Mechanic$serviceRequestsArgs<ExtArgs>
    reviews?: boolean | Mechanic$reviewsArgs<ExtArgs>
    sentMessages?: boolean | Mechanic$sentMessagesArgs<ExtArgs>
    MechanicConfirmation?: boolean | Mechanic$MechanicConfirmationArgs<ExtArgs>
    _count?: boolean | MechanicCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $MechanicPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Mechanic"
    objects: {
      serviceRequests: Prisma.$ServiceRequestPayload<ExtArgs>[]
      reviews: Prisma.$ReviewPayload<ExtArgs>[]
      sentMessages: Prisma.$MessagePayload<ExtArgs>[]
      MechanicConfirmation: Prisma.$MechanicConfirmationPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string | null
      email: string | null
      phoneNumber: string
      services: $Enums.ServiceType[]
      latitude: number | null
      longitude: number | null
      location: Prisma.JsonValue | null
      expoToken: string | null
    }, ExtArgs["result"]["mechanic"]>
    composites: {}
  }

  type MechanicGetPayload<S extends boolean | null | undefined | MechanicDefaultArgs> = $Result.GetResult<Prisma.$MechanicPayload, S>

  type MechanicCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<MechanicFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: MechanicCountAggregateInputType | true
    }

  export interface MechanicDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Mechanic'], meta: { name: 'Mechanic' } }
    /**
     * Find zero or one Mechanic that matches the filter.
     * @param {MechanicFindUniqueArgs} args - Arguments to find a Mechanic
     * @example
     * // Get one Mechanic
     * const mechanic = await prisma.mechanic.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MechanicFindUniqueArgs>(args: SelectSubset<T, MechanicFindUniqueArgs<ExtArgs>>): Prisma__MechanicClient<$Result.GetResult<Prisma.$MechanicPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Mechanic that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {MechanicFindUniqueOrThrowArgs} args - Arguments to find a Mechanic
     * @example
     * // Get one Mechanic
     * const mechanic = await prisma.mechanic.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MechanicFindUniqueOrThrowArgs>(args: SelectSubset<T, MechanicFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MechanicClient<$Result.GetResult<Prisma.$MechanicPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Mechanic that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MechanicFindFirstArgs} args - Arguments to find a Mechanic
     * @example
     * // Get one Mechanic
     * const mechanic = await prisma.mechanic.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MechanicFindFirstArgs>(args?: SelectSubset<T, MechanicFindFirstArgs<ExtArgs>>): Prisma__MechanicClient<$Result.GetResult<Prisma.$MechanicPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Mechanic that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MechanicFindFirstOrThrowArgs} args - Arguments to find a Mechanic
     * @example
     * // Get one Mechanic
     * const mechanic = await prisma.mechanic.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MechanicFindFirstOrThrowArgs>(args?: SelectSubset<T, MechanicFindFirstOrThrowArgs<ExtArgs>>): Prisma__MechanicClient<$Result.GetResult<Prisma.$MechanicPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Mechanics that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MechanicFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Mechanics
     * const mechanics = await prisma.mechanic.findMany()
     * 
     * // Get first 10 Mechanics
     * const mechanics = await prisma.mechanic.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const mechanicWithIdOnly = await prisma.mechanic.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MechanicFindManyArgs>(args?: SelectSubset<T, MechanicFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MechanicPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Mechanic.
     * @param {MechanicCreateArgs} args - Arguments to create a Mechanic.
     * @example
     * // Create one Mechanic
     * const Mechanic = await prisma.mechanic.create({
     *   data: {
     *     // ... data to create a Mechanic
     *   }
     * })
     * 
     */
    create<T extends MechanicCreateArgs>(args: SelectSubset<T, MechanicCreateArgs<ExtArgs>>): Prisma__MechanicClient<$Result.GetResult<Prisma.$MechanicPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Mechanics.
     * @param {MechanicCreateManyArgs} args - Arguments to create many Mechanics.
     * @example
     * // Create many Mechanics
     * const mechanic = await prisma.mechanic.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MechanicCreateManyArgs>(args?: SelectSubset<T, MechanicCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Mechanic.
     * @param {MechanicDeleteArgs} args - Arguments to delete one Mechanic.
     * @example
     * // Delete one Mechanic
     * const Mechanic = await prisma.mechanic.delete({
     *   where: {
     *     // ... filter to delete one Mechanic
     *   }
     * })
     * 
     */
    delete<T extends MechanicDeleteArgs>(args: SelectSubset<T, MechanicDeleteArgs<ExtArgs>>): Prisma__MechanicClient<$Result.GetResult<Prisma.$MechanicPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Mechanic.
     * @param {MechanicUpdateArgs} args - Arguments to update one Mechanic.
     * @example
     * // Update one Mechanic
     * const mechanic = await prisma.mechanic.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MechanicUpdateArgs>(args: SelectSubset<T, MechanicUpdateArgs<ExtArgs>>): Prisma__MechanicClient<$Result.GetResult<Prisma.$MechanicPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Mechanics.
     * @param {MechanicDeleteManyArgs} args - Arguments to filter Mechanics to delete.
     * @example
     * // Delete a few Mechanics
     * const { count } = await prisma.mechanic.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MechanicDeleteManyArgs>(args?: SelectSubset<T, MechanicDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Mechanics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MechanicUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Mechanics
     * const mechanic = await prisma.mechanic.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MechanicUpdateManyArgs>(args: SelectSubset<T, MechanicUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Mechanic.
     * @param {MechanicUpsertArgs} args - Arguments to update or create a Mechanic.
     * @example
     * // Update or create a Mechanic
     * const mechanic = await prisma.mechanic.upsert({
     *   create: {
     *     // ... data to create a Mechanic
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Mechanic we want to update
     *   }
     * })
     */
    upsert<T extends MechanicUpsertArgs>(args: SelectSubset<T, MechanicUpsertArgs<ExtArgs>>): Prisma__MechanicClient<$Result.GetResult<Prisma.$MechanicPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Mechanics that matches the filter.
     * @param {MechanicFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const mechanic = await prisma.mechanic.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: MechanicFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a Mechanic.
     * @param {MechanicAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const mechanic = await prisma.mechanic.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: MechanicAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of Mechanics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MechanicCountArgs} args - Arguments to filter Mechanics to count.
     * @example
     * // Count the number of Mechanics
     * const count = await prisma.mechanic.count({
     *   where: {
     *     // ... the filter for the Mechanics we want to count
     *   }
     * })
    **/
    count<T extends MechanicCountArgs>(
      args?: Subset<T, MechanicCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MechanicCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Mechanic.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MechanicAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MechanicAggregateArgs>(args: Subset<T, MechanicAggregateArgs>): Prisma.PrismaPromise<GetMechanicAggregateType<T>>

    /**
     * Group by Mechanic.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MechanicGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MechanicGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MechanicGroupByArgs['orderBy'] }
        : { orderBy?: MechanicGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MechanicGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMechanicGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Mechanic model
   */
  readonly fields: MechanicFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Mechanic.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MechanicClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    serviceRequests<T extends Mechanic$serviceRequestsArgs<ExtArgs> = {}>(args?: Subset<T, Mechanic$serviceRequestsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ServiceRequestPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    reviews<T extends Mechanic$reviewsArgs<ExtArgs> = {}>(args?: Subset<T, Mechanic$reviewsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReviewPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    sentMessages<T extends Mechanic$sentMessagesArgs<ExtArgs> = {}>(args?: Subset<T, Mechanic$sentMessagesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    MechanicConfirmation<T extends Mechanic$MechanicConfirmationArgs<ExtArgs> = {}>(args?: Subset<T, Mechanic$MechanicConfirmationArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MechanicConfirmationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Mechanic model
   */ 
  interface MechanicFieldRefs {
    readonly id: FieldRef<"Mechanic", 'String'>
    readonly name: FieldRef<"Mechanic", 'String'>
    readonly email: FieldRef<"Mechanic", 'String'>
    readonly phoneNumber: FieldRef<"Mechanic", 'String'>
    readonly services: FieldRef<"Mechanic", 'ServiceType[]'>
    readonly latitude: FieldRef<"Mechanic", 'Float'>
    readonly longitude: FieldRef<"Mechanic", 'Float'>
    readonly location: FieldRef<"Mechanic", 'Json'>
    readonly expoToken: FieldRef<"Mechanic", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Mechanic findUnique
   */
  export type MechanicFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Mechanic
     */
    select?: MechanicSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Mechanic
     */
    omit?: MechanicOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MechanicInclude<ExtArgs> | null
    /**
     * Filter, which Mechanic to fetch.
     */
    where: MechanicWhereUniqueInput
  }

  /**
   * Mechanic findUniqueOrThrow
   */
  export type MechanicFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Mechanic
     */
    select?: MechanicSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Mechanic
     */
    omit?: MechanicOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MechanicInclude<ExtArgs> | null
    /**
     * Filter, which Mechanic to fetch.
     */
    where: MechanicWhereUniqueInput
  }

  /**
   * Mechanic findFirst
   */
  export type MechanicFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Mechanic
     */
    select?: MechanicSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Mechanic
     */
    omit?: MechanicOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MechanicInclude<ExtArgs> | null
    /**
     * Filter, which Mechanic to fetch.
     */
    where?: MechanicWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Mechanics to fetch.
     */
    orderBy?: MechanicOrderByWithRelationInput | MechanicOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Mechanics.
     */
    cursor?: MechanicWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Mechanics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Mechanics.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Mechanics.
     */
    distinct?: MechanicScalarFieldEnum | MechanicScalarFieldEnum[]
  }

  /**
   * Mechanic findFirstOrThrow
   */
  export type MechanicFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Mechanic
     */
    select?: MechanicSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Mechanic
     */
    omit?: MechanicOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MechanicInclude<ExtArgs> | null
    /**
     * Filter, which Mechanic to fetch.
     */
    where?: MechanicWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Mechanics to fetch.
     */
    orderBy?: MechanicOrderByWithRelationInput | MechanicOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Mechanics.
     */
    cursor?: MechanicWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Mechanics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Mechanics.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Mechanics.
     */
    distinct?: MechanicScalarFieldEnum | MechanicScalarFieldEnum[]
  }

  /**
   * Mechanic findMany
   */
  export type MechanicFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Mechanic
     */
    select?: MechanicSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Mechanic
     */
    omit?: MechanicOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MechanicInclude<ExtArgs> | null
    /**
     * Filter, which Mechanics to fetch.
     */
    where?: MechanicWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Mechanics to fetch.
     */
    orderBy?: MechanicOrderByWithRelationInput | MechanicOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Mechanics.
     */
    cursor?: MechanicWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Mechanics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Mechanics.
     */
    skip?: number
    distinct?: MechanicScalarFieldEnum | MechanicScalarFieldEnum[]
  }

  /**
   * Mechanic create
   */
  export type MechanicCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Mechanic
     */
    select?: MechanicSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Mechanic
     */
    omit?: MechanicOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MechanicInclude<ExtArgs> | null
    /**
     * The data needed to create a Mechanic.
     */
    data: XOR<MechanicCreateInput, MechanicUncheckedCreateInput>
  }

  /**
   * Mechanic createMany
   */
  export type MechanicCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Mechanics.
     */
    data: MechanicCreateManyInput | MechanicCreateManyInput[]
  }

  /**
   * Mechanic update
   */
  export type MechanicUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Mechanic
     */
    select?: MechanicSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Mechanic
     */
    omit?: MechanicOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MechanicInclude<ExtArgs> | null
    /**
     * The data needed to update a Mechanic.
     */
    data: XOR<MechanicUpdateInput, MechanicUncheckedUpdateInput>
    /**
     * Choose, which Mechanic to update.
     */
    where: MechanicWhereUniqueInput
  }

  /**
   * Mechanic updateMany
   */
  export type MechanicUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Mechanics.
     */
    data: XOR<MechanicUpdateManyMutationInput, MechanicUncheckedUpdateManyInput>
    /**
     * Filter which Mechanics to update
     */
    where?: MechanicWhereInput
    /**
     * Limit how many Mechanics to update.
     */
    limit?: number
  }

  /**
   * Mechanic upsert
   */
  export type MechanicUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Mechanic
     */
    select?: MechanicSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Mechanic
     */
    omit?: MechanicOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MechanicInclude<ExtArgs> | null
    /**
     * The filter to search for the Mechanic to update in case it exists.
     */
    where: MechanicWhereUniqueInput
    /**
     * In case the Mechanic found by the `where` argument doesn't exist, create a new Mechanic with this data.
     */
    create: XOR<MechanicCreateInput, MechanicUncheckedCreateInput>
    /**
     * In case the Mechanic was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MechanicUpdateInput, MechanicUncheckedUpdateInput>
  }

  /**
   * Mechanic delete
   */
  export type MechanicDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Mechanic
     */
    select?: MechanicSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Mechanic
     */
    omit?: MechanicOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MechanicInclude<ExtArgs> | null
    /**
     * Filter which Mechanic to delete.
     */
    where: MechanicWhereUniqueInput
  }

  /**
   * Mechanic deleteMany
   */
  export type MechanicDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Mechanics to delete
     */
    where?: MechanicWhereInput
    /**
     * Limit how many Mechanics to delete.
     */
    limit?: number
  }

  /**
   * Mechanic findRaw
   */
  export type MechanicFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * Mechanic aggregateRaw
   */
  export type MechanicAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * Mechanic.serviceRequests
   */
  export type Mechanic$serviceRequestsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceRequest
     */
    select?: ServiceRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceRequest
     */
    omit?: ServiceRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceRequestInclude<ExtArgs> | null
    where?: ServiceRequestWhereInput
    orderBy?: ServiceRequestOrderByWithRelationInput | ServiceRequestOrderByWithRelationInput[]
    cursor?: ServiceRequestWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ServiceRequestScalarFieldEnum | ServiceRequestScalarFieldEnum[]
  }

  /**
   * Mechanic.reviews
   */
  export type Mechanic$reviewsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Review
     */
    omit?: ReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewInclude<ExtArgs> | null
    where?: ReviewWhereInput
    orderBy?: ReviewOrderByWithRelationInput | ReviewOrderByWithRelationInput[]
    cursor?: ReviewWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ReviewScalarFieldEnum | ReviewScalarFieldEnum[]
  }

  /**
   * Mechanic.sentMessages
   */
  export type Mechanic$sentMessagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    where?: MessageWhereInput
    orderBy?: MessageOrderByWithRelationInput | MessageOrderByWithRelationInput[]
    cursor?: MessageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MessageScalarFieldEnum | MessageScalarFieldEnum[]
  }

  /**
   * Mechanic.MechanicConfirmation
   */
  export type Mechanic$MechanicConfirmationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MechanicConfirmation
     */
    select?: MechanicConfirmationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MechanicConfirmation
     */
    omit?: MechanicConfirmationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MechanicConfirmationInclude<ExtArgs> | null
    where?: MechanicConfirmationWhereInput
    orderBy?: MechanicConfirmationOrderByWithRelationInput | MechanicConfirmationOrderByWithRelationInput[]
    cursor?: MechanicConfirmationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MechanicConfirmationScalarFieldEnum | MechanicConfirmationScalarFieldEnum[]
  }

  /**
   * Mechanic without action
   */
  export type MechanicDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Mechanic
     */
    select?: MechanicSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Mechanic
     */
    omit?: MechanicOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MechanicInclude<ExtArgs> | null
  }


  /**
   * Model Car
   */

  export type AggregateCar = {
    _count: CarCountAggregateOutputType | null
    _avg: CarAvgAggregateOutputType | null
    _sum: CarSumAggregateOutputType | null
    _min: CarMinAggregateOutputType | null
    _max: CarMaxAggregateOutputType | null
  }

  export type CarAvgAggregateOutputType = {
    year: number | null
  }

  export type CarSumAggregateOutputType = {
    year: number | null
  }

  export type CarMinAggregateOutputType = {
    id: string | null
    userId: string | null
    make: string | null
    model: string | null
    year: number | null
    licensePlate: string | null
  }

  export type CarMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    make: string | null
    model: string | null
    year: number | null
    licensePlate: string | null
  }

  export type CarCountAggregateOutputType = {
    id: number
    userId: number
    make: number
    model: number
    year: number
    licensePlate: number
    _all: number
  }


  export type CarAvgAggregateInputType = {
    year?: true
  }

  export type CarSumAggregateInputType = {
    year?: true
  }

  export type CarMinAggregateInputType = {
    id?: true
    userId?: true
    make?: true
    model?: true
    year?: true
    licensePlate?: true
  }

  export type CarMaxAggregateInputType = {
    id?: true
    userId?: true
    make?: true
    model?: true
    year?: true
    licensePlate?: true
  }

  export type CarCountAggregateInputType = {
    id?: true
    userId?: true
    make?: true
    model?: true
    year?: true
    licensePlate?: true
    _all?: true
  }

  export type CarAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Car to aggregate.
     */
    where?: CarWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Cars to fetch.
     */
    orderBy?: CarOrderByWithRelationInput | CarOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CarWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Cars from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Cars.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Cars
    **/
    _count?: true | CarCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CarAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CarSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CarMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CarMaxAggregateInputType
  }

  export type GetCarAggregateType<T extends CarAggregateArgs> = {
        [P in keyof T & keyof AggregateCar]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCar[P]>
      : GetScalarType<T[P], AggregateCar[P]>
  }




  export type CarGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CarWhereInput
    orderBy?: CarOrderByWithAggregationInput | CarOrderByWithAggregationInput[]
    by: CarScalarFieldEnum[] | CarScalarFieldEnum
    having?: CarScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CarCountAggregateInputType | true
    _avg?: CarAvgAggregateInputType
    _sum?: CarSumAggregateInputType
    _min?: CarMinAggregateInputType
    _max?: CarMaxAggregateInputType
  }

  export type CarGroupByOutputType = {
    id: string
    userId: string
    make: string
    model: string
    year: number
    licensePlate: string
    _count: CarCountAggregateOutputType | null
    _avg: CarAvgAggregateOutputType | null
    _sum: CarSumAggregateOutputType | null
    _min: CarMinAggregateOutputType | null
    _max: CarMaxAggregateOutputType | null
  }

  type GetCarGroupByPayload<T extends CarGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CarGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CarGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CarGroupByOutputType[P]>
            : GetScalarType<T[P], CarGroupByOutputType[P]>
        }
      >
    >


  export type CarSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    make?: boolean
    model?: boolean
    year?: boolean
    licensePlate?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["car"]>



  export type CarSelectScalar = {
    id?: boolean
    userId?: boolean
    make?: boolean
    model?: boolean
    year?: boolean
    licensePlate?: boolean
  }

  export type CarOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "make" | "model" | "year" | "licensePlate", ExtArgs["result"]["car"]>
  export type CarInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $CarPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Car"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      make: string
      model: string
      year: number
      licensePlate: string
    }, ExtArgs["result"]["car"]>
    composites: {}
  }

  type CarGetPayload<S extends boolean | null | undefined | CarDefaultArgs> = $Result.GetResult<Prisma.$CarPayload, S>

  type CarCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CarFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CarCountAggregateInputType | true
    }

  export interface CarDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Car'], meta: { name: 'Car' } }
    /**
     * Find zero or one Car that matches the filter.
     * @param {CarFindUniqueArgs} args - Arguments to find a Car
     * @example
     * // Get one Car
     * const car = await prisma.car.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CarFindUniqueArgs>(args: SelectSubset<T, CarFindUniqueArgs<ExtArgs>>): Prisma__CarClient<$Result.GetResult<Prisma.$CarPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Car that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CarFindUniqueOrThrowArgs} args - Arguments to find a Car
     * @example
     * // Get one Car
     * const car = await prisma.car.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CarFindUniqueOrThrowArgs>(args: SelectSubset<T, CarFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CarClient<$Result.GetResult<Prisma.$CarPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Car that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CarFindFirstArgs} args - Arguments to find a Car
     * @example
     * // Get one Car
     * const car = await prisma.car.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CarFindFirstArgs>(args?: SelectSubset<T, CarFindFirstArgs<ExtArgs>>): Prisma__CarClient<$Result.GetResult<Prisma.$CarPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Car that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CarFindFirstOrThrowArgs} args - Arguments to find a Car
     * @example
     * // Get one Car
     * const car = await prisma.car.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CarFindFirstOrThrowArgs>(args?: SelectSubset<T, CarFindFirstOrThrowArgs<ExtArgs>>): Prisma__CarClient<$Result.GetResult<Prisma.$CarPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Cars that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CarFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Cars
     * const cars = await prisma.car.findMany()
     * 
     * // Get first 10 Cars
     * const cars = await prisma.car.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const carWithIdOnly = await prisma.car.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CarFindManyArgs>(args?: SelectSubset<T, CarFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CarPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Car.
     * @param {CarCreateArgs} args - Arguments to create a Car.
     * @example
     * // Create one Car
     * const Car = await prisma.car.create({
     *   data: {
     *     // ... data to create a Car
     *   }
     * })
     * 
     */
    create<T extends CarCreateArgs>(args: SelectSubset<T, CarCreateArgs<ExtArgs>>): Prisma__CarClient<$Result.GetResult<Prisma.$CarPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Cars.
     * @param {CarCreateManyArgs} args - Arguments to create many Cars.
     * @example
     * // Create many Cars
     * const car = await prisma.car.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CarCreateManyArgs>(args?: SelectSubset<T, CarCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Car.
     * @param {CarDeleteArgs} args - Arguments to delete one Car.
     * @example
     * // Delete one Car
     * const Car = await prisma.car.delete({
     *   where: {
     *     // ... filter to delete one Car
     *   }
     * })
     * 
     */
    delete<T extends CarDeleteArgs>(args: SelectSubset<T, CarDeleteArgs<ExtArgs>>): Prisma__CarClient<$Result.GetResult<Prisma.$CarPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Car.
     * @param {CarUpdateArgs} args - Arguments to update one Car.
     * @example
     * // Update one Car
     * const car = await prisma.car.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CarUpdateArgs>(args: SelectSubset<T, CarUpdateArgs<ExtArgs>>): Prisma__CarClient<$Result.GetResult<Prisma.$CarPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Cars.
     * @param {CarDeleteManyArgs} args - Arguments to filter Cars to delete.
     * @example
     * // Delete a few Cars
     * const { count } = await prisma.car.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CarDeleteManyArgs>(args?: SelectSubset<T, CarDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Cars.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CarUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Cars
     * const car = await prisma.car.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CarUpdateManyArgs>(args: SelectSubset<T, CarUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Car.
     * @param {CarUpsertArgs} args - Arguments to update or create a Car.
     * @example
     * // Update or create a Car
     * const car = await prisma.car.upsert({
     *   create: {
     *     // ... data to create a Car
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Car we want to update
     *   }
     * })
     */
    upsert<T extends CarUpsertArgs>(args: SelectSubset<T, CarUpsertArgs<ExtArgs>>): Prisma__CarClient<$Result.GetResult<Prisma.$CarPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Cars that matches the filter.
     * @param {CarFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const car = await prisma.car.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: CarFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a Car.
     * @param {CarAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const car = await prisma.car.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: CarAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of Cars.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CarCountArgs} args - Arguments to filter Cars to count.
     * @example
     * // Count the number of Cars
     * const count = await prisma.car.count({
     *   where: {
     *     // ... the filter for the Cars we want to count
     *   }
     * })
    **/
    count<T extends CarCountArgs>(
      args?: Subset<T, CarCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CarCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Car.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CarAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CarAggregateArgs>(args: Subset<T, CarAggregateArgs>): Prisma.PrismaPromise<GetCarAggregateType<T>>

    /**
     * Group by Car.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CarGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CarGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CarGroupByArgs['orderBy'] }
        : { orderBy?: CarGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CarGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCarGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Car model
   */
  readonly fields: CarFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Car.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CarClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Car model
   */ 
  interface CarFieldRefs {
    readonly id: FieldRef<"Car", 'String'>
    readonly userId: FieldRef<"Car", 'String'>
    readonly make: FieldRef<"Car", 'String'>
    readonly model: FieldRef<"Car", 'String'>
    readonly year: FieldRef<"Car", 'Int'>
    readonly licensePlate: FieldRef<"Car", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Car findUnique
   */
  export type CarFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Car
     */
    select?: CarSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Car
     */
    omit?: CarOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CarInclude<ExtArgs> | null
    /**
     * Filter, which Car to fetch.
     */
    where: CarWhereUniqueInput
  }

  /**
   * Car findUniqueOrThrow
   */
  export type CarFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Car
     */
    select?: CarSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Car
     */
    omit?: CarOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CarInclude<ExtArgs> | null
    /**
     * Filter, which Car to fetch.
     */
    where: CarWhereUniqueInput
  }

  /**
   * Car findFirst
   */
  export type CarFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Car
     */
    select?: CarSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Car
     */
    omit?: CarOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CarInclude<ExtArgs> | null
    /**
     * Filter, which Car to fetch.
     */
    where?: CarWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Cars to fetch.
     */
    orderBy?: CarOrderByWithRelationInput | CarOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Cars.
     */
    cursor?: CarWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Cars from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Cars.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Cars.
     */
    distinct?: CarScalarFieldEnum | CarScalarFieldEnum[]
  }

  /**
   * Car findFirstOrThrow
   */
  export type CarFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Car
     */
    select?: CarSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Car
     */
    omit?: CarOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CarInclude<ExtArgs> | null
    /**
     * Filter, which Car to fetch.
     */
    where?: CarWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Cars to fetch.
     */
    orderBy?: CarOrderByWithRelationInput | CarOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Cars.
     */
    cursor?: CarWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Cars from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Cars.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Cars.
     */
    distinct?: CarScalarFieldEnum | CarScalarFieldEnum[]
  }

  /**
   * Car findMany
   */
  export type CarFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Car
     */
    select?: CarSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Car
     */
    omit?: CarOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CarInclude<ExtArgs> | null
    /**
     * Filter, which Cars to fetch.
     */
    where?: CarWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Cars to fetch.
     */
    orderBy?: CarOrderByWithRelationInput | CarOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Cars.
     */
    cursor?: CarWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Cars from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Cars.
     */
    skip?: number
    distinct?: CarScalarFieldEnum | CarScalarFieldEnum[]
  }

  /**
   * Car create
   */
  export type CarCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Car
     */
    select?: CarSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Car
     */
    omit?: CarOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CarInclude<ExtArgs> | null
    /**
     * The data needed to create a Car.
     */
    data: XOR<CarCreateInput, CarUncheckedCreateInput>
  }

  /**
   * Car createMany
   */
  export type CarCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Cars.
     */
    data: CarCreateManyInput | CarCreateManyInput[]
  }

  /**
   * Car update
   */
  export type CarUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Car
     */
    select?: CarSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Car
     */
    omit?: CarOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CarInclude<ExtArgs> | null
    /**
     * The data needed to update a Car.
     */
    data: XOR<CarUpdateInput, CarUncheckedUpdateInput>
    /**
     * Choose, which Car to update.
     */
    where: CarWhereUniqueInput
  }

  /**
   * Car updateMany
   */
  export type CarUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Cars.
     */
    data: XOR<CarUpdateManyMutationInput, CarUncheckedUpdateManyInput>
    /**
     * Filter which Cars to update
     */
    where?: CarWhereInput
    /**
     * Limit how many Cars to update.
     */
    limit?: number
  }

  /**
   * Car upsert
   */
  export type CarUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Car
     */
    select?: CarSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Car
     */
    omit?: CarOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CarInclude<ExtArgs> | null
    /**
     * The filter to search for the Car to update in case it exists.
     */
    where: CarWhereUniqueInput
    /**
     * In case the Car found by the `where` argument doesn't exist, create a new Car with this data.
     */
    create: XOR<CarCreateInput, CarUncheckedCreateInput>
    /**
     * In case the Car was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CarUpdateInput, CarUncheckedUpdateInput>
  }

  /**
   * Car delete
   */
  export type CarDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Car
     */
    select?: CarSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Car
     */
    omit?: CarOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CarInclude<ExtArgs> | null
    /**
     * Filter which Car to delete.
     */
    where: CarWhereUniqueInput
  }

  /**
   * Car deleteMany
   */
  export type CarDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Cars to delete
     */
    where?: CarWhereInput
    /**
     * Limit how many Cars to delete.
     */
    limit?: number
  }

  /**
   * Car findRaw
   */
  export type CarFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * Car aggregateRaw
   */
  export type CarAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * Car without action
   */
  export type CarDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Car
     */
    select?: CarSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Car
     */
    omit?: CarOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CarInclude<ExtArgs> | null
  }


  /**
   * Model ServiceRequest
   */

  export type AggregateServiceRequest = {
    _count: ServiceRequestCountAggregateOutputType | null
    _avg: ServiceRequestAvgAggregateOutputType | null
    _sum: ServiceRequestSumAggregateOutputType | null
    _min: ServiceRequestMinAggregateOutputType | null
    _max: ServiceRequestMaxAggregateOutputType | null
  }

  export type ServiceRequestAvgAggregateOutputType = {
    latitude: number | null
    longitude: number | null
  }

  export type ServiceRequestSumAggregateOutputType = {
    latitude: number | null
    longitude: number | null
  }

  export type ServiceRequestMinAggregateOutputType = {
    id: string | null
    userId: string | null
    mechanicId: string | null
    serviceType: $Enums.ServiceType | null
    description: string | null
    latitude: number | null
    longitude: number | null
    address: string | null
    status: $Enums.ServiceStatus | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ServiceRequestMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    mechanicId: string | null
    serviceType: $Enums.ServiceType | null
    description: string | null
    latitude: number | null
    longitude: number | null
    address: string | null
    status: $Enums.ServiceStatus | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ServiceRequestCountAggregateOutputType = {
    id: number
    userId: number
    mechanicId: number
    serviceType: number
    description: number
    latitude: number
    longitude: number
    address: number
    status: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ServiceRequestAvgAggregateInputType = {
    latitude?: true
    longitude?: true
  }

  export type ServiceRequestSumAggregateInputType = {
    latitude?: true
    longitude?: true
  }

  export type ServiceRequestMinAggregateInputType = {
    id?: true
    userId?: true
    mechanicId?: true
    serviceType?: true
    description?: true
    latitude?: true
    longitude?: true
    address?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ServiceRequestMaxAggregateInputType = {
    id?: true
    userId?: true
    mechanicId?: true
    serviceType?: true
    description?: true
    latitude?: true
    longitude?: true
    address?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ServiceRequestCountAggregateInputType = {
    id?: true
    userId?: true
    mechanicId?: true
    serviceType?: true
    description?: true
    latitude?: true
    longitude?: true
    address?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ServiceRequestAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ServiceRequest to aggregate.
     */
    where?: ServiceRequestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ServiceRequests to fetch.
     */
    orderBy?: ServiceRequestOrderByWithRelationInput | ServiceRequestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ServiceRequestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ServiceRequests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ServiceRequests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ServiceRequests
    **/
    _count?: true | ServiceRequestCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ServiceRequestAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ServiceRequestSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ServiceRequestMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ServiceRequestMaxAggregateInputType
  }

  export type GetServiceRequestAggregateType<T extends ServiceRequestAggregateArgs> = {
        [P in keyof T & keyof AggregateServiceRequest]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateServiceRequest[P]>
      : GetScalarType<T[P], AggregateServiceRequest[P]>
  }




  export type ServiceRequestGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ServiceRequestWhereInput
    orderBy?: ServiceRequestOrderByWithAggregationInput | ServiceRequestOrderByWithAggregationInput[]
    by: ServiceRequestScalarFieldEnum[] | ServiceRequestScalarFieldEnum
    having?: ServiceRequestScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ServiceRequestCountAggregateInputType | true
    _avg?: ServiceRequestAvgAggregateInputType
    _sum?: ServiceRequestSumAggregateInputType
    _min?: ServiceRequestMinAggregateInputType
    _max?: ServiceRequestMaxAggregateInputType
  }

  export type ServiceRequestGroupByOutputType = {
    id: string
    userId: string
    mechanicId: string | null
    serviceType: $Enums.ServiceType
    description: string | null
    latitude: number
    longitude: number
    address: string | null
    status: $Enums.ServiceStatus
    createdAt: Date
    updatedAt: Date
    _count: ServiceRequestCountAggregateOutputType | null
    _avg: ServiceRequestAvgAggregateOutputType | null
    _sum: ServiceRequestSumAggregateOutputType | null
    _min: ServiceRequestMinAggregateOutputType | null
    _max: ServiceRequestMaxAggregateOutputType | null
  }

  type GetServiceRequestGroupByPayload<T extends ServiceRequestGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ServiceRequestGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ServiceRequestGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ServiceRequestGroupByOutputType[P]>
            : GetScalarType<T[P], ServiceRequestGroupByOutputType[P]>
        }
      >
    >


  export type ServiceRequestSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    mechanicId?: boolean
    serviceType?: boolean
    description?: boolean
    latitude?: boolean
    longitude?: boolean
    address?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    mechanic?: boolean | ServiceRequest$mechanicArgs<ExtArgs>
    payment?: boolean | ServiceRequest$paymentArgs<ExtArgs>
    chat?: boolean | ServiceRequest$chatArgs<ExtArgs>
    confirmations?: boolean | ServiceRequest$confirmationsArgs<ExtArgs>
    reviews?: boolean | ServiceRequest$reviewsArgs<ExtArgs>
    _count?: boolean | ServiceRequestCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["serviceRequest"]>



  export type ServiceRequestSelectScalar = {
    id?: boolean
    userId?: boolean
    mechanicId?: boolean
    serviceType?: boolean
    description?: boolean
    latitude?: boolean
    longitude?: boolean
    address?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ServiceRequestOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "mechanicId" | "serviceType" | "description" | "latitude" | "longitude" | "address" | "status" | "createdAt" | "updatedAt", ExtArgs["result"]["serviceRequest"]>
  export type ServiceRequestInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    mechanic?: boolean | ServiceRequest$mechanicArgs<ExtArgs>
    payment?: boolean | ServiceRequest$paymentArgs<ExtArgs>
    chat?: boolean | ServiceRequest$chatArgs<ExtArgs>
    confirmations?: boolean | ServiceRequest$confirmationsArgs<ExtArgs>
    reviews?: boolean | ServiceRequest$reviewsArgs<ExtArgs>
    _count?: boolean | ServiceRequestCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $ServiceRequestPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ServiceRequest"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      mechanic: Prisma.$MechanicPayload<ExtArgs> | null
      payment: Prisma.$PaymentPayload<ExtArgs> | null
      chat: Prisma.$ChatPayload<ExtArgs> | null
      confirmations: Prisma.$MechanicConfirmationPayload<ExtArgs>[]
      reviews: Prisma.$ReviewPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      mechanicId: string | null
      serviceType: $Enums.ServiceType
      description: string | null
      latitude: number
      longitude: number
      address: string | null
      status: $Enums.ServiceStatus
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["serviceRequest"]>
    composites: {}
  }

  type ServiceRequestGetPayload<S extends boolean | null | undefined | ServiceRequestDefaultArgs> = $Result.GetResult<Prisma.$ServiceRequestPayload, S>

  type ServiceRequestCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ServiceRequestFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ServiceRequestCountAggregateInputType | true
    }

  export interface ServiceRequestDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ServiceRequest'], meta: { name: 'ServiceRequest' } }
    /**
     * Find zero or one ServiceRequest that matches the filter.
     * @param {ServiceRequestFindUniqueArgs} args - Arguments to find a ServiceRequest
     * @example
     * // Get one ServiceRequest
     * const serviceRequest = await prisma.serviceRequest.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ServiceRequestFindUniqueArgs>(args: SelectSubset<T, ServiceRequestFindUniqueArgs<ExtArgs>>): Prisma__ServiceRequestClient<$Result.GetResult<Prisma.$ServiceRequestPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ServiceRequest that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ServiceRequestFindUniqueOrThrowArgs} args - Arguments to find a ServiceRequest
     * @example
     * // Get one ServiceRequest
     * const serviceRequest = await prisma.serviceRequest.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ServiceRequestFindUniqueOrThrowArgs>(args: SelectSubset<T, ServiceRequestFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ServiceRequestClient<$Result.GetResult<Prisma.$ServiceRequestPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ServiceRequest that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceRequestFindFirstArgs} args - Arguments to find a ServiceRequest
     * @example
     * // Get one ServiceRequest
     * const serviceRequest = await prisma.serviceRequest.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ServiceRequestFindFirstArgs>(args?: SelectSubset<T, ServiceRequestFindFirstArgs<ExtArgs>>): Prisma__ServiceRequestClient<$Result.GetResult<Prisma.$ServiceRequestPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ServiceRequest that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceRequestFindFirstOrThrowArgs} args - Arguments to find a ServiceRequest
     * @example
     * // Get one ServiceRequest
     * const serviceRequest = await prisma.serviceRequest.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ServiceRequestFindFirstOrThrowArgs>(args?: SelectSubset<T, ServiceRequestFindFirstOrThrowArgs<ExtArgs>>): Prisma__ServiceRequestClient<$Result.GetResult<Prisma.$ServiceRequestPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ServiceRequests that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceRequestFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ServiceRequests
     * const serviceRequests = await prisma.serviceRequest.findMany()
     * 
     * // Get first 10 ServiceRequests
     * const serviceRequests = await prisma.serviceRequest.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const serviceRequestWithIdOnly = await prisma.serviceRequest.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ServiceRequestFindManyArgs>(args?: SelectSubset<T, ServiceRequestFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ServiceRequestPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ServiceRequest.
     * @param {ServiceRequestCreateArgs} args - Arguments to create a ServiceRequest.
     * @example
     * // Create one ServiceRequest
     * const ServiceRequest = await prisma.serviceRequest.create({
     *   data: {
     *     // ... data to create a ServiceRequest
     *   }
     * })
     * 
     */
    create<T extends ServiceRequestCreateArgs>(args: SelectSubset<T, ServiceRequestCreateArgs<ExtArgs>>): Prisma__ServiceRequestClient<$Result.GetResult<Prisma.$ServiceRequestPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ServiceRequests.
     * @param {ServiceRequestCreateManyArgs} args - Arguments to create many ServiceRequests.
     * @example
     * // Create many ServiceRequests
     * const serviceRequest = await prisma.serviceRequest.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ServiceRequestCreateManyArgs>(args?: SelectSubset<T, ServiceRequestCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a ServiceRequest.
     * @param {ServiceRequestDeleteArgs} args - Arguments to delete one ServiceRequest.
     * @example
     * // Delete one ServiceRequest
     * const ServiceRequest = await prisma.serviceRequest.delete({
     *   where: {
     *     // ... filter to delete one ServiceRequest
     *   }
     * })
     * 
     */
    delete<T extends ServiceRequestDeleteArgs>(args: SelectSubset<T, ServiceRequestDeleteArgs<ExtArgs>>): Prisma__ServiceRequestClient<$Result.GetResult<Prisma.$ServiceRequestPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ServiceRequest.
     * @param {ServiceRequestUpdateArgs} args - Arguments to update one ServiceRequest.
     * @example
     * // Update one ServiceRequest
     * const serviceRequest = await prisma.serviceRequest.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ServiceRequestUpdateArgs>(args: SelectSubset<T, ServiceRequestUpdateArgs<ExtArgs>>): Prisma__ServiceRequestClient<$Result.GetResult<Prisma.$ServiceRequestPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ServiceRequests.
     * @param {ServiceRequestDeleteManyArgs} args - Arguments to filter ServiceRequests to delete.
     * @example
     * // Delete a few ServiceRequests
     * const { count } = await prisma.serviceRequest.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ServiceRequestDeleteManyArgs>(args?: SelectSubset<T, ServiceRequestDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ServiceRequests.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceRequestUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ServiceRequests
     * const serviceRequest = await prisma.serviceRequest.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ServiceRequestUpdateManyArgs>(args: SelectSubset<T, ServiceRequestUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ServiceRequest.
     * @param {ServiceRequestUpsertArgs} args - Arguments to update or create a ServiceRequest.
     * @example
     * // Update or create a ServiceRequest
     * const serviceRequest = await prisma.serviceRequest.upsert({
     *   create: {
     *     // ... data to create a ServiceRequest
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ServiceRequest we want to update
     *   }
     * })
     */
    upsert<T extends ServiceRequestUpsertArgs>(args: SelectSubset<T, ServiceRequestUpsertArgs<ExtArgs>>): Prisma__ServiceRequestClient<$Result.GetResult<Prisma.$ServiceRequestPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ServiceRequests that matches the filter.
     * @param {ServiceRequestFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const serviceRequest = await prisma.serviceRequest.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: ServiceRequestFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a ServiceRequest.
     * @param {ServiceRequestAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const serviceRequest = await prisma.serviceRequest.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: ServiceRequestAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of ServiceRequests.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceRequestCountArgs} args - Arguments to filter ServiceRequests to count.
     * @example
     * // Count the number of ServiceRequests
     * const count = await prisma.serviceRequest.count({
     *   where: {
     *     // ... the filter for the ServiceRequests we want to count
     *   }
     * })
    **/
    count<T extends ServiceRequestCountArgs>(
      args?: Subset<T, ServiceRequestCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ServiceRequestCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ServiceRequest.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceRequestAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ServiceRequestAggregateArgs>(args: Subset<T, ServiceRequestAggregateArgs>): Prisma.PrismaPromise<GetServiceRequestAggregateType<T>>

    /**
     * Group by ServiceRequest.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceRequestGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ServiceRequestGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ServiceRequestGroupByArgs['orderBy'] }
        : { orderBy?: ServiceRequestGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ServiceRequestGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetServiceRequestGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ServiceRequest model
   */
  readonly fields: ServiceRequestFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ServiceRequest.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ServiceRequestClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    mechanic<T extends ServiceRequest$mechanicArgs<ExtArgs> = {}>(args?: Subset<T, ServiceRequest$mechanicArgs<ExtArgs>>): Prisma__MechanicClient<$Result.GetResult<Prisma.$MechanicPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    payment<T extends ServiceRequest$paymentArgs<ExtArgs> = {}>(args?: Subset<T, ServiceRequest$paymentArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    chat<T extends ServiceRequest$chatArgs<ExtArgs> = {}>(args?: Subset<T, ServiceRequest$chatArgs<ExtArgs>>): Prisma__ChatClient<$Result.GetResult<Prisma.$ChatPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    confirmations<T extends ServiceRequest$confirmationsArgs<ExtArgs> = {}>(args?: Subset<T, ServiceRequest$confirmationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MechanicConfirmationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    reviews<T extends ServiceRequest$reviewsArgs<ExtArgs> = {}>(args?: Subset<T, ServiceRequest$reviewsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReviewPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ServiceRequest model
   */ 
  interface ServiceRequestFieldRefs {
    readonly id: FieldRef<"ServiceRequest", 'String'>
    readonly userId: FieldRef<"ServiceRequest", 'String'>
    readonly mechanicId: FieldRef<"ServiceRequest", 'String'>
    readonly serviceType: FieldRef<"ServiceRequest", 'ServiceType'>
    readonly description: FieldRef<"ServiceRequest", 'String'>
    readonly latitude: FieldRef<"ServiceRequest", 'Float'>
    readonly longitude: FieldRef<"ServiceRequest", 'Float'>
    readonly address: FieldRef<"ServiceRequest", 'String'>
    readonly status: FieldRef<"ServiceRequest", 'ServiceStatus'>
    readonly createdAt: FieldRef<"ServiceRequest", 'DateTime'>
    readonly updatedAt: FieldRef<"ServiceRequest", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ServiceRequest findUnique
   */
  export type ServiceRequestFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceRequest
     */
    select?: ServiceRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceRequest
     */
    omit?: ServiceRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceRequestInclude<ExtArgs> | null
    /**
     * Filter, which ServiceRequest to fetch.
     */
    where: ServiceRequestWhereUniqueInput
  }

  /**
   * ServiceRequest findUniqueOrThrow
   */
  export type ServiceRequestFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceRequest
     */
    select?: ServiceRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceRequest
     */
    omit?: ServiceRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceRequestInclude<ExtArgs> | null
    /**
     * Filter, which ServiceRequest to fetch.
     */
    where: ServiceRequestWhereUniqueInput
  }

  /**
   * ServiceRequest findFirst
   */
  export type ServiceRequestFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceRequest
     */
    select?: ServiceRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceRequest
     */
    omit?: ServiceRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceRequestInclude<ExtArgs> | null
    /**
     * Filter, which ServiceRequest to fetch.
     */
    where?: ServiceRequestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ServiceRequests to fetch.
     */
    orderBy?: ServiceRequestOrderByWithRelationInput | ServiceRequestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ServiceRequests.
     */
    cursor?: ServiceRequestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ServiceRequests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ServiceRequests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ServiceRequests.
     */
    distinct?: ServiceRequestScalarFieldEnum | ServiceRequestScalarFieldEnum[]
  }

  /**
   * ServiceRequest findFirstOrThrow
   */
  export type ServiceRequestFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceRequest
     */
    select?: ServiceRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceRequest
     */
    omit?: ServiceRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceRequestInclude<ExtArgs> | null
    /**
     * Filter, which ServiceRequest to fetch.
     */
    where?: ServiceRequestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ServiceRequests to fetch.
     */
    orderBy?: ServiceRequestOrderByWithRelationInput | ServiceRequestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ServiceRequests.
     */
    cursor?: ServiceRequestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ServiceRequests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ServiceRequests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ServiceRequests.
     */
    distinct?: ServiceRequestScalarFieldEnum | ServiceRequestScalarFieldEnum[]
  }

  /**
   * ServiceRequest findMany
   */
  export type ServiceRequestFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceRequest
     */
    select?: ServiceRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceRequest
     */
    omit?: ServiceRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceRequestInclude<ExtArgs> | null
    /**
     * Filter, which ServiceRequests to fetch.
     */
    where?: ServiceRequestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ServiceRequests to fetch.
     */
    orderBy?: ServiceRequestOrderByWithRelationInput | ServiceRequestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ServiceRequests.
     */
    cursor?: ServiceRequestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ServiceRequests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ServiceRequests.
     */
    skip?: number
    distinct?: ServiceRequestScalarFieldEnum | ServiceRequestScalarFieldEnum[]
  }

  /**
   * ServiceRequest create
   */
  export type ServiceRequestCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceRequest
     */
    select?: ServiceRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceRequest
     */
    omit?: ServiceRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceRequestInclude<ExtArgs> | null
    /**
     * The data needed to create a ServiceRequest.
     */
    data: XOR<ServiceRequestCreateInput, ServiceRequestUncheckedCreateInput>
  }

  /**
   * ServiceRequest createMany
   */
  export type ServiceRequestCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ServiceRequests.
     */
    data: ServiceRequestCreateManyInput | ServiceRequestCreateManyInput[]
  }

  /**
   * ServiceRequest update
   */
  export type ServiceRequestUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceRequest
     */
    select?: ServiceRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceRequest
     */
    omit?: ServiceRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceRequestInclude<ExtArgs> | null
    /**
     * The data needed to update a ServiceRequest.
     */
    data: XOR<ServiceRequestUpdateInput, ServiceRequestUncheckedUpdateInput>
    /**
     * Choose, which ServiceRequest to update.
     */
    where: ServiceRequestWhereUniqueInput
  }

  /**
   * ServiceRequest updateMany
   */
  export type ServiceRequestUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ServiceRequests.
     */
    data: XOR<ServiceRequestUpdateManyMutationInput, ServiceRequestUncheckedUpdateManyInput>
    /**
     * Filter which ServiceRequests to update
     */
    where?: ServiceRequestWhereInput
    /**
     * Limit how many ServiceRequests to update.
     */
    limit?: number
  }

  /**
   * ServiceRequest upsert
   */
  export type ServiceRequestUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceRequest
     */
    select?: ServiceRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceRequest
     */
    omit?: ServiceRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceRequestInclude<ExtArgs> | null
    /**
     * The filter to search for the ServiceRequest to update in case it exists.
     */
    where: ServiceRequestWhereUniqueInput
    /**
     * In case the ServiceRequest found by the `where` argument doesn't exist, create a new ServiceRequest with this data.
     */
    create: XOR<ServiceRequestCreateInput, ServiceRequestUncheckedCreateInput>
    /**
     * In case the ServiceRequest was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ServiceRequestUpdateInput, ServiceRequestUncheckedUpdateInput>
  }

  /**
   * ServiceRequest delete
   */
  export type ServiceRequestDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceRequest
     */
    select?: ServiceRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceRequest
     */
    omit?: ServiceRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceRequestInclude<ExtArgs> | null
    /**
     * Filter which ServiceRequest to delete.
     */
    where: ServiceRequestWhereUniqueInput
  }

  /**
   * ServiceRequest deleteMany
   */
  export type ServiceRequestDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ServiceRequests to delete
     */
    where?: ServiceRequestWhereInput
    /**
     * Limit how many ServiceRequests to delete.
     */
    limit?: number
  }

  /**
   * ServiceRequest findRaw
   */
  export type ServiceRequestFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * ServiceRequest aggregateRaw
   */
  export type ServiceRequestAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * ServiceRequest.mechanic
   */
  export type ServiceRequest$mechanicArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Mechanic
     */
    select?: MechanicSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Mechanic
     */
    omit?: MechanicOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MechanicInclude<ExtArgs> | null
    where?: MechanicWhereInput
  }

  /**
   * ServiceRequest.payment
   */
  export type ServiceRequest$paymentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    where?: PaymentWhereInput
  }

  /**
   * ServiceRequest.chat
   */
  export type ServiceRequest$chatArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Chat
     */
    select?: ChatSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Chat
     */
    omit?: ChatOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatInclude<ExtArgs> | null
    where?: ChatWhereInput
  }

  /**
   * ServiceRequest.confirmations
   */
  export type ServiceRequest$confirmationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MechanicConfirmation
     */
    select?: MechanicConfirmationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MechanicConfirmation
     */
    omit?: MechanicConfirmationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MechanicConfirmationInclude<ExtArgs> | null
    where?: MechanicConfirmationWhereInput
    orderBy?: MechanicConfirmationOrderByWithRelationInput | MechanicConfirmationOrderByWithRelationInput[]
    cursor?: MechanicConfirmationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MechanicConfirmationScalarFieldEnum | MechanicConfirmationScalarFieldEnum[]
  }

  /**
   * ServiceRequest.reviews
   */
  export type ServiceRequest$reviewsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Review
     */
    omit?: ReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewInclude<ExtArgs> | null
    where?: ReviewWhereInput
    orderBy?: ReviewOrderByWithRelationInput | ReviewOrderByWithRelationInput[]
    cursor?: ReviewWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ReviewScalarFieldEnum | ReviewScalarFieldEnum[]
  }

  /**
   * ServiceRequest without action
   */
  export type ServiceRequestDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceRequest
     */
    select?: ServiceRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceRequest
     */
    omit?: ServiceRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceRequestInclude<ExtArgs> | null
  }


  /**
   * Model EmergencyContact
   */

  export type AggregateEmergencyContact = {
    _count: EmergencyContactCountAggregateOutputType | null
    _min: EmergencyContactMinAggregateOutputType | null
    _max: EmergencyContactMaxAggregateOutputType | null
  }

  export type EmergencyContactMinAggregateOutputType = {
    id: string | null
    userId: string | null
    name: string | null
    mobileNumber: string | null
  }

  export type EmergencyContactMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    name: string | null
    mobileNumber: string | null
  }

  export type EmergencyContactCountAggregateOutputType = {
    id: number
    userId: number
    name: number
    mobileNumber: number
    _all: number
  }


  export type EmergencyContactMinAggregateInputType = {
    id?: true
    userId?: true
    name?: true
    mobileNumber?: true
  }

  export type EmergencyContactMaxAggregateInputType = {
    id?: true
    userId?: true
    name?: true
    mobileNumber?: true
  }

  export type EmergencyContactCountAggregateInputType = {
    id?: true
    userId?: true
    name?: true
    mobileNumber?: true
    _all?: true
  }

  export type EmergencyContactAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EmergencyContact to aggregate.
     */
    where?: EmergencyContactWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmergencyContacts to fetch.
     */
    orderBy?: EmergencyContactOrderByWithRelationInput | EmergencyContactOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EmergencyContactWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmergencyContacts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmergencyContacts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned EmergencyContacts
    **/
    _count?: true | EmergencyContactCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EmergencyContactMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EmergencyContactMaxAggregateInputType
  }

  export type GetEmergencyContactAggregateType<T extends EmergencyContactAggregateArgs> = {
        [P in keyof T & keyof AggregateEmergencyContact]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEmergencyContact[P]>
      : GetScalarType<T[P], AggregateEmergencyContact[P]>
  }




  export type EmergencyContactGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EmergencyContactWhereInput
    orderBy?: EmergencyContactOrderByWithAggregationInput | EmergencyContactOrderByWithAggregationInput[]
    by: EmergencyContactScalarFieldEnum[] | EmergencyContactScalarFieldEnum
    having?: EmergencyContactScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EmergencyContactCountAggregateInputType | true
    _min?: EmergencyContactMinAggregateInputType
    _max?: EmergencyContactMaxAggregateInputType
  }

  export type EmergencyContactGroupByOutputType = {
    id: string
    userId: string
    name: string
    mobileNumber: string
    _count: EmergencyContactCountAggregateOutputType | null
    _min: EmergencyContactMinAggregateOutputType | null
    _max: EmergencyContactMaxAggregateOutputType | null
  }

  type GetEmergencyContactGroupByPayload<T extends EmergencyContactGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EmergencyContactGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EmergencyContactGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EmergencyContactGroupByOutputType[P]>
            : GetScalarType<T[P], EmergencyContactGroupByOutputType[P]>
        }
      >
    >


  export type EmergencyContactSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    name?: boolean
    mobileNumber?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    sosEvents?: boolean | EmergencyContact$sosEventsArgs<ExtArgs>
    _count?: boolean | EmergencyContactCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["emergencyContact"]>



  export type EmergencyContactSelectScalar = {
    id?: boolean
    userId?: boolean
    name?: boolean
    mobileNumber?: boolean
  }

  export type EmergencyContactOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "name" | "mobileNumber", ExtArgs["result"]["emergencyContact"]>
  export type EmergencyContactInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    sosEvents?: boolean | EmergencyContact$sosEventsArgs<ExtArgs>
    _count?: boolean | EmergencyContactCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $EmergencyContactPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "EmergencyContact"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      sosEvents: Prisma.$SOSPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      name: string
      mobileNumber: string
    }, ExtArgs["result"]["emergencyContact"]>
    composites: {}
  }

  type EmergencyContactGetPayload<S extends boolean | null | undefined | EmergencyContactDefaultArgs> = $Result.GetResult<Prisma.$EmergencyContactPayload, S>

  type EmergencyContactCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<EmergencyContactFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: EmergencyContactCountAggregateInputType | true
    }

  export interface EmergencyContactDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['EmergencyContact'], meta: { name: 'EmergencyContact' } }
    /**
     * Find zero or one EmergencyContact that matches the filter.
     * @param {EmergencyContactFindUniqueArgs} args - Arguments to find a EmergencyContact
     * @example
     * // Get one EmergencyContact
     * const emergencyContact = await prisma.emergencyContact.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends EmergencyContactFindUniqueArgs>(args: SelectSubset<T, EmergencyContactFindUniqueArgs<ExtArgs>>): Prisma__EmergencyContactClient<$Result.GetResult<Prisma.$EmergencyContactPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one EmergencyContact that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {EmergencyContactFindUniqueOrThrowArgs} args - Arguments to find a EmergencyContact
     * @example
     * // Get one EmergencyContact
     * const emergencyContact = await prisma.emergencyContact.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends EmergencyContactFindUniqueOrThrowArgs>(args: SelectSubset<T, EmergencyContactFindUniqueOrThrowArgs<ExtArgs>>): Prisma__EmergencyContactClient<$Result.GetResult<Prisma.$EmergencyContactPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first EmergencyContact that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmergencyContactFindFirstArgs} args - Arguments to find a EmergencyContact
     * @example
     * // Get one EmergencyContact
     * const emergencyContact = await prisma.emergencyContact.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends EmergencyContactFindFirstArgs>(args?: SelectSubset<T, EmergencyContactFindFirstArgs<ExtArgs>>): Prisma__EmergencyContactClient<$Result.GetResult<Prisma.$EmergencyContactPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first EmergencyContact that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmergencyContactFindFirstOrThrowArgs} args - Arguments to find a EmergencyContact
     * @example
     * // Get one EmergencyContact
     * const emergencyContact = await prisma.emergencyContact.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends EmergencyContactFindFirstOrThrowArgs>(args?: SelectSubset<T, EmergencyContactFindFirstOrThrowArgs<ExtArgs>>): Prisma__EmergencyContactClient<$Result.GetResult<Prisma.$EmergencyContactPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more EmergencyContacts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmergencyContactFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all EmergencyContacts
     * const emergencyContacts = await prisma.emergencyContact.findMany()
     * 
     * // Get first 10 EmergencyContacts
     * const emergencyContacts = await prisma.emergencyContact.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const emergencyContactWithIdOnly = await prisma.emergencyContact.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends EmergencyContactFindManyArgs>(args?: SelectSubset<T, EmergencyContactFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmergencyContactPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a EmergencyContact.
     * @param {EmergencyContactCreateArgs} args - Arguments to create a EmergencyContact.
     * @example
     * // Create one EmergencyContact
     * const EmergencyContact = await prisma.emergencyContact.create({
     *   data: {
     *     // ... data to create a EmergencyContact
     *   }
     * })
     * 
     */
    create<T extends EmergencyContactCreateArgs>(args: SelectSubset<T, EmergencyContactCreateArgs<ExtArgs>>): Prisma__EmergencyContactClient<$Result.GetResult<Prisma.$EmergencyContactPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many EmergencyContacts.
     * @param {EmergencyContactCreateManyArgs} args - Arguments to create many EmergencyContacts.
     * @example
     * // Create many EmergencyContacts
     * const emergencyContact = await prisma.emergencyContact.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends EmergencyContactCreateManyArgs>(args?: SelectSubset<T, EmergencyContactCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a EmergencyContact.
     * @param {EmergencyContactDeleteArgs} args - Arguments to delete one EmergencyContact.
     * @example
     * // Delete one EmergencyContact
     * const EmergencyContact = await prisma.emergencyContact.delete({
     *   where: {
     *     // ... filter to delete one EmergencyContact
     *   }
     * })
     * 
     */
    delete<T extends EmergencyContactDeleteArgs>(args: SelectSubset<T, EmergencyContactDeleteArgs<ExtArgs>>): Prisma__EmergencyContactClient<$Result.GetResult<Prisma.$EmergencyContactPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one EmergencyContact.
     * @param {EmergencyContactUpdateArgs} args - Arguments to update one EmergencyContact.
     * @example
     * // Update one EmergencyContact
     * const emergencyContact = await prisma.emergencyContact.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends EmergencyContactUpdateArgs>(args: SelectSubset<T, EmergencyContactUpdateArgs<ExtArgs>>): Prisma__EmergencyContactClient<$Result.GetResult<Prisma.$EmergencyContactPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more EmergencyContacts.
     * @param {EmergencyContactDeleteManyArgs} args - Arguments to filter EmergencyContacts to delete.
     * @example
     * // Delete a few EmergencyContacts
     * const { count } = await prisma.emergencyContact.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends EmergencyContactDeleteManyArgs>(args?: SelectSubset<T, EmergencyContactDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more EmergencyContacts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmergencyContactUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many EmergencyContacts
     * const emergencyContact = await prisma.emergencyContact.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends EmergencyContactUpdateManyArgs>(args: SelectSubset<T, EmergencyContactUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one EmergencyContact.
     * @param {EmergencyContactUpsertArgs} args - Arguments to update or create a EmergencyContact.
     * @example
     * // Update or create a EmergencyContact
     * const emergencyContact = await prisma.emergencyContact.upsert({
     *   create: {
     *     // ... data to create a EmergencyContact
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the EmergencyContact we want to update
     *   }
     * })
     */
    upsert<T extends EmergencyContactUpsertArgs>(args: SelectSubset<T, EmergencyContactUpsertArgs<ExtArgs>>): Prisma__EmergencyContactClient<$Result.GetResult<Prisma.$EmergencyContactPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more EmergencyContacts that matches the filter.
     * @param {EmergencyContactFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const emergencyContact = await prisma.emergencyContact.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: EmergencyContactFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a EmergencyContact.
     * @param {EmergencyContactAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const emergencyContact = await prisma.emergencyContact.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: EmergencyContactAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of EmergencyContacts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmergencyContactCountArgs} args - Arguments to filter EmergencyContacts to count.
     * @example
     * // Count the number of EmergencyContacts
     * const count = await prisma.emergencyContact.count({
     *   where: {
     *     // ... the filter for the EmergencyContacts we want to count
     *   }
     * })
    **/
    count<T extends EmergencyContactCountArgs>(
      args?: Subset<T, EmergencyContactCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EmergencyContactCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a EmergencyContact.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmergencyContactAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EmergencyContactAggregateArgs>(args: Subset<T, EmergencyContactAggregateArgs>): Prisma.PrismaPromise<GetEmergencyContactAggregateType<T>>

    /**
     * Group by EmergencyContact.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmergencyContactGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EmergencyContactGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EmergencyContactGroupByArgs['orderBy'] }
        : { orderBy?: EmergencyContactGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EmergencyContactGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEmergencyContactGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the EmergencyContact model
   */
  readonly fields: EmergencyContactFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for EmergencyContact.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EmergencyContactClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    sosEvents<T extends EmergencyContact$sosEventsArgs<ExtArgs> = {}>(args?: Subset<T, EmergencyContact$sosEventsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SOSPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the EmergencyContact model
   */ 
  interface EmergencyContactFieldRefs {
    readonly id: FieldRef<"EmergencyContact", 'String'>
    readonly userId: FieldRef<"EmergencyContact", 'String'>
    readonly name: FieldRef<"EmergencyContact", 'String'>
    readonly mobileNumber: FieldRef<"EmergencyContact", 'String'>
  }
    

  // Custom InputTypes
  /**
   * EmergencyContact findUnique
   */
  export type EmergencyContactFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmergencyContact
     */
    select?: EmergencyContactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmergencyContact
     */
    omit?: EmergencyContactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmergencyContactInclude<ExtArgs> | null
    /**
     * Filter, which EmergencyContact to fetch.
     */
    where: EmergencyContactWhereUniqueInput
  }

  /**
   * EmergencyContact findUniqueOrThrow
   */
  export type EmergencyContactFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmergencyContact
     */
    select?: EmergencyContactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmergencyContact
     */
    omit?: EmergencyContactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmergencyContactInclude<ExtArgs> | null
    /**
     * Filter, which EmergencyContact to fetch.
     */
    where: EmergencyContactWhereUniqueInput
  }

  /**
   * EmergencyContact findFirst
   */
  export type EmergencyContactFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmergencyContact
     */
    select?: EmergencyContactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmergencyContact
     */
    omit?: EmergencyContactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmergencyContactInclude<ExtArgs> | null
    /**
     * Filter, which EmergencyContact to fetch.
     */
    where?: EmergencyContactWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmergencyContacts to fetch.
     */
    orderBy?: EmergencyContactOrderByWithRelationInput | EmergencyContactOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EmergencyContacts.
     */
    cursor?: EmergencyContactWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmergencyContacts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmergencyContacts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EmergencyContacts.
     */
    distinct?: EmergencyContactScalarFieldEnum | EmergencyContactScalarFieldEnum[]
  }

  /**
   * EmergencyContact findFirstOrThrow
   */
  export type EmergencyContactFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmergencyContact
     */
    select?: EmergencyContactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmergencyContact
     */
    omit?: EmergencyContactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmergencyContactInclude<ExtArgs> | null
    /**
     * Filter, which EmergencyContact to fetch.
     */
    where?: EmergencyContactWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmergencyContacts to fetch.
     */
    orderBy?: EmergencyContactOrderByWithRelationInput | EmergencyContactOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EmergencyContacts.
     */
    cursor?: EmergencyContactWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmergencyContacts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmergencyContacts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EmergencyContacts.
     */
    distinct?: EmergencyContactScalarFieldEnum | EmergencyContactScalarFieldEnum[]
  }

  /**
   * EmergencyContact findMany
   */
  export type EmergencyContactFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmergencyContact
     */
    select?: EmergencyContactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmergencyContact
     */
    omit?: EmergencyContactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmergencyContactInclude<ExtArgs> | null
    /**
     * Filter, which EmergencyContacts to fetch.
     */
    where?: EmergencyContactWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmergencyContacts to fetch.
     */
    orderBy?: EmergencyContactOrderByWithRelationInput | EmergencyContactOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing EmergencyContacts.
     */
    cursor?: EmergencyContactWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmergencyContacts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmergencyContacts.
     */
    skip?: number
    distinct?: EmergencyContactScalarFieldEnum | EmergencyContactScalarFieldEnum[]
  }

  /**
   * EmergencyContact create
   */
  export type EmergencyContactCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmergencyContact
     */
    select?: EmergencyContactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmergencyContact
     */
    omit?: EmergencyContactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmergencyContactInclude<ExtArgs> | null
    /**
     * The data needed to create a EmergencyContact.
     */
    data: XOR<EmergencyContactCreateInput, EmergencyContactUncheckedCreateInput>
  }

  /**
   * EmergencyContact createMany
   */
  export type EmergencyContactCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many EmergencyContacts.
     */
    data: EmergencyContactCreateManyInput | EmergencyContactCreateManyInput[]
  }

  /**
   * EmergencyContact update
   */
  export type EmergencyContactUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmergencyContact
     */
    select?: EmergencyContactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmergencyContact
     */
    omit?: EmergencyContactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmergencyContactInclude<ExtArgs> | null
    /**
     * The data needed to update a EmergencyContact.
     */
    data: XOR<EmergencyContactUpdateInput, EmergencyContactUncheckedUpdateInput>
    /**
     * Choose, which EmergencyContact to update.
     */
    where: EmergencyContactWhereUniqueInput
  }

  /**
   * EmergencyContact updateMany
   */
  export type EmergencyContactUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update EmergencyContacts.
     */
    data: XOR<EmergencyContactUpdateManyMutationInput, EmergencyContactUncheckedUpdateManyInput>
    /**
     * Filter which EmergencyContacts to update
     */
    where?: EmergencyContactWhereInput
    /**
     * Limit how many EmergencyContacts to update.
     */
    limit?: number
  }

  /**
   * EmergencyContact upsert
   */
  export type EmergencyContactUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmergencyContact
     */
    select?: EmergencyContactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmergencyContact
     */
    omit?: EmergencyContactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmergencyContactInclude<ExtArgs> | null
    /**
     * The filter to search for the EmergencyContact to update in case it exists.
     */
    where: EmergencyContactWhereUniqueInput
    /**
     * In case the EmergencyContact found by the `where` argument doesn't exist, create a new EmergencyContact with this data.
     */
    create: XOR<EmergencyContactCreateInput, EmergencyContactUncheckedCreateInput>
    /**
     * In case the EmergencyContact was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EmergencyContactUpdateInput, EmergencyContactUncheckedUpdateInput>
  }

  /**
   * EmergencyContact delete
   */
  export type EmergencyContactDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmergencyContact
     */
    select?: EmergencyContactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmergencyContact
     */
    omit?: EmergencyContactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmergencyContactInclude<ExtArgs> | null
    /**
     * Filter which EmergencyContact to delete.
     */
    where: EmergencyContactWhereUniqueInput
  }

  /**
   * EmergencyContact deleteMany
   */
  export type EmergencyContactDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EmergencyContacts to delete
     */
    where?: EmergencyContactWhereInput
    /**
     * Limit how many EmergencyContacts to delete.
     */
    limit?: number
  }

  /**
   * EmergencyContact findRaw
   */
  export type EmergencyContactFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * EmergencyContact aggregateRaw
   */
  export type EmergencyContactAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * EmergencyContact.sosEvents
   */
  export type EmergencyContact$sosEventsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SOS
     */
    select?: SOSSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SOS
     */
    omit?: SOSOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SOSInclude<ExtArgs> | null
    where?: SOSWhereInput
    orderBy?: SOSOrderByWithRelationInput | SOSOrderByWithRelationInput[]
    cursor?: SOSWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SOSScalarFieldEnum | SOSScalarFieldEnum[]
  }

  /**
   * EmergencyContact without action
   */
  export type EmergencyContactDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmergencyContact
     */
    select?: EmergencyContactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmergencyContact
     */
    omit?: EmergencyContactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmergencyContactInclude<ExtArgs> | null
  }


  /**
   * Model Review
   */

  export type AggregateReview = {
    _count: ReviewCountAggregateOutputType | null
    _avg: ReviewAvgAggregateOutputType | null
    _sum: ReviewSumAggregateOutputType | null
    _min: ReviewMinAggregateOutputType | null
    _max: ReviewMaxAggregateOutputType | null
  }

  export type ReviewAvgAggregateOutputType = {
    rating: number | null
  }

  export type ReviewSumAggregateOutputType = {
    rating: number | null
  }

  export type ReviewMinAggregateOutputType = {
    id: string | null
    serviceRequestId: string | null
    reviewerType: $Enums.SenderType | null
    rating: number | null
    comment: string | null
    createdAt: Date | null
    mechanicId: string | null
  }

  export type ReviewMaxAggregateOutputType = {
    id: string | null
    serviceRequestId: string | null
    reviewerType: $Enums.SenderType | null
    rating: number | null
    comment: string | null
    createdAt: Date | null
    mechanicId: string | null
  }

  export type ReviewCountAggregateOutputType = {
    id: number
    serviceRequestId: number
    reviewerType: number
    rating: number
    comment: number
    createdAt: number
    mechanicId: number
    _all: number
  }


  export type ReviewAvgAggregateInputType = {
    rating?: true
  }

  export type ReviewSumAggregateInputType = {
    rating?: true
  }

  export type ReviewMinAggregateInputType = {
    id?: true
    serviceRequestId?: true
    reviewerType?: true
    rating?: true
    comment?: true
    createdAt?: true
    mechanicId?: true
  }

  export type ReviewMaxAggregateInputType = {
    id?: true
    serviceRequestId?: true
    reviewerType?: true
    rating?: true
    comment?: true
    createdAt?: true
    mechanicId?: true
  }

  export type ReviewCountAggregateInputType = {
    id?: true
    serviceRequestId?: true
    reviewerType?: true
    rating?: true
    comment?: true
    createdAt?: true
    mechanicId?: true
    _all?: true
  }

  export type ReviewAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Review to aggregate.
     */
    where?: ReviewWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Reviews to fetch.
     */
    orderBy?: ReviewOrderByWithRelationInput | ReviewOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ReviewWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Reviews from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Reviews.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Reviews
    **/
    _count?: true | ReviewCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ReviewAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ReviewSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ReviewMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ReviewMaxAggregateInputType
  }

  export type GetReviewAggregateType<T extends ReviewAggregateArgs> = {
        [P in keyof T & keyof AggregateReview]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateReview[P]>
      : GetScalarType<T[P], AggregateReview[P]>
  }




  export type ReviewGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReviewWhereInput
    orderBy?: ReviewOrderByWithAggregationInput | ReviewOrderByWithAggregationInput[]
    by: ReviewScalarFieldEnum[] | ReviewScalarFieldEnum
    having?: ReviewScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ReviewCountAggregateInputType | true
    _avg?: ReviewAvgAggregateInputType
    _sum?: ReviewSumAggregateInputType
    _min?: ReviewMinAggregateInputType
    _max?: ReviewMaxAggregateInputType
  }

  export type ReviewGroupByOutputType = {
    id: string
    serviceRequestId: string
    reviewerType: $Enums.SenderType
    rating: number
    comment: string | null
    createdAt: Date
    mechanicId: string | null
    _count: ReviewCountAggregateOutputType | null
    _avg: ReviewAvgAggregateOutputType | null
    _sum: ReviewSumAggregateOutputType | null
    _min: ReviewMinAggregateOutputType | null
    _max: ReviewMaxAggregateOutputType | null
  }

  type GetReviewGroupByPayload<T extends ReviewGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ReviewGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ReviewGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ReviewGroupByOutputType[P]>
            : GetScalarType<T[P], ReviewGroupByOutputType[P]>
        }
      >
    >


  export type ReviewSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    serviceRequestId?: boolean
    reviewerType?: boolean
    rating?: boolean
    comment?: boolean
    createdAt?: boolean
    mechanicId?: boolean
    serviceRequest?: boolean | ServiceRequestDefaultArgs<ExtArgs>
    Mechanic?: boolean | Review$MechanicArgs<ExtArgs>
  }, ExtArgs["result"]["review"]>



  export type ReviewSelectScalar = {
    id?: boolean
    serviceRequestId?: boolean
    reviewerType?: boolean
    rating?: boolean
    comment?: boolean
    createdAt?: boolean
    mechanicId?: boolean
  }

  export type ReviewOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "serviceRequestId" | "reviewerType" | "rating" | "comment" | "createdAt" | "mechanicId", ExtArgs["result"]["review"]>
  export type ReviewInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    serviceRequest?: boolean | ServiceRequestDefaultArgs<ExtArgs>
    Mechanic?: boolean | Review$MechanicArgs<ExtArgs>
  }

  export type $ReviewPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Review"
    objects: {
      serviceRequest: Prisma.$ServiceRequestPayload<ExtArgs>
      Mechanic: Prisma.$MechanicPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      serviceRequestId: string
      reviewerType: $Enums.SenderType
      rating: number
      comment: string | null
      createdAt: Date
      mechanicId: string | null
    }, ExtArgs["result"]["review"]>
    composites: {}
  }

  type ReviewGetPayload<S extends boolean | null | undefined | ReviewDefaultArgs> = $Result.GetResult<Prisma.$ReviewPayload, S>

  type ReviewCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ReviewFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ReviewCountAggregateInputType | true
    }

  export interface ReviewDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Review'], meta: { name: 'Review' } }
    /**
     * Find zero or one Review that matches the filter.
     * @param {ReviewFindUniqueArgs} args - Arguments to find a Review
     * @example
     * // Get one Review
     * const review = await prisma.review.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ReviewFindUniqueArgs>(args: SelectSubset<T, ReviewFindUniqueArgs<ExtArgs>>): Prisma__ReviewClient<$Result.GetResult<Prisma.$ReviewPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Review that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ReviewFindUniqueOrThrowArgs} args - Arguments to find a Review
     * @example
     * // Get one Review
     * const review = await prisma.review.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ReviewFindUniqueOrThrowArgs>(args: SelectSubset<T, ReviewFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ReviewClient<$Result.GetResult<Prisma.$ReviewPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Review that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReviewFindFirstArgs} args - Arguments to find a Review
     * @example
     * // Get one Review
     * const review = await prisma.review.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ReviewFindFirstArgs>(args?: SelectSubset<T, ReviewFindFirstArgs<ExtArgs>>): Prisma__ReviewClient<$Result.GetResult<Prisma.$ReviewPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Review that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReviewFindFirstOrThrowArgs} args - Arguments to find a Review
     * @example
     * // Get one Review
     * const review = await prisma.review.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ReviewFindFirstOrThrowArgs>(args?: SelectSubset<T, ReviewFindFirstOrThrowArgs<ExtArgs>>): Prisma__ReviewClient<$Result.GetResult<Prisma.$ReviewPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Reviews that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReviewFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Reviews
     * const reviews = await prisma.review.findMany()
     * 
     * // Get first 10 Reviews
     * const reviews = await prisma.review.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const reviewWithIdOnly = await prisma.review.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ReviewFindManyArgs>(args?: SelectSubset<T, ReviewFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReviewPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Review.
     * @param {ReviewCreateArgs} args - Arguments to create a Review.
     * @example
     * // Create one Review
     * const Review = await prisma.review.create({
     *   data: {
     *     // ... data to create a Review
     *   }
     * })
     * 
     */
    create<T extends ReviewCreateArgs>(args: SelectSubset<T, ReviewCreateArgs<ExtArgs>>): Prisma__ReviewClient<$Result.GetResult<Prisma.$ReviewPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Reviews.
     * @param {ReviewCreateManyArgs} args - Arguments to create many Reviews.
     * @example
     * // Create many Reviews
     * const review = await prisma.review.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ReviewCreateManyArgs>(args?: SelectSubset<T, ReviewCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Review.
     * @param {ReviewDeleteArgs} args - Arguments to delete one Review.
     * @example
     * // Delete one Review
     * const Review = await prisma.review.delete({
     *   where: {
     *     // ... filter to delete one Review
     *   }
     * })
     * 
     */
    delete<T extends ReviewDeleteArgs>(args: SelectSubset<T, ReviewDeleteArgs<ExtArgs>>): Prisma__ReviewClient<$Result.GetResult<Prisma.$ReviewPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Review.
     * @param {ReviewUpdateArgs} args - Arguments to update one Review.
     * @example
     * // Update one Review
     * const review = await prisma.review.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ReviewUpdateArgs>(args: SelectSubset<T, ReviewUpdateArgs<ExtArgs>>): Prisma__ReviewClient<$Result.GetResult<Prisma.$ReviewPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Reviews.
     * @param {ReviewDeleteManyArgs} args - Arguments to filter Reviews to delete.
     * @example
     * // Delete a few Reviews
     * const { count } = await prisma.review.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ReviewDeleteManyArgs>(args?: SelectSubset<T, ReviewDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Reviews.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReviewUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Reviews
     * const review = await prisma.review.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ReviewUpdateManyArgs>(args: SelectSubset<T, ReviewUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Review.
     * @param {ReviewUpsertArgs} args - Arguments to update or create a Review.
     * @example
     * // Update or create a Review
     * const review = await prisma.review.upsert({
     *   create: {
     *     // ... data to create a Review
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Review we want to update
     *   }
     * })
     */
    upsert<T extends ReviewUpsertArgs>(args: SelectSubset<T, ReviewUpsertArgs<ExtArgs>>): Prisma__ReviewClient<$Result.GetResult<Prisma.$ReviewPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Reviews that matches the filter.
     * @param {ReviewFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const review = await prisma.review.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: ReviewFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a Review.
     * @param {ReviewAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const review = await prisma.review.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: ReviewAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of Reviews.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReviewCountArgs} args - Arguments to filter Reviews to count.
     * @example
     * // Count the number of Reviews
     * const count = await prisma.review.count({
     *   where: {
     *     // ... the filter for the Reviews we want to count
     *   }
     * })
    **/
    count<T extends ReviewCountArgs>(
      args?: Subset<T, ReviewCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ReviewCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Review.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReviewAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ReviewAggregateArgs>(args: Subset<T, ReviewAggregateArgs>): Prisma.PrismaPromise<GetReviewAggregateType<T>>

    /**
     * Group by Review.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReviewGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ReviewGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ReviewGroupByArgs['orderBy'] }
        : { orderBy?: ReviewGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ReviewGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetReviewGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Review model
   */
  readonly fields: ReviewFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Review.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ReviewClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    serviceRequest<T extends ServiceRequestDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ServiceRequestDefaultArgs<ExtArgs>>): Prisma__ServiceRequestClient<$Result.GetResult<Prisma.$ServiceRequestPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    Mechanic<T extends Review$MechanicArgs<ExtArgs> = {}>(args?: Subset<T, Review$MechanicArgs<ExtArgs>>): Prisma__MechanicClient<$Result.GetResult<Prisma.$MechanicPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Review model
   */ 
  interface ReviewFieldRefs {
    readonly id: FieldRef<"Review", 'String'>
    readonly serviceRequestId: FieldRef<"Review", 'String'>
    readonly reviewerType: FieldRef<"Review", 'SenderType'>
    readonly rating: FieldRef<"Review", 'Int'>
    readonly comment: FieldRef<"Review", 'String'>
    readonly createdAt: FieldRef<"Review", 'DateTime'>
    readonly mechanicId: FieldRef<"Review", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Review findUnique
   */
  export type ReviewFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Review
     */
    omit?: ReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewInclude<ExtArgs> | null
    /**
     * Filter, which Review to fetch.
     */
    where: ReviewWhereUniqueInput
  }

  /**
   * Review findUniqueOrThrow
   */
  export type ReviewFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Review
     */
    omit?: ReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewInclude<ExtArgs> | null
    /**
     * Filter, which Review to fetch.
     */
    where: ReviewWhereUniqueInput
  }

  /**
   * Review findFirst
   */
  export type ReviewFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Review
     */
    omit?: ReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewInclude<ExtArgs> | null
    /**
     * Filter, which Review to fetch.
     */
    where?: ReviewWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Reviews to fetch.
     */
    orderBy?: ReviewOrderByWithRelationInput | ReviewOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Reviews.
     */
    cursor?: ReviewWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Reviews from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Reviews.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Reviews.
     */
    distinct?: ReviewScalarFieldEnum | ReviewScalarFieldEnum[]
  }

  /**
   * Review findFirstOrThrow
   */
  export type ReviewFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Review
     */
    omit?: ReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewInclude<ExtArgs> | null
    /**
     * Filter, which Review to fetch.
     */
    where?: ReviewWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Reviews to fetch.
     */
    orderBy?: ReviewOrderByWithRelationInput | ReviewOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Reviews.
     */
    cursor?: ReviewWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Reviews from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Reviews.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Reviews.
     */
    distinct?: ReviewScalarFieldEnum | ReviewScalarFieldEnum[]
  }

  /**
   * Review findMany
   */
  export type ReviewFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Review
     */
    omit?: ReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewInclude<ExtArgs> | null
    /**
     * Filter, which Reviews to fetch.
     */
    where?: ReviewWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Reviews to fetch.
     */
    orderBy?: ReviewOrderByWithRelationInput | ReviewOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Reviews.
     */
    cursor?: ReviewWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Reviews from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Reviews.
     */
    skip?: number
    distinct?: ReviewScalarFieldEnum | ReviewScalarFieldEnum[]
  }

  /**
   * Review create
   */
  export type ReviewCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Review
     */
    omit?: ReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewInclude<ExtArgs> | null
    /**
     * The data needed to create a Review.
     */
    data: XOR<ReviewCreateInput, ReviewUncheckedCreateInput>
  }

  /**
   * Review createMany
   */
  export type ReviewCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Reviews.
     */
    data: ReviewCreateManyInput | ReviewCreateManyInput[]
  }

  /**
   * Review update
   */
  export type ReviewUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Review
     */
    omit?: ReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewInclude<ExtArgs> | null
    /**
     * The data needed to update a Review.
     */
    data: XOR<ReviewUpdateInput, ReviewUncheckedUpdateInput>
    /**
     * Choose, which Review to update.
     */
    where: ReviewWhereUniqueInput
  }

  /**
   * Review updateMany
   */
  export type ReviewUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Reviews.
     */
    data: XOR<ReviewUpdateManyMutationInput, ReviewUncheckedUpdateManyInput>
    /**
     * Filter which Reviews to update
     */
    where?: ReviewWhereInput
    /**
     * Limit how many Reviews to update.
     */
    limit?: number
  }

  /**
   * Review upsert
   */
  export type ReviewUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Review
     */
    omit?: ReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewInclude<ExtArgs> | null
    /**
     * The filter to search for the Review to update in case it exists.
     */
    where: ReviewWhereUniqueInput
    /**
     * In case the Review found by the `where` argument doesn't exist, create a new Review with this data.
     */
    create: XOR<ReviewCreateInput, ReviewUncheckedCreateInput>
    /**
     * In case the Review was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ReviewUpdateInput, ReviewUncheckedUpdateInput>
  }

  /**
   * Review delete
   */
  export type ReviewDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Review
     */
    omit?: ReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewInclude<ExtArgs> | null
    /**
     * Filter which Review to delete.
     */
    where: ReviewWhereUniqueInput
  }

  /**
   * Review deleteMany
   */
  export type ReviewDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Reviews to delete
     */
    where?: ReviewWhereInput
    /**
     * Limit how many Reviews to delete.
     */
    limit?: number
  }

  /**
   * Review findRaw
   */
  export type ReviewFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * Review aggregateRaw
   */
  export type ReviewAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * Review.Mechanic
   */
  export type Review$MechanicArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Mechanic
     */
    select?: MechanicSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Mechanic
     */
    omit?: MechanicOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MechanicInclude<ExtArgs> | null
    where?: MechanicWhereInput
  }

  /**
   * Review without action
   */
  export type ReviewDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Review
     */
    omit?: ReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewInclude<ExtArgs> | null
  }


  /**
   * Model Payment
   */

  export type AggregatePayment = {
    _count: PaymentCountAggregateOutputType | null
    _avg: PaymentAvgAggregateOutputType | null
    _sum: PaymentSumAggregateOutputType | null
    _min: PaymentMinAggregateOutputType | null
    _max: PaymentMaxAggregateOutputType | null
  }

  export type PaymentAvgAggregateOutputType = {
    amount: number | null
  }

  export type PaymentSumAggregateOutputType = {
    amount: number | null
  }

  export type PaymentMinAggregateOutputType = {
    id: string | null
    serviceRequestId: string | null
    amount: number | null
    status: $Enums.PaymentStatus | null
    razorpayOrderId: string | null
    razorpayPaymentId: string | null
    razorpaySignature: string | null
    comment: string | null
    createdAt: Date | null
  }

  export type PaymentMaxAggregateOutputType = {
    id: string | null
    serviceRequestId: string | null
    amount: number | null
    status: $Enums.PaymentStatus | null
    razorpayOrderId: string | null
    razorpayPaymentId: string | null
    razorpaySignature: string | null
    comment: string | null
    createdAt: Date | null
  }

  export type PaymentCountAggregateOutputType = {
    id: number
    serviceRequestId: number
    amount: number
    status: number
    razorpayOrderId: number
    razorpayPaymentId: number
    razorpaySignature: number
    comment: number
    createdAt: number
    _all: number
  }


  export type PaymentAvgAggregateInputType = {
    amount?: true
  }

  export type PaymentSumAggregateInputType = {
    amount?: true
  }

  export type PaymentMinAggregateInputType = {
    id?: true
    serviceRequestId?: true
    amount?: true
    status?: true
    razorpayOrderId?: true
    razorpayPaymentId?: true
    razorpaySignature?: true
    comment?: true
    createdAt?: true
  }

  export type PaymentMaxAggregateInputType = {
    id?: true
    serviceRequestId?: true
    amount?: true
    status?: true
    razorpayOrderId?: true
    razorpayPaymentId?: true
    razorpaySignature?: true
    comment?: true
    createdAt?: true
  }

  export type PaymentCountAggregateInputType = {
    id?: true
    serviceRequestId?: true
    amount?: true
    status?: true
    razorpayOrderId?: true
    razorpayPaymentId?: true
    razorpaySignature?: true
    comment?: true
    createdAt?: true
    _all?: true
  }

  export type PaymentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Payment to aggregate.
     */
    where?: PaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Payments to fetch.
     */
    orderBy?: PaymentOrderByWithRelationInput | PaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Payments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Payments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Payments
    **/
    _count?: true | PaymentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PaymentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PaymentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PaymentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PaymentMaxAggregateInputType
  }

  export type GetPaymentAggregateType<T extends PaymentAggregateArgs> = {
        [P in keyof T & keyof AggregatePayment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePayment[P]>
      : GetScalarType<T[P], AggregatePayment[P]>
  }




  export type PaymentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PaymentWhereInput
    orderBy?: PaymentOrderByWithAggregationInput | PaymentOrderByWithAggregationInput[]
    by: PaymentScalarFieldEnum[] | PaymentScalarFieldEnum
    having?: PaymentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PaymentCountAggregateInputType | true
    _avg?: PaymentAvgAggregateInputType
    _sum?: PaymentSumAggregateInputType
    _min?: PaymentMinAggregateInputType
    _max?: PaymentMaxAggregateInputType
  }

  export type PaymentGroupByOutputType = {
    id: string
    serviceRequestId: string
    amount: number
    status: $Enums.PaymentStatus
    razorpayOrderId: string | null
    razorpayPaymentId: string | null
    razorpaySignature: string | null
    comment: string | null
    createdAt: Date
    _count: PaymentCountAggregateOutputType | null
    _avg: PaymentAvgAggregateOutputType | null
    _sum: PaymentSumAggregateOutputType | null
    _min: PaymentMinAggregateOutputType | null
    _max: PaymentMaxAggregateOutputType | null
  }

  type GetPaymentGroupByPayload<T extends PaymentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PaymentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PaymentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PaymentGroupByOutputType[P]>
            : GetScalarType<T[P], PaymentGroupByOutputType[P]>
        }
      >
    >


  export type PaymentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    serviceRequestId?: boolean
    amount?: boolean
    status?: boolean
    razorpayOrderId?: boolean
    razorpayPaymentId?: boolean
    razorpaySignature?: boolean
    comment?: boolean
    createdAt?: boolean
    serviceRequest?: boolean | ServiceRequestDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["payment"]>



  export type PaymentSelectScalar = {
    id?: boolean
    serviceRequestId?: boolean
    amount?: boolean
    status?: boolean
    razorpayOrderId?: boolean
    razorpayPaymentId?: boolean
    razorpaySignature?: boolean
    comment?: boolean
    createdAt?: boolean
  }

  export type PaymentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "serviceRequestId" | "amount" | "status" | "razorpayOrderId" | "razorpayPaymentId" | "razorpaySignature" | "comment" | "createdAt", ExtArgs["result"]["payment"]>
  export type PaymentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    serviceRequest?: boolean | ServiceRequestDefaultArgs<ExtArgs>
  }

  export type $PaymentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Payment"
    objects: {
      serviceRequest: Prisma.$ServiceRequestPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      serviceRequestId: string
      amount: number
      status: $Enums.PaymentStatus
      razorpayOrderId: string | null
      razorpayPaymentId: string | null
      razorpaySignature: string | null
      comment: string | null
      createdAt: Date
    }, ExtArgs["result"]["payment"]>
    composites: {}
  }

  type PaymentGetPayload<S extends boolean | null | undefined | PaymentDefaultArgs> = $Result.GetResult<Prisma.$PaymentPayload, S>

  type PaymentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PaymentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PaymentCountAggregateInputType | true
    }

  export interface PaymentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Payment'], meta: { name: 'Payment' } }
    /**
     * Find zero or one Payment that matches the filter.
     * @param {PaymentFindUniqueArgs} args - Arguments to find a Payment
     * @example
     * // Get one Payment
     * const payment = await prisma.payment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PaymentFindUniqueArgs>(args: SelectSubset<T, PaymentFindUniqueArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Payment that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PaymentFindUniqueOrThrowArgs} args - Arguments to find a Payment
     * @example
     * // Get one Payment
     * const payment = await prisma.payment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PaymentFindUniqueOrThrowArgs>(args: SelectSubset<T, PaymentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Payment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentFindFirstArgs} args - Arguments to find a Payment
     * @example
     * // Get one Payment
     * const payment = await prisma.payment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PaymentFindFirstArgs>(args?: SelectSubset<T, PaymentFindFirstArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Payment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentFindFirstOrThrowArgs} args - Arguments to find a Payment
     * @example
     * // Get one Payment
     * const payment = await prisma.payment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PaymentFindFirstOrThrowArgs>(args?: SelectSubset<T, PaymentFindFirstOrThrowArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Payments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Payments
     * const payments = await prisma.payment.findMany()
     * 
     * // Get first 10 Payments
     * const payments = await prisma.payment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const paymentWithIdOnly = await prisma.payment.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PaymentFindManyArgs>(args?: SelectSubset<T, PaymentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Payment.
     * @param {PaymentCreateArgs} args - Arguments to create a Payment.
     * @example
     * // Create one Payment
     * const Payment = await prisma.payment.create({
     *   data: {
     *     // ... data to create a Payment
     *   }
     * })
     * 
     */
    create<T extends PaymentCreateArgs>(args: SelectSubset<T, PaymentCreateArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Payments.
     * @param {PaymentCreateManyArgs} args - Arguments to create many Payments.
     * @example
     * // Create many Payments
     * const payment = await prisma.payment.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PaymentCreateManyArgs>(args?: SelectSubset<T, PaymentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Payment.
     * @param {PaymentDeleteArgs} args - Arguments to delete one Payment.
     * @example
     * // Delete one Payment
     * const Payment = await prisma.payment.delete({
     *   where: {
     *     // ... filter to delete one Payment
     *   }
     * })
     * 
     */
    delete<T extends PaymentDeleteArgs>(args: SelectSubset<T, PaymentDeleteArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Payment.
     * @param {PaymentUpdateArgs} args - Arguments to update one Payment.
     * @example
     * // Update one Payment
     * const payment = await prisma.payment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PaymentUpdateArgs>(args: SelectSubset<T, PaymentUpdateArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Payments.
     * @param {PaymentDeleteManyArgs} args - Arguments to filter Payments to delete.
     * @example
     * // Delete a few Payments
     * const { count } = await prisma.payment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PaymentDeleteManyArgs>(args?: SelectSubset<T, PaymentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Payments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Payments
     * const payment = await prisma.payment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PaymentUpdateManyArgs>(args: SelectSubset<T, PaymentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Payment.
     * @param {PaymentUpsertArgs} args - Arguments to update or create a Payment.
     * @example
     * // Update or create a Payment
     * const payment = await prisma.payment.upsert({
     *   create: {
     *     // ... data to create a Payment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Payment we want to update
     *   }
     * })
     */
    upsert<T extends PaymentUpsertArgs>(args: SelectSubset<T, PaymentUpsertArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Payments that matches the filter.
     * @param {PaymentFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const payment = await prisma.payment.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: PaymentFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a Payment.
     * @param {PaymentAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const payment = await prisma.payment.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: PaymentAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of Payments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentCountArgs} args - Arguments to filter Payments to count.
     * @example
     * // Count the number of Payments
     * const count = await prisma.payment.count({
     *   where: {
     *     // ... the filter for the Payments we want to count
     *   }
     * })
    **/
    count<T extends PaymentCountArgs>(
      args?: Subset<T, PaymentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PaymentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Payment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PaymentAggregateArgs>(args: Subset<T, PaymentAggregateArgs>): Prisma.PrismaPromise<GetPaymentAggregateType<T>>

    /**
     * Group by Payment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PaymentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PaymentGroupByArgs['orderBy'] }
        : { orderBy?: PaymentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PaymentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPaymentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Payment model
   */
  readonly fields: PaymentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Payment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PaymentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    serviceRequest<T extends ServiceRequestDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ServiceRequestDefaultArgs<ExtArgs>>): Prisma__ServiceRequestClient<$Result.GetResult<Prisma.$ServiceRequestPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Payment model
   */ 
  interface PaymentFieldRefs {
    readonly id: FieldRef<"Payment", 'String'>
    readonly serviceRequestId: FieldRef<"Payment", 'String'>
    readonly amount: FieldRef<"Payment", 'Float'>
    readonly status: FieldRef<"Payment", 'PaymentStatus'>
    readonly razorpayOrderId: FieldRef<"Payment", 'String'>
    readonly razorpayPaymentId: FieldRef<"Payment", 'String'>
    readonly razorpaySignature: FieldRef<"Payment", 'String'>
    readonly comment: FieldRef<"Payment", 'String'>
    readonly createdAt: FieldRef<"Payment", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Payment findUnique
   */
  export type PaymentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter, which Payment to fetch.
     */
    where: PaymentWhereUniqueInput
  }

  /**
   * Payment findUniqueOrThrow
   */
  export type PaymentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter, which Payment to fetch.
     */
    where: PaymentWhereUniqueInput
  }

  /**
   * Payment findFirst
   */
  export type PaymentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter, which Payment to fetch.
     */
    where?: PaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Payments to fetch.
     */
    orderBy?: PaymentOrderByWithRelationInput | PaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Payments.
     */
    cursor?: PaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Payments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Payments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Payments.
     */
    distinct?: PaymentScalarFieldEnum | PaymentScalarFieldEnum[]
  }

  /**
   * Payment findFirstOrThrow
   */
  export type PaymentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter, which Payment to fetch.
     */
    where?: PaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Payments to fetch.
     */
    orderBy?: PaymentOrderByWithRelationInput | PaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Payments.
     */
    cursor?: PaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Payments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Payments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Payments.
     */
    distinct?: PaymentScalarFieldEnum | PaymentScalarFieldEnum[]
  }

  /**
   * Payment findMany
   */
  export type PaymentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter, which Payments to fetch.
     */
    where?: PaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Payments to fetch.
     */
    orderBy?: PaymentOrderByWithRelationInput | PaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Payments.
     */
    cursor?: PaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Payments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Payments.
     */
    skip?: number
    distinct?: PaymentScalarFieldEnum | PaymentScalarFieldEnum[]
  }

  /**
   * Payment create
   */
  export type PaymentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * The data needed to create a Payment.
     */
    data: XOR<PaymentCreateInput, PaymentUncheckedCreateInput>
  }

  /**
   * Payment createMany
   */
  export type PaymentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Payments.
     */
    data: PaymentCreateManyInput | PaymentCreateManyInput[]
  }

  /**
   * Payment update
   */
  export type PaymentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * The data needed to update a Payment.
     */
    data: XOR<PaymentUpdateInput, PaymentUncheckedUpdateInput>
    /**
     * Choose, which Payment to update.
     */
    where: PaymentWhereUniqueInput
  }

  /**
   * Payment updateMany
   */
  export type PaymentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Payments.
     */
    data: XOR<PaymentUpdateManyMutationInput, PaymentUncheckedUpdateManyInput>
    /**
     * Filter which Payments to update
     */
    where?: PaymentWhereInput
    /**
     * Limit how many Payments to update.
     */
    limit?: number
  }

  /**
   * Payment upsert
   */
  export type PaymentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * The filter to search for the Payment to update in case it exists.
     */
    where: PaymentWhereUniqueInput
    /**
     * In case the Payment found by the `where` argument doesn't exist, create a new Payment with this data.
     */
    create: XOR<PaymentCreateInput, PaymentUncheckedCreateInput>
    /**
     * In case the Payment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PaymentUpdateInput, PaymentUncheckedUpdateInput>
  }

  /**
   * Payment delete
   */
  export type PaymentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter which Payment to delete.
     */
    where: PaymentWhereUniqueInput
  }

  /**
   * Payment deleteMany
   */
  export type PaymentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Payments to delete
     */
    where?: PaymentWhereInput
    /**
     * Limit how many Payments to delete.
     */
    limit?: number
  }

  /**
   * Payment findRaw
   */
  export type PaymentFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * Payment aggregateRaw
   */
  export type PaymentAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * Payment without action
   */
  export type PaymentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
  }


  /**
   * Model Chat
   */

  export type AggregateChat = {
    _count: ChatCountAggregateOutputType | null
    _min: ChatMinAggregateOutputType | null
    _max: ChatMaxAggregateOutputType | null
  }

  export type ChatMinAggregateOutputType = {
    id: string | null
    serviceRequestId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ChatMaxAggregateOutputType = {
    id: string | null
    serviceRequestId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ChatCountAggregateOutputType = {
    id: number
    serviceRequestId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ChatMinAggregateInputType = {
    id?: true
    serviceRequestId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ChatMaxAggregateInputType = {
    id?: true
    serviceRequestId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ChatCountAggregateInputType = {
    id?: true
    serviceRequestId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ChatAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Chat to aggregate.
     */
    where?: ChatWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Chats to fetch.
     */
    orderBy?: ChatOrderByWithRelationInput | ChatOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ChatWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Chats from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Chats.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Chats
    **/
    _count?: true | ChatCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ChatMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ChatMaxAggregateInputType
  }

  export type GetChatAggregateType<T extends ChatAggregateArgs> = {
        [P in keyof T & keyof AggregateChat]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateChat[P]>
      : GetScalarType<T[P], AggregateChat[P]>
  }




  export type ChatGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ChatWhereInput
    orderBy?: ChatOrderByWithAggregationInput | ChatOrderByWithAggregationInput[]
    by: ChatScalarFieldEnum[] | ChatScalarFieldEnum
    having?: ChatScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ChatCountAggregateInputType | true
    _min?: ChatMinAggregateInputType
    _max?: ChatMaxAggregateInputType
  }

  export type ChatGroupByOutputType = {
    id: string
    serviceRequestId: string
    createdAt: Date
    updatedAt: Date
    _count: ChatCountAggregateOutputType | null
    _min: ChatMinAggregateOutputType | null
    _max: ChatMaxAggregateOutputType | null
  }

  type GetChatGroupByPayload<T extends ChatGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ChatGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ChatGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ChatGroupByOutputType[P]>
            : GetScalarType<T[P], ChatGroupByOutputType[P]>
        }
      >
    >


  export type ChatSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    serviceRequestId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    serviceRequest?: boolean | ServiceRequestDefaultArgs<ExtArgs>
    messages?: boolean | Chat$messagesArgs<ExtArgs>
    _count?: boolean | ChatCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["chat"]>



  export type ChatSelectScalar = {
    id?: boolean
    serviceRequestId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ChatOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "serviceRequestId" | "createdAt" | "updatedAt", ExtArgs["result"]["chat"]>
  export type ChatInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    serviceRequest?: boolean | ServiceRequestDefaultArgs<ExtArgs>
    messages?: boolean | Chat$messagesArgs<ExtArgs>
    _count?: boolean | ChatCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $ChatPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Chat"
    objects: {
      serviceRequest: Prisma.$ServiceRequestPayload<ExtArgs>
      messages: Prisma.$MessagePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      serviceRequestId: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["chat"]>
    composites: {}
  }

  type ChatGetPayload<S extends boolean | null | undefined | ChatDefaultArgs> = $Result.GetResult<Prisma.$ChatPayload, S>

  type ChatCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ChatFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ChatCountAggregateInputType | true
    }

  export interface ChatDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Chat'], meta: { name: 'Chat' } }
    /**
     * Find zero or one Chat that matches the filter.
     * @param {ChatFindUniqueArgs} args - Arguments to find a Chat
     * @example
     * // Get one Chat
     * const chat = await prisma.chat.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ChatFindUniqueArgs>(args: SelectSubset<T, ChatFindUniqueArgs<ExtArgs>>): Prisma__ChatClient<$Result.GetResult<Prisma.$ChatPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Chat that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ChatFindUniqueOrThrowArgs} args - Arguments to find a Chat
     * @example
     * // Get one Chat
     * const chat = await prisma.chat.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ChatFindUniqueOrThrowArgs>(args: SelectSubset<T, ChatFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ChatClient<$Result.GetResult<Prisma.$ChatPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Chat that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChatFindFirstArgs} args - Arguments to find a Chat
     * @example
     * // Get one Chat
     * const chat = await prisma.chat.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ChatFindFirstArgs>(args?: SelectSubset<T, ChatFindFirstArgs<ExtArgs>>): Prisma__ChatClient<$Result.GetResult<Prisma.$ChatPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Chat that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChatFindFirstOrThrowArgs} args - Arguments to find a Chat
     * @example
     * // Get one Chat
     * const chat = await prisma.chat.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ChatFindFirstOrThrowArgs>(args?: SelectSubset<T, ChatFindFirstOrThrowArgs<ExtArgs>>): Prisma__ChatClient<$Result.GetResult<Prisma.$ChatPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Chats that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChatFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Chats
     * const chats = await prisma.chat.findMany()
     * 
     * // Get first 10 Chats
     * const chats = await prisma.chat.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const chatWithIdOnly = await prisma.chat.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ChatFindManyArgs>(args?: SelectSubset<T, ChatFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChatPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Chat.
     * @param {ChatCreateArgs} args - Arguments to create a Chat.
     * @example
     * // Create one Chat
     * const Chat = await prisma.chat.create({
     *   data: {
     *     // ... data to create a Chat
     *   }
     * })
     * 
     */
    create<T extends ChatCreateArgs>(args: SelectSubset<T, ChatCreateArgs<ExtArgs>>): Prisma__ChatClient<$Result.GetResult<Prisma.$ChatPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Chats.
     * @param {ChatCreateManyArgs} args - Arguments to create many Chats.
     * @example
     * // Create many Chats
     * const chat = await prisma.chat.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ChatCreateManyArgs>(args?: SelectSubset<T, ChatCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Chat.
     * @param {ChatDeleteArgs} args - Arguments to delete one Chat.
     * @example
     * // Delete one Chat
     * const Chat = await prisma.chat.delete({
     *   where: {
     *     // ... filter to delete one Chat
     *   }
     * })
     * 
     */
    delete<T extends ChatDeleteArgs>(args: SelectSubset<T, ChatDeleteArgs<ExtArgs>>): Prisma__ChatClient<$Result.GetResult<Prisma.$ChatPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Chat.
     * @param {ChatUpdateArgs} args - Arguments to update one Chat.
     * @example
     * // Update one Chat
     * const chat = await prisma.chat.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ChatUpdateArgs>(args: SelectSubset<T, ChatUpdateArgs<ExtArgs>>): Prisma__ChatClient<$Result.GetResult<Prisma.$ChatPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Chats.
     * @param {ChatDeleteManyArgs} args - Arguments to filter Chats to delete.
     * @example
     * // Delete a few Chats
     * const { count } = await prisma.chat.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ChatDeleteManyArgs>(args?: SelectSubset<T, ChatDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Chats.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChatUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Chats
     * const chat = await prisma.chat.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ChatUpdateManyArgs>(args: SelectSubset<T, ChatUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Chat.
     * @param {ChatUpsertArgs} args - Arguments to update or create a Chat.
     * @example
     * // Update or create a Chat
     * const chat = await prisma.chat.upsert({
     *   create: {
     *     // ... data to create a Chat
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Chat we want to update
     *   }
     * })
     */
    upsert<T extends ChatUpsertArgs>(args: SelectSubset<T, ChatUpsertArgs<ExtArgs>>): Prisma__ChatClient<$Result.GetResult<Prisma.$ChatPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Chats that matches the filter.
     * @param {ChatFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const chat = await prisma.chat.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: ChatFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a Chat.
     * @param {ChatAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const chat = await prisma.chat.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: ChatAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of Chats.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChatCountArgs} args - Arguments to filter Chats to count.
     * @example
     * // Count the number of Chats
     * const count = await prisma.chat.count({
     *   where: {
     *     // ... the filter for the Chats we want to count
     *   }
     * })
    **/
    count<T extends ChatCountArgs>(
      args?: Subset<T, ChatCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ChatCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Chat.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChatAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ChatAggregateArgs>(args: Subset<T, ChatAggregateArgs>): Prisma.PrismaPromise<GetChatAggregateType<T>>

    /**
     * Group by Chat.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChatGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ChatGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ChatGroupByArgs['orderBy'] }
        : { orderBy?: ChatGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ChatGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetChatGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Chat model
   */
  readonly fields: ChatFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Chat.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ChatClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    serviceRequest<T extends ServiceRequestDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ServiceRequestDefaultArgs<ExtArgs>>): Prisma__ServiceRequestClient<$Result.GetResult<Prisma.$ServiceRequestPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    messages<T extends Chat$messagesArgs<ExtArgs> = {}>(args?: Subset<T, Chat$messagesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Chat model
   */ 
  interface ChatFieldRefs {
    readonly id: FieldRef<"Chat", 'String'>
    readonly serviceRequestId: FieldRef<"Chat", 'String'>
    readonly createdAt: FieldRef<"Chat", 'DateTime'>
    readonly updatedAt: FieldRef<"Chat", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Chat findUnique
   */
  export type ChatFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Chat
     */
    select?: ChatSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Chat
     */
    omit?: ChatOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatInclude<ExtArgs> | null
    /**
     * Filter, which Chat to fetch.
     */
    where: ChatWhereUniqueInput
  }

  /**
   * Chat findUniqueOrThrow
   */
  export type ChatFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Chat
     */
    select?: ChatSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Chat
     */
    omit?: ChatOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatInclude<ExtArgs> | null
    /**
     * Filter, which Chat to fetch.
     */
    where: ChatWhereUniqueInput
  }

  /**
   * Chat findFirst
   */
  export type ChatFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Chat
     */
    select?: ChatSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Chat
     */
    omit?: ChatOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatInclude<ExtArgs> | null
    /**
     * Filter, which Chat to fetch.
     */
    where?: ChatWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Chats to fetch.
     */
    orderBy?: ChatOrderByWithRelationInput | ChatOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Chats.
     */
    cursor?: ChatWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Chats from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Chats.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Chats.
     */
    distinct?: ChatScalarFieldEnum | ChatScalarFieldEnum[]
  }

  /**
   * Chat findFirstOrThrow
   */
  export type ChatFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Chat
     */
    select?: ChatSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Chat
     */
    omit?: ChatOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatInclude<ExtArgs> | null
    /**
     * Filter, which Chat to fetch.
     */
    where?: ChatWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Chats to fetch.
     */
    orderBy?: ChatOrderByWithRelationInput | ChatOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Chats.
     */
    cursor?: ChatWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Chats from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Chats.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Chats.
     */
    distinct?: ChatScalarFieldEnum | ChatScalarFieldEnum[]
  }

  /**
   * Chat findMany
   */
  export type ChatFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Chat
     */
    select?: ChatSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Chat
     */
    omit?: ChatOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatInclude<ExtArgs> | null
    /**
     * Filter, which Chats to fetch.
     */
    where?: ChatWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Chats to fetch.
     */
    orderBy?: ChatOrderByWithRelationInput | ChatOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Chats.
     */
    cursor?: ChatWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Chats from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Chats.
     */
    skip?: number
    distinct?: ChatScalarFieldEnum | ChatScalarFieldEnum[]
  }

  /**
   * Chat create
   */
  export type ChatCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Chat
     */
    select?: ChatSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Chat
     */
    omit?: ChatOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatInclude<ExtArgs> | null
    /**
     * The data needed to create a Chat.
     */
    data: XOR<ChatCreateInput, ChatUncheckedCreateInput>
  }

  /**
   * Chat createMany
   */
  export type ChatCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Chats.
     */
    data: ChatCreateManyInput | ChatCreateManyInput[]
  }

  /**
   * Chat update
   */
  export type ChatUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Chat
     */
    select?: ChatSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Chat
     */
    omit?: ChatOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatInclude<ExtArgs> | null
    /**
     * The data needed to update a Chat.
     */
    data: XOR<ChatUpdateInput, ChatUncheckedUpdateInput>
    /**
     * Choose, which Chat to update.
     */
    where: ChatWhereUniqueInput
  }

  /**
   * Chat updateMany
   */
  export type ChatUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Chats.
     */
    data: XOR<ChatUpdateManyMutationInput, ChatUncheckedUpdateManyInput>
    /**
     * Filter which Chats to update
     */
    where?: ChatWhereInput
    /**
     * Limit how many Chats to update.
     */
    limit?: number
  }

  /**
   * Chat upsert
   */
  export type ChatUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Chat
     */
    select?: ChatSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Chat
     */
    omit?: ChatOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatInclude<ExtArgs> | null
    /**
     * The filter to search for the Chat to update in case it exists.
     */
    where: ChatWhereUniqueInput
    /**
     * In case the Chat found by the `where` argument doesn't exist, create a new Chat with this data.
     */
    create: XOR<ChatCreateInput, ChatUncheckedCreateInput>
    /**
     * In case the Chat was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ChatUpdateInput, ChatUncheckedUpdateInput>
  }

  /**
   * Chat delete
   */
  export type ChatDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Chat
     */
    select?: ChatSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Chat
     */
    omit?: ChatOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatInclude<ExtArgs> | null
    /**
     * Filter which Chat to delete.
     */
    where: ChatWhereUniqueInput
  }

  /**
   * Chat deleteMany
   */
  export type ChatDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Chats to delete
     */
    where?: ChatWhereInput
    /**
     * Limit how many Chats to delete.
     */
    limit?: number
  }

  /**
   * Chat findRaw
   */
  export type ChatFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * Chat aggregateRaw
   */
  export type ChatAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * Chat.messages
   */
  export type Chat$messagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    where?: MessageWhereInput
    orderBy?: MessageOrderByWithRelationInput | MessageOrderByWithRelationInput[]
    cursor?: MessageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MessageScalarFieldEnum | MessageScalarFieldEnum[]
  }

  /**
   * Chat without action
   */
  export type ChatDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Chat
     */
    select?: ChatSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Chat
     */
    omit?: ChatOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatInclude<ExtArgs> | null
  }


  /**
   * Model Message
   */

  export type AggregateMessage = {
    _count: MessageCountAggregateOutputType | null
    _min: MessageMinAggregateOutputType | null
    _max: MessageMaxAggregateOutputType | null
  }

  export type MessageMinAggregateOutputType = {
    id: string | null
    chatId: string | null
    senderId: string | null
    senderType: string | null
    content: string | null
    createdAt: Date | null
  }

  export type MessageMaxAggregateOutputType = {
    id: string | null
    chatId: string | null
    senderId: string | null
    senderType: string | null
    content: string | null
    createdAt: Date | null
  }

  export type MessageCountAggregateOutputType = {
    id: number
    chatId: number
    senderId: number
    senderType: number
    content: number
    createdAt: number
    _all: number
  }


  export type MessageMinAggregateInputType = {
    id?: true
    chatId?: true
    senderId?: true
    senderType?: true
    content?: true
    createdAt?: true
  }

  export type MessageMaxAggregateInputType = {
    id?: true
    chatId?: true
    senderId?: true
    senderType?: true
    content?: true
    createdAt?: true
  }

  export type MessageCountAggregateInputType = {
    id?: true
    chatId?: true
    senderId?: true
    senderType?: true
    content?: true
    createdAt?: true
    _all?: true
  }

  export type MessageAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Message to aggregate.
     */
    where?: MessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Messages to fetch.
     */
    orderBy?: MessageOrderByWithRelationInput | MessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Messages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Messages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Messages
    **/
    _count?: true | MessageCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MessageMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MessageMaxAggregateInputType
  }

  export type GetMessageAggregateType<T extends MessageAggregateArgs> = {
        [P in keyof T & keyof AggregateMessage]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMessage[P]>
      : GetScalarType<T[P], AggregateMessage[P]>
  }




  export type MessageGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MessageWhereInput
    orderBy?: MessageOrderByWithAggregationInput | MessageOrderByWithAggregationInput[]
    by: MessageScalarFieldEnum[] | MessageScalarFieldEnum
    having?: MessageScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MessageCountAggregateInputType | true
    _min?: MessageMinAggregateInputType
    _max?: MessageMaxAggregateInputType
  }

  export type MessageGroupByOutputType = {
    id: string
    chatId: string
    senderId: string | null
    senderType: string
    content: string
    createdAt: Date
    _count: MessageCountAggregateOutputType | null
    _min: MessageMinAggregateOutputType | null
    _max: MessageMaxAggregateOutputType | null
  }

  type GetMessageGroupByPayload<T extends MessageGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MessageGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MessageGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MessageGroupByOutputType[P]>
            : GetScalarType<T[P], MessageGroupByOutputType[P]>
        }
      >
    >


  export type MessageSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    chatId?: boolean
    senderId?: boolean
    senderType?: boolean
    content?: boolean
    createdAt?: boolean
    chat?: boolean | ChatDefaultArgs<ExtArgs>
    user?: boolean | Message$userArgs<ExtArgs>
    mechanic?: boolean | Message$mechanicArgs<ExtArgs>
  }, ExtArgs["result"]["message"]>



  export type MessageSelectScalar = {
    id?: boolean
    chatId?: boolean
    senderId?: boolean
    senderType?: boolean
    content?: boolean
    createdAt?: boolean
  }

  export type MessageOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "chatId" | "senderId" | "senderType" | "content" | "createdAt", ExtArgs["result"]["message"]>
  export type MessageInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    chat?: boolean | ChatDefaultArgs<ExtArgs>
    user?: boolean | Message$userArgs<ExtArgs>
    mechanic?: boolean | Message$mechanicArgs<ExtArgs>
  }

  export type $MessagePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Message"
    objects: {
      chat: Prisma.$ChatPayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs> | null
      mechanic: Prisma.$MechanicPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      chatId: string
      senderId: string | null
      senderType: string
      content: string
      createdAt: Date
    }, ExtArgs["result"]["message"]>
    composites: {}
  }

  type MessageGetPayload<S extends boolean | null | undefined | MessageDefaultArgs> = $Result.GetResult<Prisma.$MessagePayload, S>

  type MessageCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<MessageFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: MessageCountAggregateInputType | true
    }

  export interface MessageDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Message'], meta: { name: 'Message' } }
    /**
     * Find zero or one Message that matches the filter.
     * @param {MessageFindUniqueArgs} args - Arguments to find a Message
     * @example
     * // Get one Message
     * const message = await prisma.message.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MessageFindUniqueArgs>(args: SelectSubset<T, MessageFindUniqueArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Message that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {MessageFindUniqueOrThrowArgs} args - Arguments to find a Message
     * @example
     * // Get one Message
     * const message = await prisma.message.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MessageFindUniqueOrThrowArgs>(args: SelectSubset<T, MessageFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Message that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageFindFirstArgs} args - Arguments to find a Message
     * @example
     * // Get one Message
     * const message = await prisma.message.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MessageFindFirstArgs>(args?: SelectSubset<T, MessageFindFirstArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Message that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageFindFirstOrThrowArgs} args - Arguments to find a Message
     * @example
     * // Get one Message
     * const message = await prisma.message.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MessageFindFirstOrThrowArgs>(args?: SelectSubset<T, MessageFindFirstOrThrowArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Messages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Messages
     * const messages = await prisma.message.findMany()
     * 
     * // Get first 10 Messages
     * const messages = await prisma.message.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const messageWithIdOnly = await prisma.message.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MessageFindManyArgs>(args?: SelectSubset<T, MessageFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Message.
     * @param {MessageCreateArgs} args - Arguments to create a Message.
     * @example
     * // Create one Message
     * const Message = await prisma.message.create({
     *   data: {
     *     // ... data to create a Message
     *   }
     * })
     * 
     */
    create<T extends MessageCreateArgs>(args: SelectSubset<T, MessageCreateArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Messages.
     * @param {MessageCreateManyArgs} args - Arguments to create many Messages.
     * @example
     * // Create many Messages
     * const message = await prisma.message.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MessageCreateManyArgs>(args?: SelectSubset<T, MessageCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Message.
     * @param {MessageDeleteArgs} args - Arguments to delete one Message.
     * @example
     * // Delete one Message
     * const Message = await prisma.message.delete({
     *   where: {
     *     // ... filter to delete one Message
     *   }
     * })
     * 
     */
    delete<T extends MessageDeleteArgs>(args: SelectSubset<T, MessageDeleteArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Message.
     * @param {MessageUpdateArgs} args - Arguments to update one Message.
     * @example
     * // Update one Message
     * const message = await prisma.message.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MessageUpdateArgs>(args: SelectSubset<T, MessageUpdateArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Messages.
     * @param {MessageDeleteManyArgs} args - Arguments to filter Messages to delete.
     * @example
     * // Delete a few Messages
     * const { count } = await prisma.message.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MessageDeleteManyArgs>(args?: SelectSubset<T, MessageDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Messages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Messages
     * const message = await prisma.message.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MessageUpdateManyArgs>(args: SelectSubset<T, MessageUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Message.
     * @param {MessageUpsertArgs} args - Arguments to update or create a Message.
     * @example
     * // Update or create a Message
     * const message = await prisma.message.upsert({
     *   create: {
     *     // ... data to create a Message
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Message we want to update
     *   }
     * })
     */
    upsert<T extends MessageUpsertArgs>(args: SelectSubset<T, MessageUpsertArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Messages that matches the filter.
     * @param {MessageFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const message = await prisma.message.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: MessageFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a Message.
     * @param {MessageAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const message = await prisma.message.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: MessageAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of Messages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageCountArgs} args - Arguments to filter Messages to count.
     * @example
     * // Count the number of Messages
     * const count = await prisma.message.count({
     *   where: {
     *     // ... the filter for the Messages we want to count
     *   }
     * })
    **/
    count<T extends MessageCountArgs>(
      args?: Subset<T, MessageCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MessageCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Message.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MessageAggregateArgs>(args: Subset<T, MessageAggregateArgs>): Prisma.PrismaPromise<GetMessageAggregateType<T>>

    /**
     * Group by Message.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MessageGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MessageGroupByArgs['orderBy'] }
        : { orderBy?: MessageGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MessageGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMessageGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Message model
   */
  readonly fields: MessageFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Message.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MessageClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    chat<T extends ChatDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ChatDefaultArgs<ExtArgs>>): Prisma__ChatClient<$Result.GetResult<Prisma.$ChatPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    user<T extends Message$userArgs<ExtArgs> = {}>(args?: Subset<T, Message$userArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    mechanic<T extends Message$mechanicArgs<ExtArgs> = {}>(args?: Subset<T, Message$mechanicArgs<ExtArgs>>): Prisma__MechanicClient<$Result.GetResult<Prisma.$MechanicPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Message model
   */ 
  interface MessageFieldRefs {
    readonly id: FieldRef<"Message", 'String'>
    readonly chatId: FieldRef<"Message", 'String'>
    readonly senderId: FieldRef<"Message", 'String'>
    readonly senderType: FieldRef<"Message", 'String'>
    readonly content: FieldRef<"Message", 'String'>
    readonly createdAt: FieldRef<"Message", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Message findUnique
   */
  export type MessageFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * Filter, which Message to fetch.
     */
    where: MessageWhereUniqueInput
  }

  /**
   * Message findUniqueOrThrow
   */
  export type MessageFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * Filter, which Message to fetch.
     */
    where: MessageWhereUniqueInput
  }

  /**
   * Message findFirst
   */
  export type MessageFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * Filter, which Message to fetch.
     */
    where?: MessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Messages to fetch.
     */
    orderBy?: MessageOrderByWithRelationInput | MessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Messages.
     */
    cursor?: MessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Messages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Messages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Messages.
     */
    distinct?: MessageScalarFieldEnum | MessageScalarFieldEnum[]
  }

  /**
   * Message findFirstOrThrow
   */
  export type MessageFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * Filter, which Message to fetch.
     */
    where?: MessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Messages to fetch.
     */
    orderBy?: MessageOrderByWithRelationInput | MessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Messages.
     */
    cursor?: MessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Messages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Messages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Messages.
     */
    distinct?: MessageScalarFieldEnum | MessageScalarFieldEnum[]
  }

  /**
   * Message findMany
   */
  export type MessageFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * Filter, which Messages to fetch.
     */
    where?: MessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Messages to fetch.
     */
    orderBy?: MessageOrderByWithRelationInput | MessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Messages.
     */
    cursor?: MessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Messages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Messages.
     */
    skip?: number
    distinct?: MessageScalarFieldEnum | MessageScalarFieldEnum[]
  }

  /**
   * Message create
   */
  export type MessageCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * The data needed to create a Message.
     */
    data: XOR<MessageCreateInput, MessageUncheckedCreateInput>
  }

  /**
   * Message createMany
   */
  export type MessageCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Messages.
     */
    data: MessageCreateManyInput | MessageCreateManyInput[]
  }

  /**
   * Message update
   */
  export type MessageUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * The data needed to update a Message.
     */
    data: XOR<MessageUpdateInput, MessageUncheckedUpdateInput>
    /**
     * Choose, which Message to update.
     */
    where: MessageWhereUniqueInput
  }

  /**
   * Message updateMany
   */
  export type MessageUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Messages.
     */
    data: XOR<MessageUpdateManyMutationInput, MessageUncheckedUpdateManyInput>
    /**
     * Filter which Messages to update
     */
    where?: MessageWhereInput
    /**
     * Limit how many Messages to update.
     */
    limit?: number
  }

  /**
   * Message upsert
   */
  export type MessageUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * The filter to search for the Message to update in case it exists.
     */
    where: MessageWhereUniqueInput
    /**
     * In case the Message found by the `where` argument doesn't exist, create a new Message with this data.
     */
    create: XOR<MessageCreateInput, MessageUncheckedCreateInput>
    /**
     * In case the Message was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MessageUpdateInput, MessageUncheckedUpdateInput>
  }

  /**
   * Message delete
   */
  export type MessageDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * Filter which Message to delete.
     */
    where: MessageWhereUniqueInput
  }

  /**
   * Message deleteMany
   */
  export type MessageDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Messages to delete
     */
    where?: MessageWhereInput
    /**
     * Limit how many Messages to delete.
     */
    limit?: number
  }

  /**
   * Message findRaw
   */
  export type MessageFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * Message aggregateRaw
   */
  export type MessageAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * Message.user
   */
  export type Message$userArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * Message.mechanic
   */
  export type Message$mechanicArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Mechanic
     */
    select?: MechanicSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Mechanic
     */
    omit?: MechanicOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MechanicInclude<ExtArgs> | null
    where?: MechanicWhereInput
  }

  /**
   * Message without action
   */
  export type MessageDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
  }


  /**
   * Model SOS
   */

  export type AggregateSOS = {
    _count: SOSCountAggregateOutputType | null
    _avg: SOSAvgAggregateOutputType | null
    _sum: SOSSumAggregateOutputType | null
    _min: SOSMinAggregateOutputType | null
    _max: SOSMaxAggregateOutputType | null
  }

  export type SOSAvgAggregateOutputType = {
    latitude: number | null
    longitude: number | null
  }

  export type SOSSumAggregateOutputType = {
    latitude: number | null
    longitude: number | null
  }

  export type SOSMinAggregateOutputType = {
    id: string | null
    userId: string | null
    emergencyContactId: string | null
    latitude: number | null
    longitude: number | null
    createdAt: Date | null
    customMessage: string | null
    status: $Enums.SOSStatus | null
  }

  export type SOSMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    emergencyContactId: string | null
    latitude: number | null
    longitude: number | null
    createdAt: Date | null
    customMessage: string | null
    status: $Enums.SOSStatus | null
  }

  export type SOSCountAggregateOutputType = {
    id: number
    userId: number
    emergencyContactId: number
    latitude: number
    longitude: number
    createdAt: number
    customMessage: number
    status: number
    _all: number
  }


  export type SOSAvgAggregateInputType = {
    latitude?: true
    longitude?: true
  }

  export type SOSSumAggregateInputType = {
    latitude?: true
    longitude?: true
  }

  export type SOSMinAggregateInputType = {
    id?: true
    userId?: true
    emergencyContactId?: true
    latitude?: true
    longitude?: true
    createdAt?: true
    customMessage?: true
    status?: true
  }

  export type SOSMaxAggregateInputType = {
    id?: true
    userId?: true
    emergencyContactId?: true
    latitude?: true
    longitude?: true
    createdAt?: true
    customMessage?: true
    status?: true
  }

  export type SOSCountAggregateInputType = {
    id?: true
    userId?: true
    emergencyContactId?: true
    latitude?: true
    longitude?: true
    createdAt?: true
    customMessage?: true
    status?: true
    _all?: true
  }

  export type SOSAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SOS to aggregate.
     */
    where?: SOSWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SOS to fetch.
     */
    orderBy?: SOSOrderByWithRelationInput | SOSOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SOSWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SOS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SOS.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SOS
    **/
    _count?: true | SOSCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SOSAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SOSSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SOSMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SOSMaxAggregateInputType
  }

  export type GetSOSAggregateType<T extends SOSAggregateArgs> = {
        [P in keyof T & keyof AggregateSOS]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSOS[P]>
      : GetScalarType<T[P], AggregateSOS[P]>
  }




  export type SOSGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SOSWhereInput
    orderBy?: SOSOrderByWithAggregationInput | SOSOrderByWithAggregationInput[]
    by: SOSScalarFieldEnum[] | SOSScalarFieldEnum
    having?: SOSScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SOSCountAggregateInputType | true
    _avg?: SOSAvgAggregateInputType
    _sum?: SOSSumAggregateInputType
    _min?: SOSMinAggregateInputType
    _max?: SOSMaxAggregateInputType
  }

  export type SOSGroupByOutputType = {
    id: string
    userId: string
    emergencyContactId: string | null
    latitude: number
    longitude: number
    createdAt: Date
    customMessage: string | null
    status: $Enums.SOSStatus
    _count: SOSCountAggregateOutputType | null
    _avg: SOSAvgAggregateOutputType | null
    _sum: SOSSumAggregateOutputType | null
    _min: SOSMinAggregateOutputType | null
    _max: SOSMaxAggregateOutputType | null
  }

  type GetSOSGroupByPayload<T extends SOSGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SOSGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SOSGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SOSGroupByOutputType[P]>
            : GetScalarType<T[P], SOSGroupByOutputType[P]>
        }
      >
    >


  export type SOSSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    emergencyContactId?: boolean
    latitude?: boolean
    longitude?: boolean
    createdAt?: boolean
    customMessage?: boolean
    status?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    emergencyContact?: boolean | SOS$emergencyContactArgs<ExtArgs>
  }, ExtArgs["result"]["sOS"]>



  export type SOSSelectScalar = {
    id?: boolean
    userId?: boolean
    emergencyContactId?: boolean
    latitude?: boolean
    longitude?: boolean
    createdAt?: boolean
    customMessage?: boolean
    status?: boolean
  }

  export type SOSOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "emergencyContactId" | "latitude" | "longitude" | "createdAt" | "customMessage" | "status", ExtArgs["result"]["sOS"]>
  export type SOSInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    emergencyContact?: boolean | SOS$emergencyContactArgs<ExtArgs>
  }

  export type $SOSPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SOS"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      emergencyContact: Prisma.$EmergencyContactPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      emergencyContactId: string | null
      latitude: number
      longitude: number
      createdAt: Date
      customMessage: string | null
      status: $Enums.SOSStatus
    }, ExtArgs["result"]["sOS"]>
    composites: {}
  }

  type SOSGetPayload<S extends boolean | null | undefined | SOSDefaultArgs> = $Result.GetResult<Prisma.$SOSPayload, S>

  type SOSCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SOSFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SOSCountAggregateInputType | true
    }

  export interface SOSDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SOS'], meta: { name: 'SOS' } }
    /**
     * Find zero or one SOS that matches the filter.
     * @param {SOSFindUniqueArgs} args - Arguments to find a SOS
     * @example
     * // Get one SOS
     * const sOS = await prisma.sOS.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SOSFindUniqueArgs>(args: SelectSubset<T, SOSFindUniqueArgs<ExtArgs>>): Prisma__SOSClient<$Result.GetResult<Prisma.$SOSPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one SOS that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SOSFindUniqueOrThrowArgs} args - Arguments to find a SOS
     * @example
     * // Get one SOS
     * const sOS = await prisma.sOS.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SOSFindUniqueOrThrowArgs>(args: SelectSubset<T, SOSFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SOSClient<$Result.GetResult<Prisma.$SOSPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SOS that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SOSFindFirstArgs} args - Arguments to find a SOS
     * @example
     * // Get one SOS
     * const sOS = await prisma.sOS.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SOSFindFirstArgs>(args?: SelectSubset<T, SOSFindFirstArgs<ExtArgs>>): Prisma__SOSClient<$Result.GetResult<Prisma.$SOSPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SOS that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SOSFindFirstOrThrowArgs} args - Arguments to find a SOS
     * @example
     * // Get one SOS
     * const sOS = await prisma.sOS.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SOSFindFirstOrThrowArgs>(args?: SelectSubset<T, SOSFindFirstOrThrowArgs<ExtArgs>>): Prisma__SOSClient<$Result.GetResult<Prisma.$SOSPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more SOS that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SOSFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SOS
     * const sOS = await prisma.sOS.findMany()
     * 
     * // Get first 10 SOS
     * const sOS = await prisma.sOS.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const sOSWithIdOnly = await prisma.sOS.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SOSFindManyArgs>(args?: SelectSubset<T, SOSFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SOSPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a SOS.
     * @param {SOSCreateArgs} args - Arguments to create a SOS.
     * @example
     * // Create one SOS
     * const SOS = await prisma.sOS.create({
     *   data: {
     *     // ... data to create a SOS
     *   }
     * })
     * 
     */
    create<T extends SOSCreateArgs>(args: SelectSubset<T, SOSCreateArgs<ExtArgs>>): Prisma__SOSClient<$Result.GetResult<Prisma.$SOSPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many SOS.
     * @param {SOSCreateManyArgs} args - Arguments to create many SOS.
     * @example
     * // Create many SOS
     * const sOS = await prisma.sOS.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SOSCreateManyArgs>(args?: SelectSubset<T, SOSCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a SOS.
     * @param {SOSDeleteArgs} args - Arguments to delete one SOS.
     * @example
     * // Delete one SOS
     * const SOS = await prisma.sOS.delete({
     *   where: {
     *     // ... filter to delete one SOS
     *   }
     * })
     * 
     */
    delete<T extends SOSDeleteArgs>(args: SelectSubset<T, SOSDeleteArgs<ExtArgs>>): Prisma__SOSClient<$Result.GetResult<Prisma.$SOSPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one SOS.
     * @param {SOSUpdateArgs} args - Arguments to update one SOS.
     * @example
     * // Update one SOS
     * const sOS = await prisma.sOS.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SOSUpdateArgs>(args: SelectSubset<T, SOSUpdateArgs<ExtArgs>>): Prisma__SOSClient<$Result.GetResult<Prisma.$SOSPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more SOS.
     * @param {SOSDeleteManyArgs} args - Arguments to filter SOS to delete.
     * @example
     * // Delete a few SOS
     * const { count } = await prisma.sOS.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SOSDeleteManyArgs>(args?: SelectSubset<T, SOSDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SOS.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SOSUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SOS
     * const sOS = await prisma.sOS.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SOSUpdateManyArgs>(args: SelectSubset<T, SOSUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one SOS.
     * @param {SOSUpsertArgs} args - Arguments to update or create a SOS.
     * @example
     * // Update or create a SOS
     * const sOS = await prisma.sOS.upsert({
     *   create: {
     *     // ... data to create a SOS
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SOS we want to update
     *   }
     * })
     */
    upsert<T extends SOSUpsertArgs>(args: SelectSubset<T, SOSUpsertArgs<ExtArgs>>): Prisma__SOSClient<$Result.GetResult<Prisma.$SOSPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more SOS that matches the filter.
     * @param {SOSFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const sOS = await prisma.sOS.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: SOSFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a SOS.
     * @param {SOSAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const sOS = await prisma.sOS.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: SOSAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of SOS.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SOSCountArgs} args - Arguments to filter SOS to count.
     * @example
     * // Count the number of SOS
     * const count = await prisma.sOS.count({
     *   where: {
     *     // ... the filter for the SOS we want to count
     *   }
     * })
    **/
    count<T extends SOSCountArgs>(
      args?: Subset<T, SOSCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SOSCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SOS.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SOSAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SOSAggregateArgs>(args: Subset<T, SOSAggregateArgs>): Prisma.PrismaPromise<GetSOSAggregateType<T>>

    /**
     * Group by SOS.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SOSGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SOSGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SOSGroupByArgs['orderBy'] }
        : { orderBy?: SOSGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SOSGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSOSGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SOS model
   */
  readonly fields: SOSFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SOS.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SOSClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    emergencyContact<T extends SOS$emergencyContactArgs<ExtArgs> = {}>(args?: Subset<T, SOS$emergencyContactArgs<ExtArgs>>): Prisma__EmergencyContactClient<$Result.GetResult<Prisma.$EmergencyContactPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SOS model
   */ 
  interface SOSFieldRefs {
    readonly id: FieldRef<"SOS", 'String'>
    readonly userId: FieldRef<"SOS", 'String'>
    readonly emergencyContactId: FieldRef<"SOS", 'String'>
    readonly latitude: FieldRef<"SOS", 'Float'>
    readonly longitude: FieldRef<"SOS", 'Float'>
    readonly createdAt: FieldRef<"SOS", 'DateTime'>
    readonly customMessage: FieldRef<"SOS", 'String'>
    readonly status: FieldRef<"SOS", 'SOSStatus'>
  }
    

  // Custom InputTypes
  /**
   * SOS findUnique
   */
  export type SOSFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SOS
     */
    select?: SOSSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SOS
     */
    omit?: SOSOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SOSInclude<ExtArgs> | null
    /**
     * Filter, which SOS to fetch.
     */
    where: SOSWhereUniqueInput
  }

  /**
   * SOS findUniqueOrThrow
   */
  export type SOSFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SOS
     */
    select?: SOSSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SOS
     */
    omit?: SOSOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SOSInclude<ExtArgs> | null
    /**
     * Filter, which SOS to fetch.
     */
    where: SOSWhereUniqueInput
  }

  /**
   * SOS findFirst
   */
  export type SOSFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SOS
     */
    select?: SOSSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SOS
     */
    omit?: SOSOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SOSInclude<ExtArgs> | null
    /**
     * Filter, which SOS to fetch.
     */
    where?: SOSWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SOS to fetch.
     */
    orderBy?: SOSOrderByWithRelationInput | SOSOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SOS.
     */
    cursor?: SOSWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SOS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SOS.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SOS.
     */
    distinct?: SOSScalarFieldEnum | SOSScalarFieldEnum[]
  }

  /**
   * SOS findFirstOrThrow
   */
  export type SOSFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SOS
     */
    select?: SOSSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SOS
     */
    omit?: SOSOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SOSInclude<ExtArgs> | null
    /**
     * Filter, which SOS to fetch.
     */
    where?: SOSWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SOS to fetch.
     */
    orderBy?: SOSOrderByWithRelationInput | SOSOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SOS.
     */
    cursor?: SOSWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SOS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SOS.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SOS.
     */
    distinct?: SOSScalarFieldEnum | SOSScalarFieldEnum[]
  }

  /**
   * SOS findMany
   */
  export type SOSFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SOS
     */
    select?: SOSSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SOS
     */
    omit?: SOSOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SOSInclude<ExtArgs> | null
    /**
     * Filter, which SOS to fetch.
     */
    where?: SOSWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SOS to fetch.
     */
    orderBy?: SOSOrderByWithRelationInput | SOSOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SOS.
     */
    cursor?: SOSWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SOS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SOS.
     */
    skip?: number
    distinct?: SOSScalarFieldEnum | SOSScalarFieldEnum[]
  }

  /**
   * SOS create
   */
  export type SOSCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SOS
     */
    select?: SOSSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SOS
     */
    omit?: SOSOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SOSInclude<ExtArgs> | null
    /**
     * The data needed to create a SOS.
     */
    data: XOR<SOSCreateInput, SOSUncheckedCreateInput>
  }

  /**
   * SOS createMany
   */
  export type SOSCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SOS.
     */
    data: SOSCreateManyInput | SOSCreateManyInput[]
  }

  /**
   * SOS update
   */
  export type SOSUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SOS
     */
    select?: SOSSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SOS
     */
    omit?: SOSOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SOSInclude<ExtArgs> | null
    /**
     * The data needed to update a SOS.
     */
    data: XOR<SOSUpdateInput, SOSUncheckedUpdateInput>
    /**
     * Choose, which SOS to update.
     */
    where: SOSWhereUniqueInput
  }

  /**
   * SOS updateMany
   */
  export type SOSUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SOS.
     */
    data: XOR<SOSUpdateManyMutationInput, SOSUncheckedUpdateManyInput>
    /**
     * Filter which SOS to update
     */
    where?: SOSWhereInput
    /**
     * Limit how many SOS to update.
     */
    limit?: number
  }

  /**
   * SOS upsert
   */
  export type SOSUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SOS
     */
    select?: SOSSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SOS
     */
    omit?: SOSOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SOSInclude<ExtArgs> | null
    /**
     * The filter to search for the SOS to update in case it exists.
     */
    where: SOSWhereUniqueInput
    /**
     * In case the SOS found by the `where` argument doesn't exist, create a new SOS with this data.
     */
    create: XOR<SOSCreateInput, SOSUncheckedCreateInput>
    /**
     * In case the SOS was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SOSUpdateInput, SOSUncheckedUpdateInput>
  }

  /**
   * SOS delete
   */
  export type SOSDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SOS
     */
    select?: SOSSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SOS
     */
    omit?: SOSOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SOSInclude<ExtArgs> | null
    /**
     * Filter which SOS to delete.
     */
    where: SOSWhereUniqueInput
  }

  /**
   * SOS deleteMany
   */
  export type SOSDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SOS to delete
     */
    where?: SOSWhereInput
    /**
     * Limit how many SOS to delete.
     */
    limit?: number
  }

  /**
   * SOS findRaw
   */
  export type SOSFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * SOS aggregateRaw
   */
  export type SOSAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * SOS.emergencyContact
   */
  export type SOS$emergencyContactArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmergencyContact
     */
    select?: EmergencyContactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmergencyContact
     */
    omit?: EmergencyContactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmergencyContactInclude<ExtArgs> | null
    where?: EmergencyContactWhereInput
  }

  /**
   * SOS without action
   */
  export type SOSDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SOS
     */
    select?: SOSSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SOS
     */
    omit?: SOSOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SOSInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const UserScalarFieldEnum: {
    id: 'id',
    phoneNumber: 'phoneNumber',
    name: 'name',
    email: 'email',
    password: 'password'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const MechanicConfirmationScalarFieldEnum: {
    id: 'id',
    mechanicId: 'mechanicId',
    serviceRequestId: 'serviceRequestId',
    status: 'status',
    distanceText: 'distanceText',
    distanceValue: 'distanceValue',
    durationText: 'durationText',
    durationValue: 'durationValue',
    estimatedCost: 'estimatedCost',
    respondedAt: 'respondedAt',
    createdAt: 'createdAt'
  };

  export type MechanicConfirmationScalarFieldEnum = (typeof MechanicConfirmationScalarFieldEnum)[keyof typeof MechanicConfirmationScalarFieldEnum]


  export const MechanicScalarFieldEnum: {
    id: 'id',
    name: 'name',
    email: 'email',
    phoneNumber: 'phoneNumber',
    services: 'services',
    latitude: 'latitude',
    longitude: 'longitude',
    location: 'location',
    expoToken: 'expoToken'
  };

  export type MechanicScalarFieldEnum = (typeof MechanicScalarFieldEnum)[keyof typeof MechanicScalarFieldEnum]


  export const CarScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    make: 'make',
    model: 'model',
    year: 'year',
    licensePlate: 'licensePlate'
  };

  export type CarScalarFieldEnum = (typeof CarScalarFieldEnum)[keyof typeof CarScalarFieldEnum]


  export const ServiceRequestScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    mechanicId: 'mechanicId',
    serviceType: 'serviceType',
    description: 'description',
    latitude: 'latitude',
    longitude: 'longitude',
    address: 'address',
    status: 'status',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ServiceRequestScalarFieldEnum = (typeof ServiceRequestScalarFieldEnum)[keyof typeof ServiceRequestScalarFieldEnum]


  export const EmergencyContactScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    name: 'name',
    mobileNumber: 'mobileNumber'
  };

  export type EmergencyContactScalarFieldEnum = (typeof EmergencyContactScalarFieldEnum)[keyof typeof EmergencyContactScalarFieldEnum]


  export const ReviewScalarFieldEnum: {
    id: 'id',
    serviceRequestId: 'serviceRequestId',
    reviewerType: 'reviewerType',
    rating: 'rating',
    comment: 'comment',
    createdAt: 'createdAt',
    mechanicId: 'mechanicId'
  };

  export type ReviewScalarFieldEnum = (typeof ReviewScalarFieldEnum)[keyof typeof ReviewScalarFieldEnum]


  export const PaymentScalarFieldEnum: {
    id: 'id',
    serviceRequestId: 'serviceRequestId',
    amount: 'amount',
    status: 'status',
    razorpayOrderId: 'razorpayOrderId',
    razorpayPaymentId: 'razorpayPaymentId',
    razorpaySignature: 'razorpaySignature',
    comment: 'comment',
    createdAt: 'createdAt'
  };

  export type PaymentScalarFieldEnum = (typeof PaymentScalarFieldEnum)[keyof typeof PaymentScalarFieldEnum]


  export const ChatScalarFieldEnum: {
    id: 'id',
    serviceRequestId: 'serviceRequestId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ChatScalarFieldEnum = (typeof ChatScalarFieldEnum)[keyof typeof ChatScalarFieldEnum]


  export const MessageScalarFieldEnum: {
    id: 'id',
    chatId: 'chatId',
    senderId: 'senderId',
    senderType: 'senderType',
    content: 'content',
    createdAt: 'createdAt'
  };

  export type MessageScalarFieldEnum = (typeof MessageScalarFieldEnum)[keyof typeof MessageScalarFieldEnum]


  export const SOSScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    emergencyContactId: 'emergencyContactId',
    latitude: 'latitude',
    longitude: 'longitude',
    createdAt: 'createdAt',
    customMessage: 'customMessage',
    status: 'status'
  };

  export type SOSScalarFieldEnum = (typeof SOSScalarFieldEnum)[keyof typeof SOSScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  /**
   * Field references 
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'ConfirmationStatus'
   */
  export type EnumConfirmationStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ConfirmationStatus'>
    


  /**
   * Reference to a field of type 'ConfirmationStatus[]'
   */
  export type ListEnumConfirmationStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ConfirmationStatus[]'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'ServiceType[]'
   */
  export type ListEnumServiceTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ServiceType[]'>
    


  /**
   * Reference to a field of type 'ServiceType'
   */
  export type EnumServiceTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ServiceType'>
    


  /**
   * Reference to a field of type 'Json'
   */
  export type JsonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Json'>
    


  /**
   * Reference to a field of type 'ServiceStatus'
   */
  export type EnumServiceStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ServiceStatus'>
    


  /**
   * Reference to a field of type 'ServiceStatus[]'
   */
  export type ListEnumServiceStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ServiceStatus[]'>
    


  /**
   * Reference to a field of type 'SenderType'
   */
  export type EnumSenderTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SenderType'>
    


  /**
   * Reference to a field of type 'SenderType[]'
   */
  export type ListEnumSenderTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SenderType[]'>
    


  /**
   * Reference to a field of type 'PaymentStatus'
   */
  export type EnumPaymentStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PaymentStatus'>
    


  /**
   * Reference to a field of type 'PaymentStatus[]'
   */
  export type ListEnumPaymentStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PaymentStatus[]'>
    


  /**
   * Reference to a field of type 'SOSStatus'
   */
  export type EnumSOSStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SOSStatus'>
    


  /**
   * Reference to a field of type 'SOSStatus[]'
   */
  export type ListEnumSOSStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SOSStatus[]'>
    
  /**
   * Deep Input Types
   */


  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: StringFilter<"User"> | string
    phoneNumber?: StringFilter<"User"> | string
    name?: StringNullableFilter<"User"> | string | null
    email?: StringNullableFilter<"User"> | string | null
    password?: StringNullableFilter<"User"> | string | null
    cars?: CarListRelationFilter
    serviceRequests?: ServiceRequestListRelationFilter
    emergencyContacts?: EmergencyContactListRelationFilter
    sentMessages?: MessageListRelationFilter
    sosEvents?: SOSListRelationFilter
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    phoneNumber?: SortOrder
    name?: SortOrder
    email?: SortOrder
    password?: SortOrder
    cars?: CarOrderByRelationAggregateInput
    serviceRequests?: ServiceRequestOrderByRelationAggregateInput
    emergencyContacts?: EmergencyContactOrderByRelationAggregateInput
    sentMessages?: MessageOrderByRelationAggregateInput
    sosEvents?: SOSOrderByRelationAggregateInput
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    phoneNumber?: string
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    name?: StringNullableFilter<"User"> | string | null
    email?: StringNullableFilter<"User"> | string | null
    password?: StringNullableFilter<"User"> | string | null
    cars?: CarListRelationFilter
    serviceRequests?: ServiceRequestListRelationFilter
    emergencyContacts?: EmergencyContactListRelationFilter
    sentMessages?: MessageListRelationFilter
    sosEvents?: SOSListRelationFilter
  }, "id" | "phoneNumber">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    phoneNumber?: SortOrder
    name?: SortOrder
    email?: SortOrder
    password?: SortOrder
    _count?: UserCountOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"User"> | string
    phoneNumber?: StringWithAggregatesFilter<"User"> | string
    name?: StringNullableWithAggregatesFilter<"User"> | string | null
    email?: StringNullableWithAggregatesFilter<"User"> | string | null
    password?: StringNullableWithAggregatesFilter<"User"> | string | null
  }

  export type MechanicConfirmationWhereInput = {
    AND?: MechanicConfirmationWhereInput | MechanicConfirmationWhereInput[]
    OR?: MechanicConfirmationWhereInput[]
    NOT?: MechanicConfirmationWhereInput | MechanicConfirmationWhereInput[]
    id?: StringFilter<"MechanicConfirmation"> | string
    mechanicId?: StringFilter<"MechanicConfirmation"> | string
    serviceRequestId?: StringFilter<"MechanicConfirmation"> | string
    status?: EnumConfirmationStatusFilter<"MechanicConfirmation"> | $Enums.ConfirmationStatus
    distanceText?: StringFilter<"MechanicConfirmation"> | string
    distanceValue?: IntFilter<"MechanicConfirmation"> | number
    durationText?: StringFilter<"MechanicConfirmation"> | string
    durationValue?: IntFilter<"MechanicConfirmation"> | number
    estimatedCost?: FloatFilter<"MechanicConfirmation"> | number
    respondedAt?: DateTimeNullableFilter<"MechanicConfirmation"> | Date | string | null
    createdAt?: DateTimeFilter<"MechanicConfirmation"> | Date | string
    mechanic?: XOR<MechanicScalarRelationFilter, MechanicWhereInput>
    serviceRequest?: XOR<ServiceRequestScalarRelationFilter, ServiceRequestWhereInput>
  }

  export type MechanicConfirmationOrderByWithRelationInput = {
    id?: SortOrder
    mechanicId?: SortOrder
    serviceRequestId?: SortOrder
    status?: SortOrder
    distanceText?: SortOrder
    distanceValue?: SortOrder
    durationText?: SortOrder
    durationValue?: SortOrder
    estimatedCost?: SortOrder
    respondedAt?: SortOrder
    createdAt?: SortOrder
    mechanic?: MechanicOrderByWithRelationInput
    serviceRequest?: ServiceRequestOrderByWithRelationInput
  }

  export type MechanicConfirmationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: MechanicConfirmationWhereInput | MechanicConfirmationWhereInput[]
    OR?: MechanicConfirmationWhereInput[]
    NOT?: MechanicConfirmationWhereInput | MechanicConfirmationWhereInput[]
    mechanicId?: StringFilter<"MechanicConfirmation"> | string
    serviceRequestId?: StringFilter<"MechanicConfirmation"> | string
    status?: EnumConfirmationStatusFilter<"MechanicConfirmation"> | $Enums.ConfirmationStatus
    distanceText?: StringFilter<"MechanicConfirmation"> | string
    distanceValue?: IntFilter<"MechanicConfirmation"> | number
    durationText?: StringFilter<"MechanicConfirmation"> | string
    durationValue?: IntFilter<"MechanicConfirmation"> | number
    estimatedCost?: FloatFilter<"MechanicConfirmation"> | number
    respondedAt?: DateTimeNullableFilter<"MechanicConfirmation"> | Date | string | null
    createdAt?: DateTimeFilter<"MechanicConfirmation"> | Date | string
    mechanic?: XOR<MechanicScalarRelationFilter, MechanicWhereInput>
    serviceRequest?: XOR<ServiceRequestScalarRelationFilter, ServiceRequestWhereInput>
  }, "id">

  export type MechanicConfirmationOrderByWithAggregationInput = {
    id?: SortOrder
    mechanicId?: SortOrder
    serviceRequestId?: SortOrder
    status?: SortOrder
    distanceText?: SortOrder
    distanceValue?: SortOrder
    durationText?: SortOrder
    durationValue?: SortOrder
    estimatedCost?: SortOrder
    respondedAt?: SortOrder
    createdAt?: SortOrder
    _count?: MechanicConfirmationCountOrderByAggregateInput
    _avg?: MechanicConfirmationAvgOrderByAggregateInput
    _max?: MechanicConfirmationMaxOrderByAggregateInput
    _min?: MechanicConfirmationMinOrderByAggregateInput
    _sum?: MechanicConfirmationSumOrderByAggregateInput
  }

  export type MechanicConfirmationScalarWhereWithAggregatesInput = {
    AND?: MechanicConfirmationScalarWhereWithAggregatesInput | MechanicConfirmationScalarWhereWithAggregatesInput[]
    OR?: MechanicConfirmationScalarWhereWithAggregatesInput[]
    NOT?: MechanicConfirmationScalarWhereWithAggregatesInput | MechanicConfirmationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"MechanicConfirmation"> | string
    mechanicId?: StringWithAggregatesFilter<"MechanicConfirmation"> | string
    serviceRequestId?: StringWithAggregatesFilter<"MechanicConfirmation"> | string
    status?: EnumConfirmationStatusWithAggregatesFilter<"MechanicConfirmation"> | $Enums.ConfirmationStatus
    distanceText?: StringWithAggregatesFilter<"MechanicConfirmation"> | string
    distanceValue?: IntWithAggregatesFilter<"MechanicConfirmation"> | number
    durationText?: StringWithAggregatesFilter<"MechanicConfirmation"> | string
    durationValue?: IntWithAggregatesFilter<"MechanicConfirmation"> | number
    estimatedCost?: FloatWithAggregatesFilter<"MechanicConfirmation"> | number
    respondedAt?: DateTimeNullableWithAggregatesFilter<"MechanicConfirmation"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"MechanicConfirmation"> | Date | string
  }

  export type MechanicWhereInput = {
    AND?: MechanicWhereInput | MechanicWhereInput[]
    OR?: MechanicWhereInput[]
    NOT?: MechanicWhereInput | MechanicWhereInput[]
    id?: StringFilter<"Mechanic"> | string
    name?: StringNullableFilter<"Mechanic"> | string | null
    email?: StringNullableFilter<"Mechanic"> | string | null
    phoneNumber?: StringFilter<"Mechanic"> | string
    services?: EnumServiceTypeNullableListFilter<"Mechanic">
    latitude?: FloatNullableFilter<"Mechanic"> | number | null
    longitude?: FloatNullableFilter<"Mechanic"> | number | null
    location?: JsonNullableFilter<"Mechanic">
    expoToken?: StringNullableFilter<"Mechanic"> | string | null
    serviceRequests?: ServiceRequestListRelationFilter
    reviews?: ReviewListRelationFilter
    sentMessages?: MessageListRelationFilter
    MechanicConfirmation?: MechanicConfirmationListRelationFilter
  }

  export type MechanicOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    phoneNumber?: SortOrder
    services?: SortOrder
    latitude?: SortOrder
    longitude?: SortOrder
    location?: SortOrder
    expoToken?: SortOrder
    serviceRequests?: ServiceRequestOrderByRelationAggregateInput
    reviews?: ReviewOrderByRelationAggregateInput
    sentMessages?: MessageOrderByRelationAggregateInput
    MechanicConfirmation?: MechanicConfirmationOrderByRelationAggregateInput
  }

  export type MechanicWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    email?: string
    phoneNumber?: string
    AND?: MechanicWhereInput | MechanicWhereInput[]
    OR?: MechanicWhereInput[]
    NOT?: MechanicWhereInput | MechanicWhereInput[]
    name?: StringNullableFilter<"Mechanic"> | string | null
    services?: EnumServiceTypeNullableListFilter<"Mechanic">
    latitude?: FloatNullableFilter<"Mechanic"> | number | null
    longitude?: FloatNullableFilter<"Mechanic"> | number | null
    location?: JsonNullableFilter<"Mechanic">
    expoToken?: StringNullableFilter<"Mechanic"> | string | null
    serviceRequests?: ServiceRequestListRelationFilter
    reviews?: ReviewListRelationFilter
    sentMessages?: MessageListRelationFilter
    MechanicConfirmation?: MechanicConfirmationListRelationFilter
  }, "id" | "email" | "phoneNumber">

  export type MechanicOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    phoneNumber?: SortOrder
    services?: SortOrder
    latitude?: SortOrder
    longitude?: SortOrder
    location?: SortOrder
    expoToken?: SortOrder
    _count?: MechanicCountOrderByAggregateInput
    _avg?: MechanicAvgOrderByAggregateInput
    _max?: MechanicMaxOrderByAggregateInput
    _min?: MechanicMinOrderByAggregateInput
    _sum?: MechanicSumOrderByAggregateInput
  }

  export type MechanicScalarWhereWithAggregatesInput = {
    AND?: MechanicScalarWhereWithAggregatesInput | MechanicScalarWhereWithAggregatesInput[]
    OR?: MechanicScalarWhereWithAggregatesInput[]
    NOT?: MechanicScalarWhereWithAggregatesInput | MechanicScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Mechanic"> | string
    name?: StringNullableWithAggregatesFilter<"Mechanic"> | string | null
    email?: StringNullableWithAggregatesFilter<"Mechanic"> | string | null
    phoneNumber?: StringWithAggregatesFilter<"Mechanic"> | string
    services?: EnumServiceTypeNullableListFilter<"Mechanic">
    latitude?: FloatNullableWithAggregatesFilter<"Mechanic"> | number | null
    longitude?: FloatNullableWithAggregatesFilter<"Mechanic"> | number | null
    location?: JsonNullableWithAggregatesFilter<"Mechanic">
    expoToken?: StringNullableWithAggregatesFilter<"Mechanic"> | string | null
  }

  export type CarWhereInput = {
    AND?: CarWhereInput | CarWhereInput[]
    OR?: CarWhereInput[]
    NOT?: CarWhereInput | CarWhereInput[]
    id?: StringFilter<"Car"> | string
    userId?: StringFilter<"Car"> | string
    make?: StringFilter<"Car"> | string
    model?: StringFilter<"Car"> | string
    year?: IntFilter<"Car"> | number
    licensePlate?: StringFilter<"Car"> | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type CarOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    make?: SortOrder
    model?: SortOrder
    year?: SortOrder
    licensePlate?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type CarWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: CarWhereInput | CarWhereInput[]
    OR?: CarWhereInput[]
    NOT?: CarWhereInput | CarWhereInput[]
    userId?: StringFilter<"Car"> | string
    make?: StringFilter<"Car"> | string
    model?: StringFilter<"Car"> | string
    year?: IntFilter<"Car"> | number
    licensePlate?: StringFilter<"Car"> | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type CarOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    make?: SortOrder
    model?: SortOrder
    year?: SortOrder
    licensePlate?: SortOrder
    _count?: CarCountOrderByAggregateInput
    _avg?: CarAvgOrderByAggregateInput
    _max?: CarMaxOrderByAggregateInput
    _min?: CarMinOrderByAggregateInput
    _sum?: CarSumOrderByAggregateInput
  }

  export type CarScalarWhereWithAggregatesInput = {
    AND?: CarScalarWhereWithAggregatesInput | CarScalarWhereWithAggregatesInput[]
    OR?: CarScalarWhereWithAggregatesInput[]
    NOT?: CarScalarWhereWithAggregatesInput | CarScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Car"> | string
    userId?: StringWithAggregatesFilter<"Car"> | string
    make?: StringWithAggregatesFilter<"Car"> | string
    model?: StringWithAggregatesFilter<"Car"> | string
    year?: IntWithAggregatesFilter<"Car"> | number
    licensePlate?: StringWithAggregatesFilter<"Car"> | string
  }

  export type ServiceRequestWhereInput = {
    AND?: ServiceRequestWhereInput | ServiceRequestWhereInput[]
    OR?: ServiceRequestWhereInput[]
    NOT?: ServiceRequestWhereInput | ServiceRequestWhereInput[]
    id?: StringFilter<"ServiceRequest"> | string
    userId?: StringFilter<"ServiceRequest"> | string
    mechanicId?: StringNullableFilter<"ServiceRequest"> | string | null
    serviceType?: EnumServiceTypeFilter<"ServiceRequest"> | $Enums.ServiceType
    description?: StringNullableFilter<"ServiceRequest"> | string | null
    latitude?: FloatFilter<"ServiceRequest"> | number
    longitude?: FloatFilter<"ServiceRequest"> | number
    address?: StringNullableFilter<"ServiceRequest"> | string | null
    status?: EnumServiceStatusFilter<"ServiceRequest"> | $Enums.ServiceStatus
    createdAt?: DateTimeFilter<"ServiceRequest"> | Date | string
    updatedAt?: DateTimeFilter<"ServiceRequest"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    mechanic?: XOR<MechanicNullableScalarRelationFilter, MechanicWhereInput> | null
    payment?: XOR<PaymentNullableScalarRelationFilter, PaymentWhereInput> | null
    chat?: XOR<ChatNullableScalarRelationFilter, ChatWhereInput> | null
    confirmations?: MechanicConfirmationListRelationFilter
    reviews?: ReviewListRelationFilter
  }

  export type ServiceRequestOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    mechanicId?: SortOrder
    serviceType?: SortOrder
    description?: SortOrder
    latitude?: SortOrder
    longitude?: SortOrder
    address?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
    mechanic?: MechanicOrderByWithRelationInput
    payment?: PaymentOrderByWithRelationInput
    chat?: ChatOrderByWithRelationInput
    confirmations?: MechanicConfirmationOrderByRelationAggregateInput
    reviews?: ReviewOrderByRelationAggregateInput
  }

  export type ServiceRequestWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ServiceRequestWhereInput | ServiceRequestWhereInput[]
    OR?: ServiceRequestWhereInput[]
    NOT?: ServiceRequestWhereInput | ServiceRequestWhereInput[]
    userId?: StringFilter<"ServiceRequest"> | string
    mechanicId?: StringNullableFilter<"ServiceRequest"> | string | null
    serviceType?: EnumServiceTypeFilter<"ServiceRequest"> | $Enums.ServiceType
    description?: StringNullableFilter<"ServiceRequest"> | string | null
    latitude?: FloatFilter<"ServiceRequest"> | number
    longitude?: FloatFilter<"ServiceRequest"> | number
    address?: StringNullableFilter<"ServiceRequest"> | string | null
    status?: EnumServiceStatusFilter<"ServiceRequest"> | $Enums.ServiceStatus
    createdAt?: DateTimeFilter<"ServiceRequest"> | Date | string
    updatedAt?: DateTimeFilter<"ServiceRequest"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    mechanic?: XOR<MechanicNullableScalarRelationFilter, MechanicWhereInput> | null
    payment?: XOR<PaymentNullableScalarRelationFilter, PaymentWhereInput> | null
    chat?: XOR<ChatNullableScalarRelationFilter, ChatWhereInput> | null
    confirmations?: MechanicConfirmationListRelationFilter
    reviews?: ReviewListRelationFilter
  }, "id">

  export type ServiceRequestOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    mechanicId?: SortOrder
    serviceType?: SortOrder
    description?: SortOrder
    latitude?: SortOrder
    longitude?: SortOrder
    address?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ServiceRequestCountOrderByAggregateInput
    _avg?: ServiceRequestAvgOrderByAggregateInput
    _max?: ServiceRequestMaxOrderByAggregateInput
    _min?: ServiceRequestMinOrderByAggregateInput
    _sum?: ServiceRequestSumOrderByAggregateInput
  }

  export type ServiceRequestScalarWhereWithAggregatesInput = {
    AND?: ServiceRequestScalarWhereWithAggregatesInput | ServiceRequestScalarWhereWithAggregatesInput[]
    OR?: ServiceRequestScalarWhereWithAggregatesInput[]
    NOT?: ServiceRequestScalarWhereWithAggregatesInput | ServiceRequestScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ServiceRequest"> | string
    userId?: StringWithAggregatesFilter<"ServiceRequest"> | string
    mechanicId?: StringNullableWithAggregatesFilter<"ServiceRequest"> | string | null
    serviceType?: EnumServiceTypeWithAggregatesFilter<"ServiceRequest"> | $Enums.ServiceType
    description?: StringNullableWithAggregatesFilter<"ServiceRequest"> | string | null
    latitude?: FloatWithAggregatesFilter<"ServiceRequest"> | number
    longitude?: FloatWithAggregatesFilter<"ServiceRequest"> | number
    address?: StringNullableWithAggregatesFilter<"ServiceRequest"> | string | null
    status?: EnumServiceStatusWithAggregatesFilter<"ServiceRequest"> | $Enums.ServiceStatus
    createdAt?: DateTimeWithAggregatesFilter<"ServiceRequest"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ServiceRequest"> | Date | string
  }

  export type EmergencyContactWhereInput = {
    AND?: EmergencyContactWhereInput | EmergencyContactWhereInput[]
    OR?: EmergencyContactWhereInput[]
    NOT?: EmergencyContactWhereInput | EmergencyContactWhereInput[]
    id?: StringFilter<"EmergencyContact"> | string
    userId?: StringFilter<"EmergencyContact"> | string
    name?: StringFilter<"EmergencyContact"> | string
    mobileNumber?: StringFilter<"EmergencyContact"> | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    sosEvents?: SOSListRelationFilter
  }

  export type EmergencyContactOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    name?: SortOrder
    mobileNumber?: SortOrder
    user?: UserOrderByWithRelationInput
    sosEvents?: SOSOrderByRelationAggregateInput
  }

  export type EmergencyContactWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: EmergencyContactWhereInput | EmergencyContactWhereInput[]
    OR?: EmergencyContactWhereInput[]
    NOT?: EmergencyContactWhereInput | EmergencyContactWhereInput[]
    userId?: StringFilter<"EmergencyContact"> | string
    name?: StringFilter<"EmergencyContact"> | string
    mobileNumber?: StringFilter<"EmergencyContact"> | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    sosEvents?: SOSListRelationFilter
  }, "id">

  export type EmergencyContactOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    name?: SortOrder
    mobileNumber?: SortOrder
    _count?: EmergencyContactCountOrderByAggregateInput
    _max?: EmergencyContactMaxOrderByAggregateInput
    _min?: EmergencyContactMinOrderByAggregateInput
  }

  export type EmergencyContactScalarWhereWithAggregatesInput = {
    AND?: EmergencyContactScalarWhereWithAggregatesInput | EmergencyContactScalarWhereWithAggregatesInput[]
    OR?: EmergencyContactScalarWhereWithAggregatesInput[]
    NOT?: EmergencyContactScalarWhereWithAggregatesInput | EmergencyContactScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"EmergencyContact"> | string
    userId?: StringWithAggregatesFilter<"EmergencyContact"> | string
    name?: StringWithAggregatesFilter<"EmergencyContact"> | string
    mobileNumber?: StringWithAggregatesFilter<"EmergencyContact"> | string
  }

  export type ReviewWhereInput = {
    AND?: ReviewWhereInput | ReviewWhereInput[]
    OR?: ReviewWhereInput[]
    NOT?: ReviewWhereInput | ReviewWhereInput[]
    id?: StringFilter<"Review"> | string
    serviceRequestId?: StringFilter<"Review"> | string
    reviewerType?: EnumSenderTypeFilter<"Review"> | $Enums.SenderType
    rating?: IntFilter<"Review"> | number
    comment?: StringNullableFilter<"Review"> | string | null
    createdAt?: DateTimeFilter<"Review"> | Date | string
    mechanicId?: StringNullableFilter<"Review"> | string | null
    serviceRequest?: XOR<ServiceRequestScalarRelationFilter, ServiceRequestWhereInput>
    Mechanic?: XOR<MechanicNullableScalarRelationFilter, MechanicWhereInput> | null
  }

  export type ReviewOrderByWithRelationInput = {
    id?: SortOrder
    serviceRequestId?: SortOrder
    reviewerType?: SortOrder
    rating?: SortOrder
    comment?: SortOrder
    createdAt?: SortOrder
    mechanicId?: SortOrder
    serviceRequest?: ServiceRequestOrderByWithRelationInput
    Mechanic?: MechanicOrderByWithRelationInput
  }

  export type ReviewWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ReviewWhereInput | ReviewWhereInput[]
    OR?: ReviewWhereInput[]
    NOT?: ReviewWhereInput | ReviewWhereInput[]
    serviceRequestId?: StringFilter<"Review"> | string
    reviewerType?: EnumSenderTypeFilter<"Review"> | $Enums.SenderType
    rating?: IntFilter<"Review"> | number
    comment?: StringNullableFilter<"Review"> | string | null
    createdAt?: DateTimeFilter<"Review"> | Date | string
    mechanicId?: StringNullableFilter<"Review"> | string | null
    serviceRequest?: XOR<ServiceRequestScalarRelationFilter, ServiceRequestWhereInput>
    Mechanic?: XOR<MechanicNullableScalarRelationFilter, MechanicWhereInput> | null
  }, "id">

  export type ReviewOrderByWithAggregationInput = {
    id?: SortOrder
    serviceRequestId?: SortOrder
    reviewerType?: SortOrder
    rating?: SortOrder
    comment?: SortOrder
    createdAt?: SortOrder
    mechanicId?: SortOrder
    _count?: ReviewCountOrderByAggregateInput
    _avg?: ReviewAvgOrderByAggregateInput
    _max?: ReviewMaxOrderByAggregateInput
    _min?: ReviewMinOrderByAggregateInput
    _sum?: ReviewSumOrderByAggregateInput
  }

  export type ReviewScalarWhereWithAggregatesInput = {
    AND?: ReviewScalarWhereWithAggregatesInput | ReviewScalarWhereWithAggregatesInput[]
    OR?: ReviewScalarWhereWithAggregatesInput[]
    NOT?: ReviewScalarWhereWithAggregatesInput | ReviewScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Review"> | string
    serviceRequestId?: StringWithAggregatesFilter<"Review"> | string
    reviewerType?: EnumSenderTypeWithAggregatesFilter<"Review"> | $Enums.SenderType
    rating?: IntWithAggregatesFilter<"Review"> | number
    comment?: StringNullableWithAggregatesFilter<"Review"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Review"> | Date | string
    mechanicId?: StringNullableWithAggregatesFilter<"Review"> | string | null
  }

  export type PaymentWhereInput = {
    AND?: PaymentWhereInput | PaymentWhereInput[]
    OR?: PaymentWhereInput[]
    NOT?: PaymentWhereInput | PaymentWhereInput[]
    id?: StringFilter<"Payment"> | string
    serviceRequestId?: StringFilter<"Payment"> | string
    amount?: FloatFilter<"Payment"> | number
    status?: EnumPaymentStatusFilter<"Payment"> | $Enums.PaymentStatus
    razorpayOrderId?: StringNullableFilter<"Payment"> | string | null
    razorpayPaymentId?: StringNullableFilter<"Payment"> | string | null
    razorpaySignature?: StringNullableFilter<"Payment"> | string | null
    comment?: StringNullableFilter<"Payment"> | string | null
    createdAt?: DateTimeFilter<"Payment"> | Date | string
    serviceRequest?: XOR<ServiceRequestScalarRelationFilter, ServiceRequestWhereInput>
  }

  export type PaymentOrderByWithRelationInput = {
    id?: SortOrder
    serviceRequestId?: SortOrder
    amount?: SortOrder
    status?: SortOrder
    razorpayOrderId?: SortOrder
    razorpayPaymentId?: SortOrder
    razorpaySignature?: SortOrder
    comment?: SortOrder
    createdAt?: SortOrder
    serviceRequest?: ServiceRequestOrderByWithRelationInput
  }

  export type PaymentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    serviceRequestId?: string
    AND?: PaymentWhereInput | PaymentWhereInput[]
    OR?: PaymentWhereInput[]
    NOT?: PaymentWhereInput | PaymentWhereInput[]
    amount?: FloatFilter<"Payment"> | number
    status?: EnumPaymentStatusFilter<"Payment"> | $Enums.PaymentStatus
    razorpayOrderId?: StringNullableFilter<"Payment"> | string | null
    razorpayPaymentId?: StringNullableFilter<"Payment"> | string | null
    razorpaySignature?: StringNullableFilter<"Payment"> | string | null
    comment?: StringNullableFilter<"Payment"> | string | null
    createdAt?: DateTimeFilter<"Payment"> | Date | string
    serviceRequest?: XOR<ServiceRequestScalarRelationFilter, ServiceRequestWhereInput>
  }, "id" | "serviceRequestId">

  export type PaymentOrderByWithAggregationInput = {
    id?: SortOrder
    serviceRequestId?: SortOrder
    amount?: SortOrder
    status?: SortOrder
    razorpayOrderId?: SortOrder
    razorpayPaymentId?: SortOrder
    razorpaySignature?: SortOrder
    comment?: SortOrder
    createdAt?: SortOrder
    _count?: PaymentCountOrderByAggregateInput
    _avg?: PaymentAvgOrderByAggregateInput
    _max?: PaymentMaxOrderByAggregateInput
    _min?: PaymentMinOrderByAggregateInput
    _sum?: PaymentSumOrderByAggregateInput
  }

  export type PaymentScalarWhereWithAggregatesInput = {
    AND?: PaymentScalarWhereWithAggregatesInput | PaymentScalarWhereWithAggregatesInput[]
    OR?: PaymentScalarWhereWithAggregatesInput[]
    NOT?: PaymentScalarWhereWithAggregatesInput | PaymentScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Payment"> | string
    serviceRequestId?: StringWithAggregatesFilter<"Payment"> | string
    amount?: FloatWithAggregatesFilter<"Payment"> | number
    status?: EnumPaymentStatusWithAggregatesFilter<"Payment"> | $Enums.PaymentStatus
    razorpayOrderId?: StringNullableWithAggregatesFilter<"Payment"> | string | null
    razorpayPaymentId?: StringNullableWithAggregatesFilter<"Payment"> | string | null
    razorpaySignature?: StringNullableWithAggregatesFilter<"Payment"> | string | null
    comment?: StringNullableWithAggregatesFilter<"Payment"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Payment"> | Date | string
  }

  export type ChatWhereInput = {
    AND?: ChatWhereInput | ChatWhereInput[]
    OR?: ChatWhereInput[]
    NOT?: ChatWhereInput | ChatWhereInput[]
    id?: StringFilter<"Chat"> | string
    serviceRequestId?: StringFilter<"Chat"> | string
    createdAt?: DateTimeFilter<"Chat"> | Date | string
    updatedAt?: DateTimeFilter<"Chat"> | Date | string
    serviceRequest?: XOR<ServiceRequestScalarRelationFilter, ServiceRequestWhereInput>
    messages?: MessageListRelationFilter
  }

  export type ChatOrderByWithRelationInput = {
    id?: SortOrder
    serviceRequestId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    serviceRequest?: ServiceRequestOrderByWithRelationInput
    messages?: MessageOrderByRelationAggregateInput
  }

  export type ChatWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    serviceRequestId?: string
    AND?: ChatWhereInput | ChatWhereInput[]
    OR?: ChatWhereInput[]
    NOT?: ChatWhereInput | ChatWhereInput[]
    createdAt?: DateTimeFilter<"Chat"> | Date | string
    updatedAt?: DateTimeFilter<"Chat"> | Date | string
    serviceRequest?: XOR<ServiceRequestScalarRelationFilter, ServiceRequestWhereInput>
    messages?: MessageListRelationFilter
  }, "id" | "serviceRequestId">

  export type ChatOrderByWithAggregationInput = {
    id?: SortOrder
    serviceRequestId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ChatCountOrderByAggregateInput
    _max?: ChatMaxOrderByAggregateInput
    _min?: ChatMinOrderByAggregateInput
  }

  export type ChatScalarWhereWithAggregatesInput = {
    AND?: ChatScalarWhereWithAggregatesInput | ChatScalarWhereWithAggregatesInput[]
    OR?: ChatScalarWhereWithAggregatesInput[]
    NOT?: ChatScalarWhereWithAggregatesInput | ChatScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Chat"> | string
    serviceRequestId?: StringWithAggregatesFilter<"Chat"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Chat"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Chat"> | Date | string
  }

  export type MessageWhereInput = {
    AND?: MessageWhereInput | MessageWhereInput[]
    OR?: MessageWhereInput[]
    NOT?: MessageWhereInput | MessageWhereInput[]
    id?: StringFilter<"Message"> | string
    chatId?: StringFilter<"Message"> | string
    senderId?: StringNullableFilter<"Message"> | string | null
    senderType?: StringFilter<"Message"> | string
    content?: StringFilter<"Message"> | string
    createdAt?: DateTimeFilter<"Message"> | Date | string
    chat?: XOR<ChatScalarRelationFilter, ChatWhereInput>
    user?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    mechanic?: XOR<MechanicNullableScalarRelationFilter, MechanicWhereInput> | null
  }

  export type MessageOrderByWithRelationInput = {
    id?: SortOrder
    chatId?: SortOrder
    senderId?: SortOrder
    senderType?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
    chat?: ChatOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
    mechanic?: MechanicOrderByWithRelationInput
  }

  export type MessageWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: MessageWhereInput | MessageWhereInput[]
    OR?: MessageWhereInput[]
    NOT?: MessageWhereInput | MessageWhereInput[]
    chatId?: StringFilter<"Message"> | string
    senderId?: StringNullableFilter<"Message"> | string | null
    senderType?: StringFilter<"Message"> | string
    content?: StringFilter<"Message"> | string
    createdAt?: DateTimeFilter<"Message"> | Date | string
    chat?: XOR<ChatScalarRelationFilter, ChatWhereInput>
    user?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    mechanic?: XOR<MechanicNullableScalarRelationFilter, MechanicWhereInput> | null
  }, "id">

  export type MessageOrderByWithAggregationInput = {
    id?: SortOrder
    chatId?: SortOrder
    senderId?: SortOrder
    senderType?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
    _count?: MessageCountOrderByAggregateInput
    _max?: MessageMaxOrderByAggregateInput
    _min?: MessageMinOrderByAggregateInput
  }

  export type MessageScalarWhereWithAggregatesInput = {
    AND?: MessageScalarWhereWithAggregatesInput | MessageScalarWhereWithAggregatesInput[]
    OR?: MessageScalarWhereWithAggregatesInput[]
    NOT?: MessageScalarWhereWithAggregatesInput | MessageScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Message"> | string
    chatId?: StringWithAggregatesFilter<"Message"> | string
    senderId?: StringNullableWithAggregatesFilter<"Message"> | string | null
    senderType?: StringWithAggregatesFilter<"Message"> | string
    content?: StringWithAggregatesFilter<"Message"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Message"> | Date | string
  }

  export type SOSWhereInput = {
    AND?: SOSWhereInput | SOSWhereInput[]
    OR?: SOSWhereInput[]
    NOT?: SOSWhereInput | SOSWhereInput[]
    id?: StringFilter<"SOS"> | string
    userId?: StringFilter<"SOS"> | string
    emergencyContactId?: StringNullableFilter<"SOS"> | string | null
    latitude?: FloatFilter<"SOS"> | number
    longitude?: FloatFilter<"SOS"> | number
    createdAt?: DateTimeFilter<"SOS"> | Date | string
    customMessage?: StringNullableFilter<"SOS"> | string | null
    status?: EnumSOSStatusFilter<"SOS"> | $Enums.SOSStatus
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    emergencyContact?: XOR<EmergencyContactNullableScalarRelationFilter, EmergencyContactWhereInput> | null
  }

  export type SOSOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    emergencyContactId?: SortOrder
    latitude?: SortOrder
    longitude?: SortOrder
    createdAt?: SortOrder
    customMessage?: SortOrder
    status?: SortOrder
    user?: UserOrderByWithRelationInput
    emergencyContact?: EmergencyContactOrderByWithRelationInput
  }

  export type SOSWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: SOSWhereInput | SOSWhereInput[]
    OR?: SOSWhereInput[]
    NOT?: SOSWhereInput | SOSWhereInput[]
    userId?: StringFilter<"SOS"> | string
    emergencyContactId?: StringNullableFilter<"SOS"> | string | null
    latitude?: FloatFilter<"SOS"> | number
    longitude?: FloatFilter<"SOS"> | number
    createdAt?: DateTimeFilter<"SOS"> | Date | string
    customMessage?: StringNullableFilter<"SOS"> | string | null
    status?: EnumSOSStatusFilter<"SOS"> | $Enums.SOSStatus
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    emergencyContact?: XOR<EmergencyContactNullableScalarRelationFilter, EmergencyContactWhereInput> | null
  }, "id">

  export type SOSOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    emergencyContactId?: SortOrder
    latitude?: SortOrder
    longitude?: SortOrder
    createdAt?: SortOrder
    customMessage?: SortOrder
    status?: SortOrder
    _count?: SOSCountOrderByAggregateInput
    _avg?: SOSAvgOrderByAggregateInput
    _max?: SOSMaxOrderByAggregateInput
    _min?: SOSMinOrderByAggregateInput
    _sum?: SOSSumOrderByAggregateInput
  }

  export type SOSScalarWhereWithAggregatesInput = {
    AND?: SOSScalarWhereWithAggregatesInput | SOSScalarWhereWithAggregatesInput[]
    OR?: SOSScalarWhereWithAggregatesInput[]
    NOT?: SOSScalarWhereWithAggregatesInput | SOSScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"SOS"> | string
    userId?: StringWithAggregatesFilter<"SOS"> | string
    emergencyContactId?: StringNullableWithAggregatesFilter<"SOS"> | string | null
    latitude?: FloatWithAggregatesFilter<"SOS"> | number
    longitude?: FloatWithAggregatesFilter<"SOS"> | number
    createdAt?: DateTimeWithAggregatesFilter<"SOS"> | Date | string
    customMessage?: StringNullableWithAggregatesFilter<"SOS"> | string | null
    status?: EnumSOSStatusWithAggregatesFilter<"SOS"> | $Enums.SOSStatus
  }

  export type UserCreateInput = {
    id?: string
    phoneNumber: string
    name?: string | null
    email?: string | null
    password?: string | null
    cars?: CarCreateNestedManyWithoutUserInput
    serviceRequests?: ServiceRequestCreateNestedManyWithoutUserInput
    emergencyContacts?: EmergencyContactCreateNestedManyWithoutUserInput
    sentMessages?: MessageCreateNestedManyWithoutUserInput
    sosEvents?: SOSCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateInput = {
    id?: string
    phoneNumber: string
    name?: string | null
    email?: string | null
    password?: string | null
    cars?: CarUncheckedCreateNestedManyWithoutUserInput
    serviceRequests?: ServiceRequestUncheckedCreateNestedManyWithoutUserInput
    emergencyContacts?: EmergencyContactUncheckedCreateNestedManyWithoutUserInput
    sentMessages?: MessageUncheckedCreateNestedManyWithoutUserInput
    sosEvents?: SOSUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserUpdateInput = {
    phoneNumber?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    cars?: CarUpdateManyWithoutUserNestedInput
    serviceRequests?: ServiceRequestUpdateManyWithoutUserNestedInput
    emergencyContacts?: EmergencyContactUpdateManyWithoutUserNestedInput
    sentMessages?: MessageUpdateManyWithoutUserNestedInput
    sosEvents?: SOSUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateInput = {
    phoneNumber?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    cars?: CarUncheckedUpdateManyWithoutUserNestedInput
    serviceRequests?: ServiceRequestUncheckedUpdateManyWithoutUserNestedInput
    emergencyContacts?: EmergencyContactUncheckedUpdateManyWithoutUserNestedInput
    sentMessages?: MessageUncheckedUpdateManyWithoutUserNestedInput
    sosEvents?: SOSUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateManyInput = {
    id?: string
    phoneNumber: string
    name?: string | null
    email?: string | null
    password?: string | null
  }

  export type UserUpdateManyMutationInput = {
    phoneNumber?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type UserUncheckedUpdateManyInput = {
    phoneNumber?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type MechanicConfirmationCreateInput = {
    id?: string
    status?: $Enums.ConfirmationStatus
    distanceText: string
    distanceValue: number
    durationText: string
    durationValue: number
    estimatedCost: number
    respondedAt?: Date | string | null
    createdAt?: Date | string
    mechanic: MechanicCreateNestedOneWithoutMechanicConfirmationInput
    serviceRequest: ServiceRequestCreateNestedOneWithoutConfirmationsInput
  }

  export type MechanicConfirmationUncheckedCreateInput = {
    id?: string
    mechanicId: string
    serviceRequestId: string
    status?: $Enums.ConfirmationStatus
    distanceText: string
    distanceValue: number
    durationText: string
    durationValue: number
    estimatedCost: number
    respondedAt?: Date | string | null
    createdAt?: Date | string
  }

  export type MechanicConfirmationUpdateInput = {
    status?: EnumConfirmationStatusFieldUpdateOperationsInput | $Enums.ConfirmationStatus
    distanceText?: StringFieldUpdateOperationsInput | string
    distanceValue?: IntFieldUpdateOperationsInput | number
    durationText?: StringFieldUpdateOperationsInput | string
    durationValue?: IntFieldUpdateOperationsInput | number
    estimatedCost?: FloatFieldUpdateOperationsInput | number
    respondedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    mechanic?: MechanicUpdateOneRequiredWithoutMechanicConfirmationNestedInput
    serviceRequest?: ServiceRequestUpdateOneRequiredWithoutConfirmationsNestedInput
  }

  export type MechanicConfirmationUncheckedUpdateInput = {
    mechanicId?: StringFieldUpdateOperationsInput | string
    serviceRequestId?: StringFieldUpdateOperationsInput | string
    status?: EnumConfirmationStatusFieldUpdateOperationsInput | $Enums.ConfirmationStatus
    distanceText?: StringFieldUpdateOperationsInput | string
    distanceValue?: IntFieldUpdateOperationsInput | number
    durationText?: StringFieldUpdateOperationsInput | string
    durationValue?: IntFieldUpdateOperationsInput | number
    estimatedCost?: FloatFieldUpdateOperationsInput | number
    respondedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MechanicConfirmationCreateManyInput = {
    id?: string
    mechanicId: string
    serviceRequestId: string
    status?: $Enums.ConfirmationStatus
    distanceText: string
    distanceValue: number
    durationText: string
    durationValue: number
    estimatedCost: number
    respondedAt?: Date | string | null
    createdAt?: Date | string
  }

  export type MechanicConfirmationUpdateManyMutationInput = {
    status?: EnumConfirmationStatusFieldUpdateOperationsInput | $Enums.ConfirmationStatus
    distanceText?: StringFieldUpdateOperationsInput | string
    distanceValue?: IntFieldUpdateOperationsInput | number
    durationText?: StringFieldUpdateOperationsInput | string
    durationValue?: IntFieldUpdateOperationsInput | number
    estimatedCost?: FloatFieldUpdateOperationsInput | number
    respondedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MechanicConfirmationUncheckedUpdateManyInput = {
    mechanicId?: StringFieldUpdateOperationsInput | string
    serviceRequestId?: StringFieldUpdateOperationsInput | string
    status?: EnumConfirmationStatusFieldUpdateOperationsInput | $Enums.ConfirmationStatus
    distanceText?: StringFieldUpdateOperationsInput | string
    distanceValue?: IntFieldUpdateOperationsInput | number
    durationText?: StringFieldUpdateOperationsInput | string
    durationValue?: IntFieldUpdateOperationsInput | number
    estimatedCost?: FloatFieldUpdateOperationsInput | number
    respondedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MechanicCreateInput = {
    id?: string
    name?: string | null
    email?: string | null
    phoneNumber: string
    services?: MechanicCreateservicesInput | $Enums.ServiceType[]
    latitude?: number | null
    longitude?: number | null
    location?: InputJsonValue | null
    expoToken?: string | null
    serviceRequests?: ServiceRequestCreateNestedManyWithoutMechanicInput
    reviews?: ReviewCreateNestedManyWithoutMechanicInput
    sentMessages?: MessageCreateNestedManyWithoutMechanicInput
    MechanicConfirmation?: MechanicConfirmationCreateNestedManyWithoutMechanicInput
  }

  export type MechanicUncheckedCreateInput = {
    id?: string
    name?: string | null
    email?: string | null
    phoneNumber: string
    services?: MechanicCreateservicesInput | $Enums.ServiceType[]
    latitude?: number | null
    longitude?: number | null
    location?: InputJsonValue | null
    expoToken?: string | null
    serviceRequests?: ServiceRequestUncheckedCreateNestedManyWithoutMechanicInput
    reviews?: ReviewUncheckedCreateNestedManyWithoutMechanicInput
    sentMessages?: MessageUncheckedCreateNestedManyWithoutMechanicInput
    MechanicConfirmation?: MechanicConfirmationUncheckedCreateNestedManyWithoutMechanicInput
  }

  export type MechanicUpdateInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: StringFieldUpdateOperationsInput | string
    services?: MechanicUpdateservicesInput | $Enums.ServiceType[]
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    location?: InputJsonValue | InputJsonValue | null
    expoToken?: NullableStringFieldUpdateOperationsInput | string | null
    serviceRequests?: ServiceRequestUpdateManyWithoutMechanicNestedInput
    reviews?: ReviewUpdateManyWithoutMechanicNestedInput
    sentMessages?: MessageUpdateManyWithoutMechanicNestedInput
    MechanicConfirmation?: MechanicConfirmationUpdateManyWithoutMechanicNestedInput
  }

  export type MechanicUncheckedUpdateInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: StringFieldUpdateOperationsInput | string
    services?: MechanicUpdateservicesInput | $Enums.ServiceType[]
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    location?: InputJsonValue | InputJsonValue | null
    expoToken?: NullableStringFieldUpdateOperationsInput | string | null
    serviceRequests?: ServiceRequestUncheckedUpdateManyWithoutMechanicNestedInput
    reviews?: ReviewUncheckedUpdateManyWithoutMechanicNestedInput
    sentMessages?: MessageUncheckedUpdateManyWithoutMechanicNestedInput
    MechanicConfirmation?: MechanicConfirmationUncheckedUpdateManyWithoutMechanicNestedInput
  }

  export type MechanicCreateManyInput = {
    id?: string
    name?: string | null
    email?: string | null
    phoneNumber: string
    services?: MechanicCreateservicesInput | $Enums.ServiceType[]
    latitude?: number | null
    longitude?: number | null
    location?: InputJsonValue | null
    expoToken?: string | null
  }

  export type MechanicUpdateManyMutationInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: StringFieldUpdateOperationsInput | string
    services?: MechanicUpdateservicesInput | $Enums.ServiceType[]
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    location?: InputJsonValue | InputJsonValue | null
    expoToken?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type MechanicUncheckedUpdateManyInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: StringFieldUpdateOperationsInput | string
    services?: MechanicUpdateservicesInput | $Enums.ServiceType[]
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    location?: InputJsonValue | InputJsonValue | null
    expoToken?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CarCreateInput = {
    id?: string
    make: string
    model: string
    year: number
    licensePlate: string
    user: UserCreateNestedOneWithoutCarsInput
  }

  export type CarUncheckedCreateInput = {
    id?: string
    userId: string
    make: string
    model: string
    year: number
    licensePlate: string
  }

  export type CarUpdateInput = {
    make?: StringFieldUpdateOperationsInput | string
    model?: StringFieldUpdateOperationsInput | string
    year?: IntFieldUpdateOperationsInput | number
    licensePlate?: StringFieldUpdateOperationsInput | string
    user?: UserUpdateOneRequiredWithoutCarsNestedInput
  }

  export type CarUncheckedUpdateInput = {
    userId?: StringFieldUpdateOperationsInput | string
    make?: StringFieldUpdateOperationsInput | string
    model?: StringFieldUpdateOperationsInput | string
    year?: IntFieldUpdateOperationsInput | number
    licensePlate?: StringFieldUpdateOperationsInput | string
  }

  export type CarCreateManyInput = {
    id?: string
    userId: string
    make: string
    model: string
    year: number
    licensePlate: string
  }

  export type CarUpdateManyMutationInput = {
    make?: StringFieldUpdateOperationsInput | string
    model?: StringFieldUpdateOperationsInput | string
    year?: IntFieldUpdateOperationsInput | number
    licensePlate?: StringFieldUpdateOperationsInput | string
  }

  export type CarUncheckedUpdateManyInput = {
    userId?: StringFieldUpdateOperationsInput | string
    make?: StringFieldUpdateOperationsInput | string
    model?: StringFieldUpdateOperationsInput | string
    year?: IntFieldUpdateOperationsInput | number
    licensePlate?: StringFieldUpdateOperationsInput | string
  }

  export type ServiceRequestCreateInput = {
    id?: string
    serviceType: $Enums.ServiceType
    description?: string | null
    latitude: number
    longitude: number
    address?: string | null
    status?: $Enums.ServiceStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutServiceRequestsInput
    mechanic?: MechanicCreateNestedOneWithoutServiceRequestsInput
    payment?: PaymentCreateNestedOneWithoutServiceRequestInput
    chat?: ChatCreateNestedOneWithoutServiceRequestInput
    confirmations?: MechanicConfirmationCreateNestedManyWithoutServiceRequestInput
    reviews?: ReviewCreateNestedManyWithoutServiceRequestInput
  }

  export type ServiceRequestUncheckedCreateInput = {
    id?: string
    userId: string
    mechanicId?: string | null
    serviceType: $Enums.ServiceType
    description?: string | null
    latitude: number
    longitude: number
    address?: string | null
    status?: $Enums.ServiceStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    payment?: PaymentUncheckedCreateNestedOneWithoutServiceRequestInput
    chat?: ChatUncheckedCreateNestedOneWithoutServiceRequestInput
    confirmations?: MechanicConfirmationUncheckedCreateNestedManyWithoutServiceRequestInput
    reviews?: ReviewUncheckedCreateNestedManyWithoutServiceRequestInput
  }

  export type ServiceRequestUpdateInput = {
    serviceType?: EnumServiceTypeFieldUpdateOperationsInput | $Enums.ServiceType
    description?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: FloatFieldUpdateOperationsInput | number
    longitude?: FloatFieldUpdateOperationsInput | number
    address?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumServiceStatusFieldUpdateOperationsInput | $Enums.ServiceStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutServiceRequestsNestedInput
    mechanic?: MechanicUpdateOneWithoutServiceRequestsNestedInput
    payment?: PaymentUpdateOneWithoutServiceRequestNestedInput
    chat?: ChatUpdateOneWithoutServiceRequestNestedInput
    confirmations?: MechanicConfirmationUpdateManyWithoutServiceRequestNestedInput
    reviews?: ReviewUpdateManyWithoutServiceRequestNestedInput
  }

  export type ServiceRequestUncheckedUpdateInput = {
    userId?: StringFieldUpdateOperationsInput | string
    mechanicId?: NullableStringFieldUpdateOperationsInput | string | null
    serviceType?: EnumServiceTypeFieldUpdateOperationsInput | $Enums.ServiceType
    description?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: FloatFieldUpdateOperationsInput | number
    longitude?: FloatFieldUpdateOperationsInput | number
    address?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumServiceStatusFieldUpdateOperationsInput | $Enums.ServiceStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    payment?: PaymentUncheckedUpdateOneWithoutServiceRequestNestedInput
    chat?: ChatUncheckedUpdateOneWithoutServiceRequestNestedInput
    confirmations?: MechanicConfirmationUncheckedUpdateManyWithoutServiceRequestNestedInput
    reviews?: ReviewUncheckedUpdateManyWithoutServiceRequestNestedInput
  }

  export type ServiceRequestCreateManyInput = {
    id?: string
    userId: string
    mechanicId?: string | null
    serviceType: $Enums.ServiceType
    description?: string | null
    latitude: number
    longitude: number
    address?: string | null
    status?: $Enums.ServiceStatus
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ServiceRequestUpdateManyMutationInput = {
    serviceType?: EnumServiceTypeFieldUpdateOperationsInput | $Enums.ServiceType
    description?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: FloatFieldUpdateOperationsInput | number
    longitude?: FloatFieldUpdateOperationsInput | number
    address?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumServiceStatusFieldUpdateOperationsInput | $Enums.ServiceStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ServiceRequestUncheckedUpdateManyInput = {
    userId?: StringFieldUpdateOperationsInput | string
    mechanicId?: NullableStringFieldUpdateOperationsInput | string | null
    serviceType?: EnumServiceTypeFieldUpdateOperationsInput | $Enums.ServiceType
    description?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: FloatFieldUpdateOperationsInput | number
    longitude?: FloatFieldUpdateOperationsInput | number
    address?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumServiceStatusFieldUpdateOperationsInput | $Enums.ServiceStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmergencyContactCreateInput = {
    id?: string
    name: string
    mobileNumber: string
    user: UserCreateNestedOneWithoutEmergencyContactsInput
    sosEvents?: SOSCreateNestedManyWithoutEmergencyContactInput
  }

  export type EmergencyContactUncheckedCreateInput = {
    id?: string
    userId: string
    name: string
    mobileNumber: string
    sosEvents?: SOSUncheckedCreateNestedManyWithoutEmergencyContactInput
  }

  export type EmergencyContactUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    mobileNumber?: StringFieldUpdateOperationsInput | string
    user?: UserUpdateOneRequiredWithoutEmergencyContactsNestedInput
    sosEvents?: SOSUpdateManyWithoutEmergencyContactNestedInput
  }

  export type EmergencyContactUncheckedUpdateInput = {
    userId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    mobileNumber?: StringFieldUpdateOperationsInput | string
    sosEvents?: SOSUncheckedUpdateManyWithoutEmergencyContactNestedInput
  }

  export type EmergencyContactCreateManyInput = {
    id?: string
    userId: string
    name: string
    mobileNumber: string
  }

  export type EmergencyContactUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    mobileNumber?: StringFieldUpdateOperationsInput | string
  }

  export type EmergencyContactUncheckedUpdateManyInput = {
    userId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    mobileNumber?: StringFieldUpdateOperationsInput | string
  }

  export type ReviewCreateInput = {
    id?: string
    reviewerType: $Enums.SenderType
    rating: number
    comment?: string | null
    createdAt?: Date | string
    serviceRequest: ServiceRequestCreateNestedOneWithoutReviewsInput
    Mechanic?: MechanicCreateNestedOneWithoutReviewsInput
  }

  export type ReviewUncheckedCreateInput = {
    id?: string
    serviceRequestId: string
    reviewerType: $Enums.SenderType
    rating: number
    comment?: string | null
    createdAt?: Date | string
    mechanicId?: string | null
  }

  export type ReviewUpdateInput = {
    reviewerType?: EnumSenderTypeFieldUpdateOperationsInput | $Enums.SenderType
    rating?: IntFieldUpdateOperationsInput | number
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    serviceRequest?: ServiceRequestUpdateOneRequiredWithoutReviewsNestedInput
    Mechanic?: MechanicUpdateOneWithoutReviewsNestedInput
  }

  export type ReviewUncheckedUpdateInput = {
    serviceRequestId?: StringFieldUpdateOperationsInput | string
    reviewerType?: EnumSenderTypeFieldUpdateOperationsInput | $Enums.SenderType
    rating?: IntFieldUpdateOperationsInput | number
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    mechanicId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ReviewCreateManyInput = {
    id?: string
    serviceRequestId: string
    reviewerType: $Enums.SenderType
    rating: number
    comment?: string | null
    createdAt?: Date | string
    mechanicId?: string | null
  }

  export type ReviewUpdateManyMutationInput = {
    reviewerType?: EnumSenderTypeFieldUpdateOperationsInput | $Enums.SenderType
    rating?: IntFieldUpdateOperationsInput | number
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReviewUncheckedUpdateManyInput = {
    serviceRequestId?: StringFieldUpdateOperationsInput | string
    reviewerType?: EnumSenderTypeFieldUpdateOperationsInput | $Enums.SenderType
    rating?: IntFieldUpdateOperationsInput | number
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    mechanicId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PaymentCreateInput = {
    id?: string
    amount: number
    status: $Enums.PaymentStatus
    razorpayOrderId?: string | null
    razorpayPaymentId?: string | null
    razorpaySignature?: string | null
    comment?: string | null
    createdAt?: Date | string
    serviceRequest: ServiceRequestCreateNestedOneWithoutPaymentInput
  }

  export type PaymentUncheckedCreateInput = {
    id?: string
    serviceRequestId: string
    amount: number
    status: $Enums.PaymentStatus
    razorpayOrderId?: string | null
    razorpayPaymentId?: string | null
    razorpaySignature?: string | null
    comment?: string | null
    createdAt?: Date | string
  }

  export type PaymentUpdateInput = {
    amount?: FloatFieldUpdateOperationsInput | number
    status?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    razorpayOrderId?: NullableStringFieldUpdateOperationsInput | string | null
    razorpayPaymentId?: NullableStringFieldUpdateOperationsInput | string | null
    razorpaySignature?: NullableStringFieldUpdateOperationsInput | string | null
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    serviceRequest?: ServiceRequestUpdateOneRequiredWithoutPaymentNestedInput
  }

  export type PaymentUncheckedUpdateInput = {
    serviceRequestId?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    status?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    razorpayOrderId?: NullableStringFieldUpdateOperationsInput | string | null
    razorpayPaymentId?: NullableStringFieldUpdateOperationsInput | string | null
    razorpaySignature?: NullableStringFieldUpdateOperationsInput | string | null
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentCreateManyInput = {
    id?: string
    serviceRequestId: string
    amount: number
    status: $Enums.PaymentStatus
    razorpayOrderId?: string | null
    razorpayPaymentId?: string | null
    razorpaySignature?: string | null
    comment?: string | null
    createdAt?: Date | string
  }

  export type PaymentUpdateManyMutationInput = {
    amount?: FloatFieldUpdateOperationsInput | number
    status?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    razorpayOrderId?: NullableStringFieldUpdateOperationsInput | string | null
    razorpayPaymentId?: NullableStringFieldUpdateOperationsInput | string | null
    razorpaySignature?: NullableStringFieldUpdateOperationsInput | string | null
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentUncheckedUpdateManyInput = {
    serviceRequestId?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    status?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    razorpayOrderId?: NullableStringFieldUpdateOperationsInput | string | null
    razorpayPaymentId?: NullableStringFieldUpdateOperationsInput | string | null
    razorpaySignature?: NullableStringFieldUpdateOperationsInput | string | null
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChatCreateInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    serviceRequest: ServiceRequestCreateNestedOneWithoutChatInput
    messages?: MessageCreateNestedManyWithoutChatInput
  }

  export type ChatUncheckedCreateInput = {
    id?: string
    serviceRequestId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    messages?: MessageUncheckedCreateNestedManyWithoutChatInput
  }

  export type ChatUpdateInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    serviceRequest?: ServiceRequestUpdateOneRequiredWithoutChatNestedInput
    messages?: MessageUpdateManyWithoutChatNestedInput
  }

  export type ChatUncheckedUpdateInput = {
    serviceRequestId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    messages?: MessageUncheckedUpdateManyWithoutChatNestedInput
  }

  export type ChatCreateManyInput = {
    id?: string
    serviceRequestId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ChatUpdateManyMutationInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChatUncheckedUpdateManyInput = {
    serviceRequestId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MessageCreateInput = {
    id?: string
    senderType: string
    content: string
    createdAt?: Date | string
    chat: ChatCreateNestedOneWithoutMessagesInput
    user?: UserCreateNestedOneWithoutSentMessagesInput
    mechanic?: MechanicCreateNestedOneWithoutSentMessagesInput
  }

  export type MessageUncheckedCreateInput = {
    id?: string
    chatId: string
    senderId?: string | null
    senderType: string
    content: string
    createdAt?: Date | string
  }

  export type MessageUpdateInput = {
    senderType?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    chat?: ChatUpdateOneRequiredWithoutMessagesNestedInput
    user?: UserUpdateOneWithoutSentMessagesNestedInput
    mechanic?: MechanicUpdateOneWithoutSentMessagesNestedInput
  }

  export type MessageUncheckedUpdateInput = {
    chatId?: StringFieldUpdateOperationsInput | string
    senderId?: NullableStringFieldUpdateOperationsInput | string | null
    senderType?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MessageCreateManyInput = {
    id?: string
    chatId: string
    senderId?: string | null
    senderType: string
    content: string
    createdAt?: Date | string
  }

  export type MessageUpdateManyMutationInput = {
    senderType?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MessageUncheckedUpdateManyInput = {
    chatId?: StringFieldUpdateOperationsInput | string
    senderId?: NullableStringFieldUpdateOperationsInput | string | null
    senderType?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SOSCreateInput = {
    id?: string
    latitude: number
    longitude: number
    createdAt?: Date | string
    customMessage?: string | null
    status?: $Enums.SOSStatus
    user: UserCreateNestedOneWithoutSosEventsInput
    emergencyContact?: EmergencyContactCreateNestedOneWithoutSosEventsInput
  }

  export type SOSUncheckedCreateInput = {
    id?: string
    userId: string
    emergencyContactId?: string | null
    latitude: number
    longitude: number
    createdAt?: Date | string
    customMessage?: string | null
    status?: $Enums.SOSStatus
  }

  export type SOSUpdateInput = {
    latitude?: FloatFieldUpdateOperationsInput | number
    longitude?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    customMessage?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumSOSStatusFieldUpdateOperationsInput | $Enums.SOSStatus
    user?: UserUpdateOneRequiredWithoutSosEventsNestedInput
    emergencyContact?: EmergencyContactUpdateOneWithoutSosEventsNestedInput
  }

  export type SOSUncheckedUpdateInput = {
    userId?: StringFieldUpdateOperationsInput | string
    emergencyContactId?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: FloatFieldUpdateOperationsInput | number
    longitude?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    customMessage?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumSOSStatusFieldUpdateOperationsInput | $Enums.SOSStatus
  }

  export type SOSCreateManyInput = {
    id?: string
    userId: string
    emergencyContactId?: string | null
    latitude: number
    longitude: number
    createdAt?: Date | string
    customMessage?: string | null
    status?: $Enums.SOSStatus
  }

  export type SOSUpdateManyMutationInput = {
    latitude?: FloatFieldUpdateOperationsInput | number
    longitude?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    customMessage?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumSOSStatusFieldUpdateOperationsInput | $Enums.SOSStatus
  }

  export type SOSUncheckedUpdateManyInput = {
    userId?: StringFieldUpdateOperationsInput | string
    emergencyContactId?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: FloatFieldUpdateOperationsInput | number
    longitude?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    customMessage?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumSOSStatusFieldUpdateOperationsInput | $Enums.SOSStatus
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
    isSet?: boolean
  }

  export type CarListRelationFilter = {
    every?: CarWhereInput
    some?: CarWhereInput
    none?: CarWhereInput
  }

  export type ServiceRequestListRelationFilter = {
    every?: ServiceRequestWhereInput
    some?: ServiceRequestWhereInput
    none?: ServiceRequestWhereInput
  }

  export type EmergencyContactListRelationFilter = {
    every?: EmergencyContactWhereInput
    some?: EmergencyContactWhereInput
    none?: EmergencyContactWhereInput
  }

  export type MessageListRelationFilter = {
    every?: MessageWhereInput
    some?: MessageWhereInput
    none?: MessageWhereInput
  }

  export type SOSListRelationFilter = {
    every?: SOSWhereInput
    some?: SOSWhereInput
    none?: SOSWhereInput
  }

  export type CarOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ServiceRequestOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type EmergencyContactOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MessageOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SOSOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    phoneNumber?: SortOrder
    name?: SortOrder
    email?: SortOrder
    password?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    phoneNumber?: SortOrder
    name?: SortOrder
    email?: SortOrder
    password?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    phoneNumber?: SortOrder
    name?: SortOrder
    email?: SortOrder
    password?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
    isSet?: boolean
  }

  export type EnumConfirmationStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.ConfirmationStatus | EnumConfirmationStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ConfirmationStatus[] | ListEnumConfirmationStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ConfirmationStatus[] | ListEnumConfirmationStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumConfirmationStatusFilter<$PrismaModel> | $Enums.ConfirmationStatus
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type FloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
    isSet?: boolean
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type MechanicScalarRelationFilter = {
    is?: MechanicWhereInput
    isNot?: MechanicWhereInput
  }

  export type ServiceRequestScalarRelationFilter = {
    is?: ServiceRequestWhereInput
    isNot?: ServiceRequestWhereInput
  }

  export type MechanicConfirmationCountOrderByAggregateInput = {
    id?: SortOrder
    mechanicId?: SortOrder
    serviceRequestId?: SortOrder
    status?: SortOrder
    distanceText?: SortOrder
    distanceValue?: SortOrder
    durationText?: SortOrder
    durationValue?: SortOrder
    estimatedCost?: SortOrder
    respondedAt?: SortOrder
    createdAt?: SortOrder
  }

  export type MechanicConfirmationAvgOrderByAggregateInput = {
    distanceValue?: SortOrder
    durationValue?: SortOrder
    estimatedCost?: SortOrder
  }

  export type MechanicConfirmationMaxOrderByAggregateInput = {
    id?: SortOrder
    mechanicId?: SortOrder
    serviceRequestId?: SortOrder
    status?: SortOrder
    distanceText?: SortOrder
    distanceValue?: SortOrder
    durationText?: SortOrder
    durationValue?: SortOrder
    estimatedCost?: SortOrder
    respondedAt?: SortOrder
    createdAt?: SortOrder
  }

  export type MechanicConfirmationMinOrderByAggregateInput = {
    id?: SortOrder
    mechanicId?: SortOrder
    serviceRequestId?: SortOrder
    status?: SortOrder
    distanceText?: SortOrder
    distanceValue?: SortOrder
    durationText?: SortOrder
    durationValue?: SortOrder
    estimatedCost?: SortOrder
    respondedAt?: SortOrder
    createdAt?: SortOrder
  }

  export type MechanicConfirmationSumOrderByAggregateInput = {
    distanceValue?: SortOrder
    durationValue?: SortOrder
    estimatedCost?: SortOrder
  }

  export type EnumConfirmationStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ConfirmationStatus | EnumConfirmationStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ConfirmationStatus[] | ListEnumConfirmationStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ConfirmationStatus[] | ListEnumConfirmationStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumConfirmationStatusWithAggregatesFilter<$PrismaModel> | $Enums.ConfirmationStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumConfirmationStatusFilter<$PrismaModel>
    _max?: NestedEnumConfirmationStatusFilter<$PrismaModel>
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type FloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
    isSet?: boolean
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type EnumServiceTypeNullableListFilter<$PrismaModel = never> = {
    equals?: $Enums.ServiceType[] | ListEnumServiceTypeFieldRefInput<$PrismaModel> | null
    has?: $Enums.ServiceType | EnumServiceTypeFieldRefInput<$PrismaModel> | null
    hasEvery?: $Enums.ServiceType[] | ListEnumServiceTypeFieldRefInput<$PrismaModel>
    hasSome?: $Enums.ServiceType[] | ListEnumServiceTypeFieldRefInput<$PrismaModel>
    isEmpty?: boolean
  }

  export type FloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
    isSet?: boolean
  }
  export type JsonNullableFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    isSet?: boolean
  }

  export type ReviewListRelationFilter = {
    every?: ReviewWhereInput
    some?: ReviewWhereInput
    none?: ReviewWhereInput
  }

  export type MechanicConfirmationListRelationFilter = {
    every?: MechanicConfirmationWhereInput
    some?: MechanicConfirmationWhereInput
    none?: MechanicConfirmationWhereInput
  }

  export type ReviewOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MechanicConfirmationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MechanicCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    phoneNumber?: SortOrder
    services?: SortOrder
    latitude?: SortOrder
    longitude?: SortOrder
    location?: SortOrder
    expoToken?: SortOrder
  }

  export type MechanicAvgOrderByAggregateInput = {
    latitude?: SortOrder
    longitude?: SortOrder
  }

  export type MechanicMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    phoneNumber?: SortOrder
    latitude?: SortOrder
    longitude?: SortOrder
    expoToken?: SortOrder
  }

  export type MechanicMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    phoneNumber?: SortOrder
    latitude?: SortOrder
    longitude?: SortOrder
    expoToken?: SortOrder
  }

  export type MechanicSumOrderByAggregateInput = {
    latitude?: SortOrder
    longitude?: SortOrder
  }

  export type FloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
    isSet?: boolean
  }
  export type JsonNullableWithAggregatesFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedJsonNullableFilter<$PrismaModel>
    _max?: NestedJsonNullableFilter<$PrismaModel>
    isSet?: boolean
  }

  export type UserScalarRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type CarCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    make?: SortOrder
    model?: SortOrder
    year?: SortOrder
    licensePlate?: SortOrder
  }

  export type CarAvgOrderByAggregateInput = {
    year?: SortOrder
  }

  export type CarMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    make?: SortOrder
    model?: SortOrder
    year?: SortOrder
    licensePlate?: SortOrder
  }

  export type CarMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    make?: SortOrder
    model?: SortOrder
    year?: SortOrder
    licensePlate?: SortOrder
  }

  export type CarSumOrderByAggregateInput = {
    year?: SortOrder
  }

  export type EnumServiceTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.ServiceType | EnumServiceTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ServiceType[] | ListEnumServiceTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ServiceType[] | ListEnumServiceTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumServiceTypeFilter<$PrismaModel> | $Enums.ServiceType
  }

  export type EnumServiceStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.ServiceStatus | EnumServiceStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ServiceStatus[] | ListEnumServiceStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ServiceStatus[] | ListEnumServiceStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumServiceStatusFilter<$PrismaModel> | $Enums.ServiceStatus
  }

  export type MechanicNullableScalarRelationFilter = {
    is?: MechanicWhereInput | null
    isNot?: MechanicWhereInput | null
  }

  export type PaymentNullableScalarRelationFilter = {
    is?: PaymentWhereInput | null
    isNot?: PaymentWhereInput | null
  }

  export type ChatNullableScalarRelationFilter = {
    is?: ChatWhereInput | null
    isNot?: ChatWhereInput | null
  }

  export type ServiceRequestCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    mechanicId?: SortOrder
    serviceType?: SortOrder
    description?: SortOrder
    latitude?: SortOrder
    longitude?: SortOrder
    address?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ServiceRequestAvgOrderByAggregateInput = {
    latitude?: SortOrder
    longitude?: SortOrder
  }

  export type ServiceRequestMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    mechanicId?: SortOrder
    serviceType?: SortOrder
    description?: SortOrder
    latitude?: SortOrder
    longitude?: SortOrder
    address?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ServiceRequestMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    mechanicId?: SortOrder
    serviceType?: SortOrder
    description?: SortOrder
    latitude?: SortOrder
    longitude?: SortOrder
    address?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ServiceRequestSumOrderByAggregateInput = {
    latitude?: SortOrder
    longitude?: SortOrder
  }

  export type EnumServiceTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ServiceType | EnumServiceTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ServiceType[] | ListEnumServiceTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ServiceType[] | ListEnumServiceTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumServiceTypeWithAggregatesFilter<$PrismaModel> | $Enums.ServiceType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumServiceTypeFilter<$PrismaModel>
    _max?: NestedEnumServiceTypeFilter<$PrismaModel>
  }

  export type EnumServiceStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ServiceStatus | EnumServiceStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ServiceStatus[] | ListEnumServiceStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ServiceStatus[] | ListEnumServiceStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumServiceStatusWithAggregatesFilter<$PrismaModel> | $Enums.ServiceStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumServiceStatusFilter<$PrismaModel>
    _max?: NestedEnumServiceStatusFilter<$PrismaModel>
  }

  export type EmergencyContactCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    name?: SortOrder
    mobileNumber?: SortOrder
  }

  export type EmergencyContactMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    name?: SortOrder
    mobileNumber?: SortOrder
  }

  export type EmergencyContactMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    name?: SortOrder
    mobileNumber?: SortOrder
  }

  export type EnumSenderTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.SenderType | EnumSenderTypeFieldRefInput<$PrismaModel>
    in?: $Enums.SenderType[] | ListEnumSenderTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.SenderType[] | ListEnumSenderTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumSenderTypeFilter<$PrismaModel> | $Enums.SenderType
  }

  export type ReviewCountOrderByAggregateInput = {
    id?: SortOrder
    serviceRequestId?: SortOrder
    reviewerType?: SortOrder
    rating?: SortOrder
    comment?: SortOrder
    createdAt?: SortOrder
    mechanicId?: SortOrder
  }

  export type ReviewAvgOrderByAggregateInput = {
    rating?: SortOrder
  }

  export type ReviewMaxOrderByAggregateInput = {
    id?: SortOrder
    serviceRequestId?: SortOrder
    reviewerType?: SortOrder
    rating?: SortOrder
    comment?: SortOrder
    createdAt?: SortOrder
    mechanicId?: SortOrder
  }

  export type ReviewMinOrderByAggregateInput = {
    id?: SortOrder
    serviceRequestId?: SortOrder
    reviewerType?: SortOrder
    rating?: SortOrder
    comment?: SortOrder
    createdAt?: SortOrder
    mechanicId?: SortOrder
  }

  export type ReviewSumOrderByAggregateInput = {
    rating?: SortOrder
  }

  export type EnumSenderTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.SenderType | EnumSenderTypeFieldRefInput<$PrismaModel>
    in?: $Enums.SenderType[] | ListEnumSenderTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.SenderType[] | ListEnumSenderTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumSenderTypeWithAggregatesFilter<$PrismaModel> | $Enums.SenderType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSenderTypeFilter<$PrismaModel>
    _max?: NestedEnumSenderTypeFilter<$PrismaModel>
  }

  export type EnumPaymentStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentStatus | EnumPaymentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentStatus[] | ListEnumPaymentStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.PaymentStatus[] | ListEnumPaymentStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumPaymentStatusFilter<$PrismaModel> | $Enums.PaymentStatus
  }

  export type PaymentCountOrderByAggregateInput = {
    id?: SortOrder
    serviceRequestId?: SortOrder
    amount?: SortOrder
    status?: SortOrder
    razorpayOrderId?: SortOrder
    razorpayPaymentId?: SortOrder
    razorpaySignature?: SortOrder
    comment?: SortOrder
    createdAt?: SortOrder
  }

  export type PaymentAvgOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type PaymentMaxOrderByAggregateInput = {
    id?: SortOrder
    serviceRequestId?: SortOrder
    amount?: SortOrder
    status?: SortOrder
    razorpayOrderId?: SortOrder
    razorpayPaymentId?: SortOrder
    razorpaySignature?: SortOrder
    comment?: SortOrder
    createdAt?: SortOrder
  }

  export type PaymentMinOrderByAggregateInput = {
    id?: SortOrder
    serviceRequestId?: SortOrder
    amount?: SortOrder
    status?: SortOrder
    razorpayOrderId?: SortOrder
    razorpayPaymentId?: SortOrder
    razorpaySignature?: SortOrder
    comment?: SortOrder
    createdAt?: SortOrder
  }

  export type PaymentSumOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type EnumPaymentStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentStatus | EnumPaymentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentStatus[] | ListEnumPaymentStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.PaymentStatus[] | ListEnumPaymentStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumPaymentStatusWithAggregatesFilter<$PrismaModel> | $Enums.PaymentStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPaymentStatusFilter<$PrismaModel>
    _max?: NestedEnumPaymentStatusFilter<$PrismaModel>
  }

  export type ChatCountOrderByAggregateInput = {
    id?: SortOrder
    serviceRequestId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ChatMaxOrderByAggregateInput = {
    id?: SortOrder
    serviceRequestId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ChatMinOrderByAggregateInput = {
    id?: SortOrder
    serviceRequestId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ChatScalarRelationFilter = {
    is?: ChatWhereInput
    isNot?: ChatWhereInput
  }

  export type UserNullableScalarRelationFilter = {
    is?: UserWhereInput | null
    isNot?: UserWhereInput | null
  }

  export type MessageCountOrderByAggregateInput = {
    id?: SortOrder
    chatId?: SortOrder
    senderId?: SortOrder
    senderType?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
  }

  export type MessageMaxOrderByAggregateInput = {
    id?: SortOrder
    chatId?: SortOrder
    senderId?: SortOrder
    senderType?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
  }

  export type MessageMinOrderByAggregateInput = {
    id?: SortOrder
    chatId?: SortOrder
    senderId?: SortOrder
    senderType?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
  }

  export type EnumSOSStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.SOSStatus | EnumSOSStatusFieldRefInput<$PrismaModel>
    in?: $Enums.SOSStatus[] | ListEnumSOSStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.SOSStatus[] | ListEnumSOSStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumSOSStatusFilter<$PrismaModel> | $Enums.SOSStatus
  }

  export type EmergencyContactNullableScalarRelationFilter = {
    is?: EmergencyContactWhereInput | null
    isNot?: EmergencyContactWhereInput | null
  }

  export type SOSCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    emergencyContactId?: SortOrder
    latitude?: SortOrder
    longitude?: SortOrder
    createdAt?: SortOrder
    customMessage?: SortOrder
    status?: SortOrder
  }

  export type SOSAvgOrderByAggregateInput = {
    latitude?: SortOrder
    longitude?: SortOrder
  }

  export type SOSMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    emergencyContactId?: SortOrder
    latitude?: SortOrder
    longitude?: SortOrder
    createdAt?: SortOrder
    customMessage?: SortOrder
    status?: SortOrder
  }

  export type SOSMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    emergencyContactId?: SortOrder
    latitude?: SortOrder
    longitude?: SortOrder
    createdAt?: SortOrder
    customMessage?: SortOrder
    status?: SortOrder
  }

  export type SOSSumOrderByAggregateInput = {
    latitude?: SortOrder
    longitude?: SortOrder
  }

  export type EnumSOSStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.SOSStatus | EnumSOSStatusFieldRefInput<$PrismaModel>
    in?: $Enums.SOSStatus[] | ListEnumSOSStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.SOSStatus[] | ListEnumSOSStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumSOSStatusWithAggregatesFilter<$PrismaModel> | $Enums.SOSStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSOSStatusFilter<$PrismaModel>
    _max?: NestedEnumSOSStatusFilter<$PrismaModel>
  }

  export type CarCreateNestedManyWithoutUserInput = {
    create?: XOR<CarCreateWithoutUserInput, CarUncheckedCreateWithoutUserInput> | CarCreateWithoutUserInput[] | CarUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CarCreateOrConnectWithoutUserInput | CarCreateOrConnectWithoutUserInput[]
    createMany?: CarCreateManyUserInputEnvelope
    connect?: CarWhereUniqueInput | CarWhereUniqueInput[]
  }

  export type ServiceRequestCreateNestedManyWithoutUserInput = {
    create?: XOR<ServiceRequestCreateWithoutUserInput, ServiceRequestUncheckedCreateWithoutUserInput> | ServiceRequestCreateWithoutUserInput[] | ServiceRequestUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ServiceRequestCreateOrConnectWithoutUserInput | ServiceRequestCreateOrConnectWithoutUserInput[]
    createMany?: ServiceRequestCreateManyUserInputEnvelope
    connect?: ServiceRequestWhereUniqueInput | ServiceRequestWhereUniqueInput[]
  }

  export type EmergencyContactCreateNestedManyWithoutUserInput = {
    create?: XOR<EmergencyContactCreateWithoutUserInput, EmergencyContactUncheckedCreateWithoutUserInput> | EmergencyContactCreateWithoutUserInput[] | EmergencyContactUncheckedCreateWithoutUserInput[]
    connectOrCreate?: EmergencyContactCreateOrConnectWithoutUserInput | EmergencyContactCreateOrConnectWithoutUserInput[]
    createMany?: EmergencyContactCreateManyUserInputEnvelope
    connect?: EmergencyContactWhereUniqueInput | EmergencyContactWhereUniqueInput[]
  }

  export type MessageCreateNestedManyWithoutUserInput = {
    create?: XOR<MessageCreateWithoutUserInput, MessageUncheckedCreateWithoutUserInput> | MessageCreateWithoutUserInput[] | MessageUncheckedCreateWithoutUserInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutUserInput | MessageCreateOrConnectWithoutUserInput[]
    createMany?: MessageCreateManyUserInputEnvelope
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
  }

  export type SOSCreateNestedManyWithoutUserInput = {
    create?: XOR<SOSCreateWithoutUserInput, SOSUncheckedCreateWithoutUserInput> | SOSCreateWithoutUserInput[] | SOSUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SOSCreateOrConnectWithoutUserInput | SOSCreateOrConnectWithoutUserInput[]
    createMany?: SOSCreateManyUserInputEnvelope
    connect?: SOSWhereUniqueInput | SOSWhereUniqueInput[]
  }

  export type CarUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<CarCreateWithoutUserInput, CarUncheckedCreateWithoutUserInput> | CarCreateWithoutUserInput[] | CarUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CarCreateOrConnectWithoutUserInput | CarCreateOrConnectWithoutUserInput[]
    createMany?: CarCreateManyUserInputEnvelope
    connect?: CarWhereUniqueInput | CarWhereUniqueInput[]
  }

  export type ServiceRequestUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<ServiceRequestCreateWithoutUserInput, ServiceRequestUncheckedCreateWithoutUserInput> | ServiceRequestCreateWithoutUserInput[] | ServiceRequestUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ServiceRequestCreateOrConnectWithoutUserInput | ServiceRequestCreateOrConnectWithoutUserInput[]
    createMany?: ServiceRequestCreateManyUserInputEnvelope
    connect?: ServiceRequestWhereUniqueInput | ServiceRequestWhereUniqueInput[]
  }

  export type EmergencyContactUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<EmergencyContactCreateWithoutUserInput, EmergencyContactUncheckedCreateWithoutUserInput> | EmergencyContactCreateWithoutUserInput[] | EmergencyContactUncheckedCreateWithoutUserInput[]
    connectOrCreate?: EmergencyContactCreateOrConnectWithoutUserInput | EmergencyContactCreateOrConnectWithoutUserInput[]
    createMany?: EmergencyContactCreateManyUserInputEnvelope
    connect?: EmergencyContactWhereUniqueInput | EmergencyContactWhereUniqueInput[]
  }

  export type MessageUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<MessageCreateWithoutUserInput, MessageUncheckedCreateWithoutUserInput> | MessageCreateWithoutUserInput[] | MessageUncheckedCreateWithoutUserInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutUserInput | MessageCreateOrConnectWithoutUserInput[]
    createMany?: MessageCreateManyUserInputEnvelope
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
  }

  export type SOSUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<SOSCreateWithoutUserInput, SOSUncheckedCreateWithoutUserInput> | SOSCreateWithoutUserInput[] | SOSUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SOSCreateOrConnectWithoutUserInput | SOSCreateOrConnectWithoutUserInput[]
    createMany?: SOSCreateManyUserInputEnvelope
    connect?: SOSWhereUniqueInput | SOSWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
    unset?: boolean
  }

  export type CarUpdateManyWithoutUserNestedInput = {
    create?: XOR<CarCreateWithoutUserInput, CarUncheckedCreateWithoutUserInput> | CarCreateWithoutUserInput[] | CarUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CarCreateOrConnectWithoutUserInput | CarCreateOrConnectWithoutUserInput[]
    upsert?: CarUpsertWithWhereUniqueWithoutUserInput | CarUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: CarCreateManyUserInputEnvelope
    set?: CarWhereUniqueInput | CarWhereUniqueInput[]
    disconnect?: CarWhereUniqueInput | CarWhereUniqueInput[]
    delete?: CarWhereUniqueInput | CarWhereUniqueInput[]
    connect?: CarWhereUniqueInput | CarWhereUniqueInput[]
    update?: CarUpdateWithWhereUniqueWithoutUserInput | CarUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: CarUpdateManyWithWhereWithoutUserInput | CarUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: CarScalarWhereInput | CarScalarWhereInput[]
  }

  export type ServiceRequestUpdateManyWithoutUserNestedInput = {
    create?: XOR<ServiceRequestCreateWithoutUserInput, ServiceRequestUncheckedCreateWithoutUserInput> | ServiceRequestCreateWithoutUserInput[] | ServiceRequestUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ServiceRequestCreateOrConnectWithoutUserInput | ServiceRequestCreateOrConnectWithoutUserInput[]
    upsert?: ServiceRequestUpsertWithWhereUniqueWithoutUserInput | ServiceRequestUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ServiceRequestCreateManyUserInputEnvelope
    set?: ServiceRequestWhereUniqueInput | ServiceRequestWhereUniqueInput[]
    disconnect?: ServiceRequestWhereUniqueInput | ServiceRequestWhereUniqueInput[]
    delete?: ServiceRequestWhereUniqueInput | ServiceRequestWhereUniqueInput[]
    connect?: ServiceRequestWhereUniqueInput | ServiceRequestWhereUniqueInput[]
    update?: ServiceRequestUpdateWithWhereUniqueWithoutUserInput | ServiceRequestUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ServiceRequestUpdateManyWithWhereWithoutUserInput | ServiceRequestUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ServiceRequestScalarWhereInput | ServiceRequestScalarWhereInput[]
  }

  export type EmergencyContactUpdateManyWithoutUserNestedInput = {
    create?: XOR<EmergencyContactCreateWithoutUserInput, EmergencyContactUncheckedCreateWithoutUserInput> | EmergencyContactCreateWithoutUserInput[] | EmergencyContactUncheckedCreateWithoutUserInput[]
    connectOrCreate?: EmergencyContactCreateOrConnectWithoutUserInput | EmergencyContactCreateOrConnectWithoutUserInput[]
    upsert?: EmergencyContactUpsertWithWhereUniqueWithoutUserInput | EmergencyContactUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: EmergencyContactCreateManyUserInputEnvelope
    set?: EmergencyContactWhereUniqueInput | EmergencyContactWhereUniqueInput[]
    disconnect?: EmergencyContactWhereUniqueInput | EmergencyContactWhereUniqueInput[]
    delete?: EmergencyContactWhereUniqueInput | EmergencyContactWhereUniqueInput[]
    connect?: EmergencyContactWhereUniqueInput | EmergencyContactWhereUniqueInput[]
    update?: EmergencyContactUpdateWithWhereUniqueWithoutUserInput | EmergencyContactUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: EmergencyContactUpdateManyWithWhereWithoutUserInput | EmergencyContactUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: EmergencyContactScalarWhereInput | EmergencyContactScalarWhereInput[]
  }

  export type MessageUpdateManyWithoutUserNestedInput = {
    create?: XOR<MessageCreateWithoutUserInput, MessageUncheckedCreateWithoutUserInput> | MessageCreateWithoutUserInput[] | MessageUncheckedCreateWithoutUserInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutUserInput | MessageCreateOrConnectWithoutUserInput[]
    upsert?: MessageUpsertWithWhereUniqueWithoutUserInput | MessageUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: MessageCreateManyUserInputEnvelope
    set?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    disconnect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    delete?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    update?: MessageUpdateWithWhereUniqueWithoutUserInput | MessageUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: MessageUpdateManyWithWhereWithoutUserInput | MessageUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: MessageScalarWhereInput | MessageScalarWhereInput[]
  }

  export type SOSUpdateManyWithoutUserNestedInput = {
    create?: XOR<SOSCreateWithoutUserInput, SOSUncheckedCreateWithoutUserInput> | SOSCreateWithoutUserInput[] | SOSUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SOSCreateOrConnectWithoutUserInput | SOSCreateOrConnectWithoutUserInput[]
    upsert?: SOSUpsertWithWhereUniqueWithoutUserInput | SOSUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: SOSCreateManyUserInputEnvelope
    set?: SOSWhereUniqueInput | SOSWhereUniqueInput[]
    disconnect?: SOSWhereUniqueInput | SOSWhereUniqueInput[]
    delete?: SOSWhereUniqueInput | SOSWhereUniqueInput[]
    connect?: SOSWhereUniqueInput | SOSWhereUniqueInput[]
    update?: SOSUpdateWithWhereUniqueWithoutUserInput | SOSUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: SOSUpdateManyWithWhereWithoutUserInput | SOSUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: SOSScalarWhereInput | SOSScalarWhereInput[]
  }

  export type CarUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<CarCreateWithoutUserInput, CarUncheckedCreateWithoutUserInput> | CarCreateWithoutUserInput[] | CarUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CarCreateOrConnectWithoutUserInput | CarCreateOrConnectWithoutUserInput[]
    upsert?: CarUpsertWithWhereUniqueWithoutUserInput | CarUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: CarCreateManyUserInputEnvelope
    set?: CarWhereUniqueInput | CarWhereUniqueInput[]
    disconnect?: CarWhereUniqueInput | CarWhereUniqueInput[]
    delete?: CarWhereUniqueInput | CarWhereUniqueInput[]
    connect?: CarWhereUniqueInput | CarWhereUniqueInput[]
    update?: CarUpdateWithWhereUniqueWithoutUserInput | CarUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: CarUpdateManyWithWhereWithoutUserInput | CarUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: CarScalarWhereInput | CarScalarWhereInput[]
  }

  export type ServiceRequestUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<ServiceRequestCreateWithoutUserInput, ServiceRequestUncheckedCreateWithoutUserInput> | ServiceRequestCreateWithoutUserInput[] | ServiceRequestUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ServiceRequestCreateOrConnectWithoutUserInput | ServiceRequestCreateOrConnectWithoutUserInput[]
    upsert?: ServiceRequestUpsertWithWhereUniqueWithoutUserInput | ServiceRequestUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ServiceRequestCreateManyUserInputEnvelope
    set?: ServiceRequestWhereUniqueInput | ServiceRequestWhereUniqueInput[]
    disconnect?: ServiceRequestWhereUniqueInput | ServiceRequestWhereUniqueInput[]
    delete?: ServiceRequestWhereUniqueInput | ServiceRequestWhereUniqueInput[]
    connect?: ServiceRequestWhereUniqueInput | ServiceRequestWhereUniqueInput[]
    update?: ServiceRequestUpdateWithWhereUniqueWithoutUserInput | ServiceRequestUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ServiceRequestUpdateManyWithWhereWithoutUserInput | ServiceRequestUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ServiceRequestScalarWhereInput | ServiceRequestScalarWhereInput[]
  }

  export type EmergencyContactUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<EmergencyContactCreateWithoutUserInput, EmergencyContactUncheckedCreateWithoutUserInput> | EmergencyContactCreateWithoutUserInput[] | EmergencyContactUncheckedCreateWithoutUserInput[]
    connectOrCreate?: EmergencyContactCreateOrConnectWithoutUserInput | EmergencyContactCreateOrConnectWithoutUserInput[]
    upsert?: EmergencyContactUpsertWithWhereUniqueWithoutUserInput | EmergencyContactUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: EmergencyContactCreateManyUserInputEnvelope
    set?: EmergencyContactWhereUniqueInput | EmergencyContactWhereUniqueInput[]
    disconnect?: EmergencyContactWhereUniqueInput | EmergencyContactWhereUniqueInput[]
    delete?: EmergencyContactWhereUniqueInput | EmergencyContactWhereUniqueInput[]
    connect?: EmergencyContactWhereUniqueInput | EmergencyContactWhereUniqueInput[]
    update?: EmergencyContactUpdateWithWhereUniqueWithoutUserInput | EmergencyContactUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: EmergencyContactUpdateManyWithWhereWithoutUserInput | EmergencyContactUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: EmergencyContactScalarWhereInput | EmergencyContactScalarWhereInput[]
  }

  export type MessageUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<MessageCreateWithoutUserInput, MessageUncheckedCreateWithoutUserInput> | MessageCreateWithoutUserInput[] | MessageUncheckedCreateWithoutUserInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutUserInput | MessageCreateOrConnectWithoutUserInput[]
    upsert?: MessageUpsertWithWhereUniqueWithoutUserInput | MessageUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: MessageCreateManyUserInputEnvelope
    set?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    disconnect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    delete?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    update?: MessageUpdateWithWhereUniqueWithoutUserInput | MessageUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: MessageUpdateManyWithWhereWithoutUserInput | MessageUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: MessageScalarWhereInput | MessageScalarWhereInput[]
  }

  export type SOSUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<SOSCreateWithoutUserInput, SOSUncheckedCreateWithoutUserInput> | SOSCreateWithoutUserInput[] | SOSUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SOSCreateOrConnectWithoutUserInput | SOSCreateOrConnectWithoutUserInput[]
    upsert?: SOSUpsertWithWhereUniqueWithoutUserInput | SOSUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: SOSCreateManyUserInputEnvelope
    set?: SOSWhereUniqueInput | SOSWhereUniqueInput[]
    disconnect?: SOSWhereUniqueInput | SOSWhereUniqueInput[]
    delete?: SOSWhereUniqueInput | SOSWhereUniqueInput[]
    connect?: SOSWhereUniqueInput | SOSWhereUniqueInput[]
    update?: SOSUpdateWithWhereUniqueWithoutUserInput | SOSUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: SOSUpdateManyWithWhereWithoutUserInput | SOSUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: SOSScalarWhereInput | SOSScalarWhereInput[]
  }

  export type MechanicCreateNestedOneWithoutMechanicConfirmationInput = {
    create?: XOR<MechanicCreateWithoutMechanicConfirmationInput, MechanicUncheckedCreateWithoutMechanicConfirmationInput>
    connectOrCreate?: MechanicCreateOrConnectWithoutMechanicConfirmationInput
    connect?: MechanicWhereUniqueInput
  }

  export type ServiceRequestCreateNestedOneWithoutConfirmationsInput = {
    create?: XOR<ServiceRequestCreateWithoutConfirmationsInput, ServiceRequestUncheckedCreateWithoutConfirmationsInput>
    connectOrCreate?: ServiceRequestCreateOrConnectWithoutConfirmationsInput
    connect?: ServiceRequestWhereUniqueInput
  }

  export type EnumConfirmationStatusFieldUpdateOperationsInput = {
    set?: $Enums.ConfirmationStatus
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type FloatFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
    unset?: boolean
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type MechanicUpdateOneRequiredWithoutMechanicConfirmationNestedInput = {
    create?: XOR<MechanicCreateWithoutMechanicConfirmationInput, MechanicUncheckedCreateWithoutMechanicConfirmationInput>
    connectOrCreate?: MechanicCreateOrConnectWithoutMechanicConfirmationInput
    upsert?: MechanicUpsertWithoutMechanicConfirmationInput
    connect?: MechanicWhereUniqueInput
    update?: XOR<XOR<MechanicUpdateToOneWithWhereWithoutMechanicConfirmationInput, MechanicUpdateWithoutMechanicConfirmationInput>, MechanicUncheckedUpdateWithoutMechanicConfirmationInput>
  }

  export type ServiceRequestUpdateOneRequiredWithoutConfirmationsNestedInput = {
    create?: XOR<ServiceRequestCreateWithoutConfirmationsInput, ServiceRequestUncheckedCreateWithoutConfirmationsInput>
    connectOrCreate?: ServiceRequestCreateOrConnectWithoutConfirmationsInput
    upsert?: ServiceRequestUpsertWithoutConfirmationsInput
    connect?: ServiceRequestWhereUniqueInput
    update?: XOR<XOR<ServiceRequestUpdateToOneWithWhereWithoutConfirmationsInput, ServiceRequestUpdateWithoutConfirmationsInput>, ServiceRequestUncheckedUpdateWithoutConfirmationsInput>
  }

  export type MechanicCreateservicesInput = {
    set: $Enums.ServiceType[]
  }

  export type ServiceRequestCreateNestedManyWithoutMechanicInput = {
    create?: XOR<ServiceRequestCreateWithoutMechanicInput, ServiceRequestUncheckedCreateWithoutMechanicInput> | ServiceRequestCreateWithoutMechanicInput[] | ServiceRequestUncheckedCreateWithoutMechanicInput[]
    connectOrCreate?: ServiceRequestCreateOrConnectWithoutMechanicInput | ServiceRequestCreateOrConnectWithoutMechanicInput[]
    createMany?: ServiceRequestCreateManyMechanicInputEnvelope
    connect?: ServiceRequestWhereUniqueInput | ServiceRequestWhereUniqueInput[]
  }

  export type ReviewCreateNestedManyWithoutMechanicInput = {
    create?: XOR<ReviewCreateWithoutMechanicInput, ReviewUncheckedCreateWithoutMechanicInput> | ReviewCreateWithoutMechanicInput[] | ReviewUncheckedCreateWithoutMechanicInput[]
    connectOrCreate?: ReviewCreateOrConnectWithoutMechanicInput | ReviewCreateOrConnectWithoutMechanicInput[]
    createMany?: ReviewCreateManyMechanicInputEnvelope
    connect?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
  }

  export type MessageCreateNestedManyWithoutMechanicInput = {
    create?: XOR<MessageCreateWithoutMechanicInput, MessageUncheckedCreateWithoutMechanicInput> | MessageCreateWithoutMechanicInput[] | MessageUncheckedCreateWithoutMechanicInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutMechanicInput | MessageCreateOrConnectWithoutMechanicInput[]
    createMany?: MessageCreateManyMechanicInputEnvelope
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
  }

  export type MechanicConfirmationCreateNestedManyWithoutMechanicInput = {
    create?: XOR<MechanicConfirmationCreateWithoutMechanicInput, MechanicConfirmationUncheckedCreateWithoutMechanicInput> | MechanicConfirmationCreateWithoutMechanicInput[] | MechanicConfirmationUncheckedCreateWithoutMechanicInput[]
    connectOrCreate?: MechanicConfirmationCreateOrConnectWithoutMechanicInput | MechanicConfirmationCreateOrConnectWithoutMechanicInput[]
    createMany?: MechanicConfirmationCreateManyMechanicInputEnvelope
    connect?: MechanicConfirmationWhereUniqueInput | MechanicConfirmationWhereUniqueInput[]
  }

  export type ServiceRequestUncheckedCreateNestedManyWithoutMechanicInput = {
    create?: XOR<ServiceRequestCreateWithoutMechanicInput, ServiceRequestUncheckedCreateWithoutMechanicInput> | ServiceRequestCreateWithoutMechanicInput[] | ServiceRequestUncheckedCreateWithoutMechanicInput[]
    connectOrCreate?: ServiceRequestCreateOrConnectWithoutMechanicInput | ServiceRequestCreateOrConnectWithoutMechanicInput[]
    createMany?: ServiceRequestCreateManyMechanicInputEnvelope
    connect?: ServiceRequestWhereUniqueInput | ServiceRequestWhereUniqueInput[]
  }

  export type ReviewUncheckedCreateNestedManyWithoutMechanicInput = {
    create?: XOR<ReviewCreateWithoutMechanicInput, ReviewUncheckedCreateWithoutMechanicInput> | ReviewCreateWithoutMechanicInput[] | ReviewUncheckedCreateWithoutMechanicInput[]
    connectOrCreate?: ReviewCreateOrConnectWithoutMechanicInput | ReviewCreateOrConnectWithoutMechanicInput[]
    createMany?: ReviewCreateManyMechanicInputEnvelope
    connect?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
  }

  export type MessageUncheckedCreateNestedManyWithoutMechanicInput = {
    create?: XOR<MessageCreateWithoutMechanicInput, MessageUncheckedCreateWithoutMechanicInput> | MessageCreateWithoutMechanicInput[] | MessageUncheckedCreateWithoutMechanicInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutMechanicInput | MessageCreateOrConnectWithoutMechanicInput[]
    createMany?: MessageCreateManyMechanicInputEnvelope
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
  }

  export type MechanicConfirmationUncheckedCreateNestedManyWithoutMechanicInput = {
    create?: XOR<MechanicConfirmationCreateWithoutMechanicInput, MechanicConfirmationUncheckedCreateWithoutMechanicInput> | MechanicConfirmationCreateWithoutMechanicInput[] | MechanicConfirmationUncheckedCreateWithoutMechanicInput[]
    connectOrCreate?: MechanicConfirmationCreateOrConnectWithoutMechanicInput | MechanicConfirmationCreateOrConnectWithoutMechanicInput[]
    createMany?: MechanicConfirmationCreateManyMechanicInputEnvelope
    connect?: MechanicConfirmationWhereUniqueInput | MechanicConfirmationWhereUniqueInput[]
  }

  export type MechanicUpdateservicesInput = {
    set?: $Enums.ServiceType[]
    push?: $Enums.ServiceType | $Enums.ServiceType[]
  }

  export type NullableFloatFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
    unset?: boolean
  }

  export type ServiceRequestUpdateManyWithoutMechanicNestedInput = {
    create?: XOR<ServiceRequestCreateWithoutMechanicInput, ServiceRequestUncheckedCreateWithoutMechanicInput> | ServiceRequestCreateWithoutMechanicInput[] | ServiceRequestUncheckedCreateWithoutMechanicInput[]
    connectOrCreate?: ServiceRequestCreateOrConnectWithoutMechanicInput | ServiceRequestCreateOrConnectWithoutMechanicInput[]
    upsert?: ServiceRequestUpsertWithWhereUniqueWithoutMechanicInput | ServiceRequestUpsertWithWhereUniqueWithoutMechanicInput[]
    createMany?: ServiceRequestCreateManyMechanicInputEnvelope
    set?: ServiceRequestWhereUniqueInput | ServiceRequestWhereUniqueInput[]
    disconnect?: ServiceRequestWhereUniqueInput | ServiceRequestWhereUniqueInput[]
    delete?: ServiceRequestWhereUniqueInput | ServiceRequestWhereUniqueInput[]
    connect?: ServiceRequestWhereUniqueInput | ServiceRequestWhereUniqueInput[]
    update?: ServiceRequestUpdateWithWhereUniqueWithoutMechanicInput | ServiceRequestUpdateWithWhereUniqueWithoutMechanicInput[]
    updateMany?: ServiceRequestUpdateManyWithWhereWithoutMechanicInput | ServiceRequestUpdateManyWithWhereWithoutMechanicInput[]
    deleteMany?: ServiceRequestScalarWhereInput | ServiceRequestScalarWhereInput[]
  }

  export type ReviewUpdateManyWithoutMechanicNestedInput = {
    create?: XOR<ReviewCreateWithoutMechanicInput, ReviewUncheckedCreateWithoutMechanicInput> | ReviewCreateWithoutMechanicInput[] | ReviewUncheckedCreateWithoutMechanicInput[]
    connectOrCreate?: ReviewCreateOrConnectWithoutMechanicInput | ReviewCreateOrConnectWithoutMechanicInput[]
    upsert?: ReviewUpsertWithWhereUniqueWithoutMechanicInput | ReviewUpsertWithWhereUniqueWithoutMechanicInput[]
    createMany?: ReviewCreateManyMechanicInputEnvelope
    set?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    disconnect?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    delete?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    connect?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    update?: ReviewUpdateWithWhereUniqueWithoutMechanicInput | ReviewUpdateWithWhereUniqueWithoutMechanicInput[]
    updateMany?: ReviewUpdateManyWithWhereWithoutMechanicInput | ReviewUpdateManyWithWhereWithoutMechanicInput[]
    deleteMany?: ReviewScalarWhereInput | ReviewScalarWhereInput[]
  }

  export type MessageUpdateManyWithoutMechanicNestedInput = {
    create?: XOR<MessageCreateWithoutMechanicInput, MessageUncheckedCreateWithoutMechanicInput> | MessageCreateWithoutMechanicInput[] | MessageUncheckedCreateWithoutMechanicInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutMechanicInput | MessageCreateOrConnectWithoutMechanicInput[]
    upsert?: MessageUpsertWithWhereUniqueWithoutMechanicInput | MessageUpsertWithWhereUniqueWithoutMechanicInput[]
    createMany?: MessageCreateManyMechanicInputEnvelope
    set?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    disconnect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    delete?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    update?: MessageUpdateWithWhereUniqueWithoutMechanicInput | MessageUpdateWithWhereUniqueWithoutMechanicInput[]
    updateMany?: MessageUpdateManyWithWhereWithoutMechanicInput | MessageUpdateManyWithWhereWithoutMechanicInput[]
    deleteMany?: MessageScalarWhereInput | MessageScalarWhereInput[]
  }

  export type MechanicConfirmationUpdateManyWithoutMechanicNestedInput = {
    create?: XOR<MechanicConfirmationCreateWithoutMechanicInput, MechanicConfirmationUncheckedCreateWithoutMechanicInput> | MechanicConfirmationCreateWithoutMechanicInput[] | MechanicConfirmationUncheckedCreateWithoutMechanicInput[]
    connectOrCreate?: MechanicConfirmationCreateOrConnectWithoutMechanicInput | MechanicConfirmationCreateOrConnectWithoutMechanicInput[]
    upsert?: MechanicConfirmationUpsertWithWhereUniqueWithoutMechanicInput | MechanicConfirmationUpsertWithWhereUniqueWithoutMechanicInput[]
    createMany?: MechanicConfirmationCreateManyMechanicInputEnvelope
    set?: MechanicConfirmationWhereUniqueInput | MechanicConfirmationWhereUniqueInput[]
    disconnect?: MechanicConfirmationWhereUniqueInput | MechanicConfirmationWhereUniqueInput[]
    delete?: MechanicConfirmationWhereUniqueInput | MechanicConfirmationWhereUniqueInput[]
    connect?: MechanicConfirmationWhereUniqueInput | MechanicConfirmationWhereUniqueInput[]
    update?: MechanicConfirmationUpdateWithWhereUniqueWithoutMechanicInput | MechanicConfirmationUpdateWithWhereUniqueWithoutMechanicInput[]
    updateMany?: MechanicConfirmationUpdateManyWithWhereWithoutMechanicInput | MechanicConfirmationUpdateManyWithWhereWithoutMechanicInput[]
    deleteMany?: MechanicConfirmationScalarWhereInput | MechanicConfirmationScalarWhereInput[]
  }

  export type ServiceRequestUncheckedUpdateManyWithoutMechanicNestedInput = {
    create?: XOR<ServiceRequestCreateWithoutMechanicInput, ServiceRequestUncheckedCreateWithoutMechanicInput> | ServiceRequestCreateWithoutMechanicInput[] | ServiceRequestUncheckedCreateWithoutMechanicInput[]
    connectOrCreate?: ServiceRequestCreateOrConnectWithoutMechanicInput | ServiceRequestCreateOrConnectWithoutMechanicInput[]
    upsert?: ServiceRequestUpsertWithWhereUniqueWithoutMechanicInput | ServiceRequestUpsertWithWhereUniqueWithoutMechanicInput[]
    createMany?: ServiceRequestCreateManyMechanicInputEnvelope
    set?: ServiceRequestWhereUniqueInput | ServiceRequestWhereUniqueInput[]
    disconnect?: ServiceRequestWhereUniqueInput | ServiceRequestWhereUniqueInput[]
    delete?: ServiceRequestWhereUniqueInput | ServiceRequestWhereUniqueInput[]
    connect?: ServiceRequestWhereUniqueInput | ServiceRequestWhereUniqueInput[]
    update?: ServiceRequestUpdateWithWhereUniqueWithoutMechanicInput | ServiceRequestUpdateWithWhereUniqueWithoutMechanicInput[]
    updateMany?: ServiceRequestUpdateManyWithWhereWithoutMechanicInput | ServiceRequestUpdateManyWithWhereWithoutMechanicInput[]
    deleteMany?: ServiceRequestScalarWhereInput | ServiceRequestScalarWhereInput[]
  }

  export type ReviewUncheckedUpdateManyWithoutMechanicNestedInput = {
    create?: XOR<ReviewCreateWithoutMechanicInput, ReviewUncheckedCreateWithoutMechanicInput> | ReviewCreateWithoutMechanicInput[] | ReviewUncheckedCreateWithoutMechanicInput[]
    connectOrCreate?: ReviewCreateOrConnectWithoutMechanicInput | ReviewCreateOrConnectWithoutMechanicInput[]
    upsert?: ReviewUpsertWithWhereUniqueWithoutMechanicInput | ReviewUpsertWithWhereUniqueWithoutMechanicInput[]
    createMany?: ReviewCreateManyMechanicInputEnvelope
    set?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    disconnect?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    delete?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    connect?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    update?: ReviewUpdateWithWhereUniqueWithoutMechanicInput | ReviewUpdateWithWhereUniqueWithoutMechanicInput[]
    updateMany?: ReviewUpdateManyWithWhereWithoutMechanicInput | ReviewUpdateManyWithWhereWithoutMechanicInput[]
    deleteMany?: ReviewScalarWhereInput | ReviewScalarWhereInput[]
  }

  export type MessageUncheckedUpdateManyWithoutMechanicNestedInput = {
    create?: XOR<MessageCreateWithoutMechanicInput, MessageUncheckedCreateWithoutMechanicInput> | MessageCreateWithoutMechanicInput[] | MessageUncheckedCreateWithoutMechanicInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutMechanicInput | MessageCreateOrConnectWithoutMechanicInput[]
    upsert?: MessageUpsertWithWhereUniqueWithoutMechanicInput | MessageUpsertWithWhereUniqueWithoutMechanicInput[]
    createMany?: MessageCreateManyMechanicInputEnvelope
    set?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    disconnect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    delete?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    update?: MessageUpdateWithWhereUniqueWithoutMechanicInput | MessageUpdateWithWhereUniqueWithoutMechanicInput[]
    updateMany?: MessageUpdateManyWithWhereWithoutMechanicInput | MessageUpdateManyWithWhereWithoutMechanicInput[]
    deleteMany?: MessageScalarWhereInput | MessageScalarWhereInput[]
  }

  export type MechanicConfirmationUncheckedUpdateManyWithoutMechanicNestedInput = {
    create?: XOR<MechanicConfirmationCreateWithoutMechanicInput, MechanicConfirmationUncheckedCreateWithoutMechanicInput> | MechanicConfirmationCreateWithoutMechanicInput[] | MechanicConfirmationUncheckedCreateWithoutMechanicInput[]
    connectOrCreate?: MechanicConfirmationCreateOrConnectWithoutMechanicInput | MechanicConfirmationCreateOrConnectWithoutMechanicInput[]
    upsert?: MechanicConfirmationUpsertWithWhereUniqueWithoutMechanicInput | MechanicConfirmationUpsertWithWhereUniqueWithoutMechanicInput[]
    createMany?: MechanicConfirmationCreateManyMechanicInputEnvelope
    set?: MechanicConfirmationWhereUniqueInput | MechanicConfirmationWhereUniqueInput[]
    disconnect?: MechanicConfirmationWhereUniqueInput | MechanicConfirmationWhereUniqueInput[]
    delete?: MechanicConfirmationWhereUniqueInput | MechanicConfirmationWhereUniqueInput[]
    connect?: MechanicConfirmationWhereUniqueInput | MechanicConfirmationWhereUniqueInput[]
    update?: MechanicConfirmationUpdateWithWhereUniqueWithoutMechanicInput | MechanicConfirmationUpdateWithWhereUniqueWithoutMechanicInput[]
    updateMany?: MechanicConfirmationUpdateManyWithWhereWithoutMechanicInput | MechanicConfirmationUpdateManyWithWhereWithoutMechanicInput[]
    deleteMany?: MechanicConfirmationScalarWhereInput | MechanicConfirmationScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutCarsInput = {
    create?: XOR<UserCreateWithoutCarsInput, UserUncheckedCreateWithoutCarsInput>
    connectOrCreate?: UserCreateOrConnectWithoutCarsInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutCarsNestedInput = {
    create?: XOR<UserCreateWithoutCarsInput, UserUncheckedCreateWithoutCarsInput>
    connectOrCreate?: UserCreateOrConnectWithoutCarsInput
    upsert?: UserUpsertWithoutCarsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutCarsInput, UserUpdateWithoutCarsInput>, UserUncheckedUpdateWithoutCarsInput>
  }

  export type UserCreateNestedOneWithoutServiceRequestsInput = {
    create?: XOR<UserCreateWithoutServiceRequestsInput, UserUncheckedCreateWithoutServiceRequestsInput>
    connectOrCreate?: UserCreateOrConnectWithoutServiceRequestsInput
    connect?: UserWhereUniqueInput
  }

  export type MechanicCreateNestedOneWithoutServiceRequestsInput = {
    create?: XOR<MechanicCreateWithoutServiceRequestsInput, MechanicUncheckedCreateWithoutServiceRequestsInput>
    connectOrCreate?: MechanicCreateOrConnectWithoutServiceRequestsInput
    connect?: MechanicWhereUniqueInput
  }

  export type PaymentCreateNestedOneWithoutServiceRequestInput = {
    create?: XOR<PaymentCreateWithoutServiceRequestInput, PaymentUncheckedCreateWithoutServiceRequestInput>
    connectOrCreate?: PaymentCreateOrConnectWithoutServiceRequestInput
    connect?: PaymentWhereUniqueInput
  }

  export type ChatCreateNestedOneWithoutServiceRequestInput = {
    create?: XOR<ChatCreateWithoutServiceRequestInput, ChatUncheckedCreateWithoutServiceRequestInput>
    connectOrCreate?: ChatCreateOrConnectWithoutServiceRequestInput
    connect?: ChatWhereUniqueInput
  }

  export type MechanicConfirmationCreateNestedManyWithoutServiceRequestInput = {
    create?: XOR<MechanicConfirmationCreateWithoutServiceRequestInput, MechanicConfirmationUncheckedCreateWithoutServiceRequestInput> | MechanicConfirmationCreateWithoutServiceRequestInput[] | MechanicConfirmationUncheckedCreateWithoutServiceRequestInput[]
    connectOrCreate?: MechanicConfirmationCreateOrConnectWithoutServiceRequestInput | MechanicConfirmationCreateOrConnectWithoutServiceRequestInput[]
    createMany?: MechanicConfirmationCreateManyServiceRequestInputEnvelope
    connect?: MechanicConfirmationWhereUniqueInput | MechanicConfirmationWhereUniqueInput[]
  }

  export type ReviewCreateNestedManyWithoutServiceRequestInput = {
    create?: XOR<ReviewCreateWithoutServiceRequestInput, ReviewUncheckedCreateWithoutServiceRequestInput> | ReviewCreateWithoutServiceRequestInput[] | ReviewUncheckedCreateWithoutServiceRequestInput[]
    connectOrCreate?: ReviewCreateOrConnectWithoutServiceRequestInput | ReviewCreateOrConnectWithoutServiceRequestInput[]
    createMany?: ReviewCreateManyServiceRequestInputEnvelope
    connect?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
  }

  export type PaymentUncheckedCreateNestedOneWithoutServiceRequestInput = {
    create?: XOR<PaymentCreateWithoutServiceRequestInput, PaymentUncheckedCreateWithoutServiceRequestInput>
    connectOrCreate?: PaymentCreateOrConnectWithoutServiceRequestInput
    connect?: PaymentWhereUniqueInput
  }

  export type ChatUncheckedCreateNestedOneWithoutServiceRequestInput = {
    create?: XOR<ChatCreateWithoutServiceRequestInput, ChatUncheckedCreateWithoutServiceRequestInput>
    connectOrCreate?: ChatCreateOrConnectWithoutServiceRequestInput
    connect?: ChatWhereUniqueInput
  }

  export type MechanicConfirmationUncheckedCreateNestedManyWithoutServiceRequestInput = {
    create?: XOR<MechanicConfirmationCreateWithoutServiceRequestInput, MechanicConfirmationUncheckedCreateWithoutServiceRequestInput> | MechanicConfirmationCreateWithoutServiceRequestInput[] | MechanicConfirmationUncheckedCreateWithoutServiceRequestInput[]
    connectOrCreate?: MechanicConfirmationCreateOrConnectWithoutServiceRequestInput | MechanicConfirmationCreateOrConnectWithoutServiceRequestInput[]
    createMany?: MechanicConfirmationCreateManyServiceRequestInputEnvelope
    connect?: MechanicConfirmationWhereUniqueInput | MechanicConfirmationWhereUniqueInput[]
  }

  export type ReviewUncheckedCreateNestedManyWithoutServiceRequestInput = {
    create?: XOR<ReviewCreateWithoutServiceRequestInput, ReviewUncheckedCreateWithoutServiceRequestInput> | ReviewCreateWithoutServiceRequestInput[] | ReviewUncheckedCreateWithoutServiceRequestInput[]
    connectOrCreate?: ReviewCreateOrConnectWithoutServiceRequestInput | ReviewCreateOrConnectWithoutServiceRequestInput[]
    createMany?: ReviewCreateManyServiceRequestInputEnvelope
    connect?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
  }

  export type EnumServiceTypeFieldUpdateOperationsInput = {
    set?: $Enums.ServiceType
  }

  export type EnumServiceStatusFieldUpdateOperationsInput = {
    set?: $Enums.ServiceStatus
  }

  export type UserUpdateOneRequiredWithoutServiceRequestsNestedInput = {
    create?: XOR<UserCreateWithoutServiceRequestsInput, UserUncheckedCreateWithoutServiceRequestsInput>
    connectOrCreate?: UserCreateOrConnectWithoutServiceRequestsInput
    upsert?: UserUpsertWithoutServiceRequestsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutServiceRequestsInput, UserUpdateWithoutServiceRequestsInput>, UserUncheckedUpdateWithoutServiceRequestsInput>
  }

  export type MechanicUpdateOneWithoutServiceRequestsNestedInput = {
    create?: XOR<MechanicCreateWithoutServiceRequestsInput, MechanicUncheckedCreateWithoutServiceRequestsInput>
    connectOrCreate?: MechanicCreateOrConnectWithoutServiceRequestsInput
    upsert?: MechanicUpsertWithoutServiceRequestsInput
    disconnect?: boolean
    delete?: MechanicWhereInput | boolean
    connect?: MechanicWhereUniqueInput
    update?: XOR<XOR<MechanicUpdateToOneWithWhereWithoutServiceRequestsInput, MechanicUpdateWithoutServiceRequestsInput>, MechanicUncheckedUpdateWithoutServiceRequestsInput>
  }

  export type PaymentUpdateOneWithoutServiceRequestNestedInput = {
    create?: XOR<PaymentCreateWithoutServiceRequestInput, PaymentUncheckedCreateWithoutServiceRequestInput>
    connectOrCreate?: PaymentCreateOrConnectWithoutServiceRequestInput
    upsert?: PaymentUpsertWithoutServiceRequestInput
    disconnect?: PaymentWhereInput | boolean
    delete?: PaymentWhereInput | boolean
    connect?: PaymentWhereUniqueInput
    update?: XOR<XOR<PaymentUpdateToOneWithWhereWithoutServiceRequestInput, PaymentUpdateWithoutServiceRequestInput>, PaymentUncheckedUpdateWithoutServiceRequestInput>
  }

  export type ChatUpdateOneWithoutServiceRequestNestedInput = {
    create?: XOR<ChatCreateWithoutServiceRequestInput, ChatUncheckedCreateWithoutServiceRequestInput>
    connectOrCreate?: ChatCreateOrConnectWithoutServiceRequestInput
    upsert?: ChatUpsertWithoutServiceRequestInput
    disconnect?: ChatWhereInput | boolean
    delete?: ChatWhereInput | boolean
    connect?: ChatWhereUniqueInput
    update?: XOR<XOR<ChatUpdateToOneWithWhereWithoutServiceRequestInput, ChatUpdateWithoutServiceRequestInput>, ChatUncheckedUpdateWithoutServiceRequestInput>
  }

  export type MechanicConfirmationUpdateManyWithoutServiceRequestNestedInput = {
    create?: XOR<MechanicConfirmationCreateWithoutServiceRequestInput, MechanicConfirmationUncheckedCreateWithoutServiceRequestInput> | MechanicConfirmationCreateWithoutServiceRequestInput[] | MechanicConfirmationUncheckedCreateWithoutServiceRequestInput[]
    connectOrCreate?: MechanicConfirmationCreateOrConnectWithoutServiceRequestInput | MechanicConfirmationCreateOrConnectWithoutServiceRequestInput[]
    upsert?: MechanicConfirmationUpsertWithWhereUniqueWithoutServiceRequestInput | MechanicConfirmationUpsertWithWhereUniqueWithoutServiceRequestInput[]
    createMany?: MechanicConfirmationCreateManyServiceRequestInputEnvelope
    set?: MechanicConfirmationWhereUniqueInput | MechanicConfirmationWhereUniqueInput[]
    disconnect?: MechanicConfirmationWhereUniqueInput | MechanicConfirmationWhereUniqueInput[]
    delete?: MechanicConfirmationWhereUniqueInput | MechanicConfirmationWhereUniqueInput[]
    connect?: MechanicConfirmationWhereUniqueInput | MechanicConfirmationWhereUniqueInput[]
    update?: MechanicConfirmationUpdateWithWhereUniqueWithoutServiceRequestInput | MechanicConfirmationUpdateWithWhereUniqueWithoutServiceRequestInput[]
    updateMany?: MechanicConfirmationUpdateManyWithWhereWithoutServiceRequestInput | MechanicConfirmationUpdateManyWithWhereWithoutServiceRequestInput[]
    deleteMany?: MechanicConfirmationScalarWhereInput | MechanicConfirmationScalarWhereInput[]
  }

  export type ReviewUpdateManyWithoutServiceRequestNestedInput = {
    create?: XOR<ReviewCreateWithoutServiceRequestInput, ReviewUncheckedCreateWithoutServiceRequestInput> | ReviewCreateWithoutServiceRequestInput[] | ReviewUncheckedCreateWithoutServiceRequestInput[]
    connectOrCreate?: ReviewCreateOrConnectWithoutServiceRequestInput | ReviewCreateOrConnectWithoutServiceRequestInput[]
    upsert?: ReviewUpsertWithWhereUniqueWithoutServiceRequestInput | ReviewUpsertWithWhereUniqueWithoutServiceRequestInput[]
    createMany?: ReviewCreateManyServiceRequestInputEnvelope
    set?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    disconnect?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    delete?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    connect?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    update?: ReviewUpdateWithWhereUniqueWithoutServiceRequestInput | ReviewUpdateWithWhereUniqueWithoutServiceRequestInput[]
    updateMany?: ReviewUpdateManyWithWhereWithoutServiceRequestInput | ReviewUpdateManyWithWhereWithoutServiceRequestInput[]
    deleteMany?: ReviewScalarWhereInput | ReviewScalarWhereInput[]
  }

  export type PaymentUncheckedUpdateOneWithoutServiceRequestNestedInput = {
    create?: XOR<PaymentCreateWithoutServiceRequestInput, PaymentUncheckedCreateWithoutServiceRequestInput>
    connectOrCreate?: PaymentCreateOrConnectWithoutServiceRequestInput
    upsert?: PaymentUpsertWithoutServiceRequestInput
    disconnect?: PaymentWhereInput | boolean
    delete?: PaymentWhereInput | boolean
    connect?: PaymentWhereUniqueInput
    update?: XOR<XOR<PaymentUpdateToOneWithWhereWithoutServiceRequestInput, PaymentUpdateWithoutServiceRequestInput>, PaymentUncheckedUpdateWithoutServiceRequestInput>
  }

  export type ChatUncheckedUpdateOneWithoutServiceRequestNestedInput = {
    create?: XOR<ChatCreateWithoutServiceRequestInput, ChatUncheckedCreateWithoutServiceRequestInput>
    connectOrCreate?: ChatCreateOrConnectWithoutServiceRequestInput
    upsert?: ChatUpsertWithoutServiceRequestInput
    disconnect?: ChatWhereInput | boolean
    delete?: ChatWhereInput | boolean
    connect?: ChatWhereUniqueInput
    update?: XOR<XOR<ChatUpdateToOneWithWhereWithoutServiceRequestInput, ChatUpdateWithoutServiceRequestInput>, ChatUncheckedUpdateWithoutServiceRequestInput>
  }

  export type MechanicConfirmationUncheckedUpdateManyWithoutServiceRequestNestedInput = {
    create?: XOR<MechanicConfirmationCreateWithoutServiceRequestInput, MechanicConfirmationUncheckedCreateWithoutServiceRequestInput> | MechanicConfirmationCreateWithoutServiceRequestInput[] | MechanicConfirmationUncheckedCreateWithoutServiceRequestInput[]
    connectOrCreate?: MechanicConfirmationCreateOrConnectWithoutServiceRequestInput | MechanicConfirmationCreateOrConnectWithoutServiceRequestInput[]
    upsert?: MechanicConfirmationUpsertWithWhereUniqueWithoutServiceRequestInput | MechanicConfirmationUpsertWithWhereUniqueWithoutServiceRequestInput[]
    createMany?: MechanicConfirmationCreateManyServiceRequestInputEnvelope
    set?: MechanicConfirmationWhereUniqueInput | MechanicConfirmationWhereUniqueInput[]
    disconnect?: MechanicConfirmationWhereUniqueInput | MechanicConfirmationWhereUniqueInput[]
    delete?: MechanicConfirmationWhereUniqueInput | MechanicConfirmationWhereUniqueInput[]
    connect?: MechanicConfirmationWhereUniqueInput | MechanicConfirmationWhereUniqueInput[]
    update?: MechanicConfirmationUpdateWithWhereUniqueWithoutServiceRequestInput | MechanicConfirmationUpdateWithWhereUniqueWithoutServiceRequestInput[]
    updateMany?: MechanicConfirmationUpdateManyWithWhereWithoutServiceRequestInput | MechanicConfirmationUpdateManyWithWhereWithoutServiceRequestInput[]
    deleteMany?: MechanicConfirmationScalarWhereInput | MechanicConfirmationScalarWhereInput[]
  }

  export type ReviewUncheckedUpdateManyWithoutServiceRequestNestedInput = {
    create?: XOR<ReviewCreateWithoutServiceRequestInput, ReviewUncheckedCreateWithoutServiceRequestInput> | ReviewCreateWithoutServiceRequestInput[] | ReviewUncheckedCreateWithoutServiceRequestInput[]
    connectOrCreate?: ReviewCreateOrConnectWithoutServiceRequestInput | ReviewCreateOrConnectWithoutServiceRequestInput[]
    upsert?: ReviewUpsertWithWhereUniqueWithoutServiceRequestInput | ReviewUpsertWithWhereUniqueWithoutServiceRequestInput[]
    createMany?: ReviewCreateManyServiceRequestInputEnvelope
    set?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    disconnect?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    delete?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    connect?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    update?: ReviewUpdateWithWhereUniqueWithoutServiceRequestInput | ReviewUpdateWithWhereUniqueWithoutServiceRequestInput[]
    updateMany?: ReviewUpdateManyWithWhereWithoutServiceRequestInput | ReviewUpdateManyWithWhereWithoutServiceRequestInput[]
    deleteMany?: ReviewScalarWhereInput | ReviewScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutEmergencyContactsInput = {
    create?: XOR<UserCreateWithoutEmergencyContactsInput, UserUncheckedCreateWithoutEmergencyContactsInput>
    connectOrCreate?: UserCreateOrConnectWithoutEmergencyContactsInput
    connect?: UserWhereUniqueInput
  }

  export type SOSCreateNestedManyWithoutEmergencyContactInput = {
    create?: XOR<SOSCreateWithoutEmergencyContactInput, SOSUncheckedCreateWithoutEmergencyContactInput> | SOSCreateWithoutEmergencyContactInput[] | SOSUncheckedCreateWithoutEmergencyContactInput[]
    connectOrCreate?: SOSCreateOrConnectWithoutEmergencyContactInput | SOSCreateOrConnectWithoutEmergencyContactInput[]
    createMany?: SOSCreateManyEmergencyContactInputEnvelope
    connect?: SOSWhereUniqueInput | SOSWhereUniqueInput[]
  }

  export type SOSUncheckedCreateNestedManyWithoutEmergencyContactInput = {
    create?: XOR<SOSCreateWithoutEmergencyContactInput, SOSUncheckedCreateWithoutEmergencyContactInput> | SOSCreateWithoutEmergencyContactInput[] | SOSUncheckedCreateWithoutEmergencyContactInput[]
    connectOrCreate?: SOSCreateOrConnectWithoutEmergencyContactInput | SOSCreateOrConnectWithoutEmergencyContactInput[]
    createMany?: SOSCreateManyEmergencyContactInputEnvelope
    connect?: SOSWhereUniqueInput | SOSWhereUniqueInput[]
  }

  export type UserUpdateOneRequiredWithoutEmergencyContactsNestedInput = {
    create?: XOR<UserCreateWithoutEmergencyContactsInput, UserUncheckedCreateWithoutEmergencyContactsInput>
    connectOrCreate?: UserCreateOrConnectWithoutEmergencyContactsInput
    upsert?: UserUpsertWithoutEmergencyContactsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutEmergencyContactsInput, UserUpdateWithoutEmergencyContactsInput>, UserUncheckedUpdateWithoutEmergencyContactsInput>
  }

  export type SOSUpdateManyWithoutEmergencyContactNestedInput = {
    create?: XOR<SOSCreateWithoutEmergencyContactInput, SOSUncheckedCreateWithoutEmergencyContactInput> | SOSCreateWithoutEmergencyContactInput[] | SOSUncheckedCreateWithoutEmergencyContactInput[]
    connectOrCreate?: SOSCreateOrConnectWithoutEmergencyContactInput | SOSCreateOrConnectWithoutEmergencyContactInput[]
    upsert?: SOSUpsertWithWhereUniqueWithoutEmergencyContactInput | SOSUpsertWithWhereUniqueWithoutEmergencyContactInput[]
    createMany?: SOSCreateManyEmergencyContactInputEnvelope
    set?: SOSWhereUniqueInput | SOSWhereUniqueInput[]
    disconnect?: SOSWhereUniqueInput | SOSWhereUniqueInput[]
    delete?: SOSWhereUniqueInput | SOSWhereUniqueInput[]
    connect?: SOSWhereUniqueInput | SOSWhereUniqueInput[]
    update?: SOSUpdateWithWhereUniqueWithoutEmergencyContactInput | SOSUpdateWithWhereUniqueWithoutEmergencyContactInput[]
    updateMany?: SOSUpdateManyWithWhereWithoutEmergencyContactInput | SOSUpdateManyWithWhereWithoutEmergencyContactInput[]
    deleteMany?: SOSScalarWhereInput | SOSScalarWhereInput[]
  }

  export type SOSUncheckedUpdateManyWithoutEmergencyContactNestedInput = {
    create?: XOR<SOSCreateWithoutEmergencyContactInput, SOSUncheckedCreateWithoutEmergencyContactInput> | SOSCreateWithoutEmergencyContactInput[] | SOSUncheckedCreateWithoutEmergencyContactInput[]
    connectOrCreate?: SOSCreateOrConnectWithoutEmergencyContactInput | SOSCreateOrConnectWithoutEmergencyContactInput[]
    upsert?: SOSUpsertWithWhereUniqueWithoutEmergencyContactInput | SOSUpsertWithWhereUniqueWithoutEmergencyContactInput[]
    createMany?: SOSCreateManyEmergencyContactInputEnvelope
    set?: SOSWhereUniqueInput | SOSWhereUniqueInput[]
    disconnect?: SOSWhereUniqueInput | SOSWhereUniqueInput[]
    delete?: SOSWhereUniqueInput | SOSWhereUniqueInput[]
    connect?: SOSWhereUniqueInput | SOSWhereUniqueInput[]
    update?: SOSUpdateWithWhereUniqueWithoutEmergencyContactInput | SOSUpdateWithWhereUniqueWithoutEmergencyContactInput[]
    updateMany?: SOSUpdateManyWithWhereWithoutEmergencyContactInput | SOSUpdateManyWithWhereWithoutEmergencyContactInput[]
    deleteMany?: SOSScalarWhereInput | SOSScalarWhereInput[]
  }

  export type ServiceRequestCreateNestedOneWithoutReviewsInput = {
    create?: XOR<ServiceRequestCreateWithoutReviewsInput, ServiceRequestUncheckedCreateWithoutReviewsInput>
    connectOrCreate?: ServiceRequestCreateOrConnectWithoutReviewsInput
    connect?: ServiceRequestWhereUniqueInput
  }

  export type MechanicCreateNestedOneWithoutReviewsInput = {
    create?: XOR<MechanicCreateWithoutReviewsInput, MechanicUncheckedCreateWithoutReviewsInput>
    connectOrCreate?: MechanicCreateOrConnectWithoutReviewsInput
    connect?: MechanicWhereUniqueInput
  }

  export type EnumSenderTypeFieldUpdateOperationsInput = {
    set?: $Enums.SenderType
  }

  export type ServiceRequestUpdateOneRequiredWithoutReviewsNestedInput = {
    create?: XOR<ServiceRequestCreateWithoutReviewsInput, ServiceRequestUncheckedCreateWithoutReviewsInput>
    connectOrCreate?: ServiceRequestCreateOrConnectWithoutReviewsInput
    upsert?: ServiceRequestUpsertWithoutReviewsInput
    connect?: ServiceRequestWhereUniqueInput
    update?: XOR<XOR<ServiceRequestUpdateToOneWithWhereWithoutReviewsInput, ServiceRequestUpdateWithoutReviewsInput>, ServiceRequestUncheckedUpdateWithoutReviewsInput>
  }

  export type MechanicUpdateOneWithoutReviewsNestedInput = {
    create?: XOR<MechanicCreateWithoutReviewsInput, MechanicUncheckedCreateWithoutReviewsInput>
    connectOrCreate?: MechanicCreateOrConnectWithoutReviewsInput
    upsert?: MechanicUpsertWithoutReviewsInput
    disconnect?: boolean
    delete?: MechanicWhereInput | boolean
    connect?: MechanicWhereUniqueInput
    update?: XOR<XOR<MechanicUpdateToOneWithWhereWithoutReviewsInput, MechanicUpdateWithoutReviewsInput>, MechanicUncheckedUpdateWithoutReviewsInput>
  }

  export type ServiceRequestCreateNestedOneWithoutPaymentInput = {
    create?: XOR<ServiceRequestCreateWithoutPaymentInput, ServiceRequestUncheckedCreateWithoutPaymentInput>
    connectOrCreate?: ServiceRequestCreateOrConnectWithoutPaymentInput
    connect?: ServiceRequestWhereUniqueInput
  }

  export type EnumPaymentStatusFieldUpdateOperationsInput = {
    set?: $Enums.PaymentStatus
  }

  export type ServiceRequestUpdateOneRequiredWithoutPaymentNestedInput = {
    create?: XOR<ServiceRequestCreateWithoutPaymentInput, ServiceRequestUncheckedCreateWithoutPaymentInput>
    connectOrCreate?: ServiceRequestCreateOrConnectWithoutPaymentInput
    upsert?: ServiceRequestUpsertWithoutPaymentInput
    connect?: ServiceRequestWhereUniqueInput
    update?: XOR<XOR<ServiceRequestUpdateToOneWithWhereWithoutPaymentInput, ServiceRequestUpdateWithoutPaymentInput>, ServiceRequestUncheckedUpdateWithoutPaymentInput>
  }

  export type ServiceRequestCreateNestedOneWithoutChatInput = {
    create?: XOR<ServiceRequestCreateWithoutChatInput, ServiceRequestUncheckedCreateWithoutChatInput>
    connectOrCreate?: ServiceRequestCreateOrConnectWithoutChatInput
    connect?: ServiceRequestWhereUniqueInput
  }

  export type MessageCreateNestedManyWithoutChatInput = {
    create?: XOR<MessageCreateWithoutChatInput, MessageUncheckedCreateWithoutChatInput> | MessageCreateWithoutChatInput[] | MessageUncheckedCreateWithoutChatInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutChatInput | MessageCreateOrConnectWithoutChatInput[]
    createMany?: MessageCreateManyChatInputEnvelope
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
  }

  export type MessageUncheckedCreateNestedManyWithoutChatInput = {
    create?: XOR<MessageCreateWithoutChatInput, MessageUncheckedCreateWithoutChatInput> | MessageCreateWithoutChatInput[] | MessageUncheckedCreateWithoutChatInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutChatInput | MessageCreateOrConnectWithoutChatInput[]
    createMany?: MessageCreateManyChatInputEnvelope
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
  }

  export type ServiceRequestUpdateOneRequiredWithoutChatNestedInput = {
    create?: XOR<ServiceRequestCreateWithoutChatInput, ServiceRequestUncheckedCreateWithoutChatInput>
    connectOrCreate?: ServiceRequestCreateOrConnectWithoutChatInput
    upsert?: ServiceRequestUpsertWithoutChatInput
    connect?: ServiceRequestWhereUniqueInput
    update?: XOR<XOR<ServiceRequestUpdateToOneWithWhereWithoutChatInput, ServiceRequestUpdateWithoutChatInput>, ServiceRequestUncheckedUpdateWithoutChatInput>
  }

  export type MessageUpdateManyWithoutChatNestedInput = {
    create?: XOR<MessageCreateWithoutChatInput, MessageUncheckedCreateWithoutChatInput> | MessageCreateWithoutChatInput[] | MessageUncheckedCreateWithoutChatInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutChatInput | MessageCreateOrConnectWithoutChatInput[]
    upsert?: MessageUpsertWithWhereUniqueWithoutChatInput | MessageUpsertWithWhereUniqueWithoutChatInput[]
    createMany?: MessageCreateManyChatInputEnvelope
    set?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    disconnect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    delete?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    update?: MessageUpdateWithWhereUniqueWithoutChatInput | MessageUpdateWithWhereUniqueWithoutChatInput[]
    updateMany?: MessageUpdateManyWithWhereWithoutChatInput | MessageUpdateManyWithWhereWithoutChatInput[]
    deleteMany?: MessageScalarWhereInput | MessageScalarWhereInput[]
  }

  export type MessageUncheckedUpdateManyWithoutChatNestedInput = {
    create?: XOR<MessageCreateWithoutChatInput, MessageUncheckedCreateWithoutChatInput> | MessageCreateWithoutChatInput[] | MessageUncheckedCreateWithoutChatInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutChatInput | MessageCreateOrConnectWithoutChatInput[]
    upsert?: MessageUpsertWithWhereUniqueWithoutChatInput | MessageUpsertWithWhereUniqueWithoutChatInput[]
    createMany?: MessageCreateManyChatInputEnvelope
    set?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    disconnect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    delete?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    update?: MessageUpdateWithWhereUniqueWithoutChatInput | MessageUpdateWithWhereUniqueWithoutChatInput[]
    updateMany?: MessageUpdateManyWithWhereWithoutChatInput | MessageUpdateManyWithWhereWithoutChatInput[]
    deleteMany?: MessageScalarWhereInput | MessageScalarWhereInput[]
  }

  export type ChatCreateNestedOneWithoutMessagesInput = {
    create?: XOR<ChatCreateWithoutMessagesInput, ChatUncheckedCreateWithoutMessagesInput>
    connectOrCreate?: ChatCreateOrConnectWithoutMessagesInput
    connect?: ChatWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutSentMessagesInput = {
    create?: XOR<UserCreateWithoutSentMessagesInput, UserUncheckedCreateWithoutSentMessagesInput>
    connectOrCreate?: UserCreateOrConnectWithoutSentMessagesInput
    connect?: UserWhereUniqueInput
  }

  export type MechanicCreateNestedOneWithoutSentMessagesInput = {
    create?: XOR<MechanicCreateWithoutSentMessagesInput, MechanicUncheckedCreateWithoutSentMessagesInput>
    connectOrCreate?: MechanicCreateOrConnectWithoutSentMessagesInput
    connect?: MechanicWhereUniqueInput
  }

  export type ChatUpdateOneRequiredWithoutMessagesNestedInput = {
    create?: XOR<ChatCreateWithoutMessagesInput, ChatUncheckedCreateWithoutMessagesInput>
    connectOrCreate?: ChatCreateOrConnectWithoutMessagesInput
    upsert?: ChatUpsertWithoutMessagesInput
    connect?: ChatWhereUniqueInput
    update?: XOR<XOR<ChatUpdateToOneWithWhereWithoutMessagesInput, ChatUpdateWithoutMessagesInput>, ChatUncheckedUpdateWithoutMessagesInput>
  }

  export type UserUpdateOneWithoutSentMessagesNestedInput = {
    create?: XOR<UserCreateWithoutSentMessagesInput, UserUncheckedCreateWithoutSentMessagesInput>
    connectOrCreate?: UserCreateOrConnectWithoutSentMessagesInput
    upsert?: UserUpsertWithoutSentMessagesInput
    disconnect?: boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutSentMessagesInput, UserUpdateWithoutSentMessagesInput>, UserUncheckedUpdateWithoutSentMessagesInput>
  }

  export type MechanicUpdateOneWithoutSentMessagesNestedInput = {
    create?: XOR<MechanicCreateWithoutSentMessagesInput, MechanicUncheckedCreateWithoutSentMessagesInput>
    connectOrCreate?: MechanicCreateOrConnectWithoutSentMessagesInput
    upsert?: MechanicUpsertWithoutSentMessagesInput
    disconnect?: boolean
    delete?: MechanicWhereInput | boolean
    connect?: MechanicWhereUniqueInput
    update?: XOR<XOR<MechanicUpdateToOneWithWhereWithoutSentMessagesInput, MechanicUpdateWithoutSentMessagesInput>, MechanicUncheckedUpdateWithoutSentMessagesInput>
  }

  export type UserCreateNestedOneWithoutSosEventsInput = {
    create?: XOR<UserCreateWithoutSosEventsInput, UserUncheckedCreateWithoutSosEventsInput>
    connectOrCreate?: UserCreateOrConnectWithoutSosEventsInput
    connect?: UserWhereUniqueInput
  }

  export type EmergencyContactCreateNestedOneWithoutSosEventsInput = {
    create?: XOR<EmergencyContactCreateWithoutSosEventsInput, EmergencyContactUncheckedCreateWithoutSosEventsInput>
    connectOrCreate?: EmergencyContactCreateOrConnectWithoutSosEventsInput
    connect?: EmergencyContactWhereUniqueInput
  }

  export type EnumSOSStatusFieldUpdateOperationsInput = {
    set?: $Enums.SOSStatus
  }

  export type UserUpdateOneRequiredWithoutSosEventsNestedInput = {
    create?: XOR<UserCreateWithoutSosEventsInput, UserUncheckedCreateWithoutSosEventsInput>
    connectOrCreate?: UserCreateOrConnectWithoutSosEventsInput
    upsert?: UserUpsertWithoutSosEventsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutSosEventsInput, UserUpdateWithoutSosEventsInput>, UserUncheckedUpdateWithoutSosEventsInput>
  }

  export type EmergencyContactUpdateOneWithoutSosEventsNestedInput = {
    create?: XOR<EmergencyContactCreateWithoutSosEventsInput, EmergencyContactUncheckedCreateWithoutSosEventsInput>
    connectOrCreate?: EmergencyContactCreateOrConnectWithoutSosEventsInput
    upsert?: EmergencyContactUpsertWithoutSosEventsInput
    disconnect?: boolean
    delete?: EmergencyContactWhereInput | boolean
    connect?: EmergencyContactWhereUniqueInput
    update?: XOR<XOR<EmergencyContactUpdateToOneWithWhereWithoutSosEventsInput, EmergencyContactUpdateWithoutSosEventsInput>, EmergencyContactUncheckedUpdateWithoutSosEventsInput>
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
    isSet?: boolean
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
    isSet?: boolean
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
    isSet?: boolean
  }

  export type NestedEnumConfirmationStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.ConfirmationStatus | EnumConfirmationStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ConfirmationStatus[] | ListEnumConfirmationStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ConfirmationStatus[] | ListEnumConfirmationStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumConfirmationStatusFilter<$PrismaModel> | $Enums.ConfirmationStatus
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
    isSet?: boolean
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedEnumConfirmationStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ConfirmationStatus | EnumConfirmationStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ConfirmationStatus[] | ListEnumConfirmationStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ConfirmationStatus[] | ListEnumConfirmationStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumConfirmationStatusWithAggregatesFilter<$PrismaModel> | $Enums.ConfirmationStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumConfirmationStatusFilter<$PrismaModel>
    _max?: NestedEnumConfirmationStatusFilter<$PrismaModel>
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
    isSet?: boolean
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
    isSet?: boolean
  }

  export type NestedFloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
    isSet?: boolean
  }
  export type NestedJsonNullableFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<NestedJsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    isSet?: boolean
  }

  export type NestedEnumServiceTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.ServiceType | EnumServiceTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ServiceType[] | ListEnumServiceTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ServiceType[] | ListEnumServiceTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumServiceTypeFilter<$PrismaModel> | $Enums.ServiceType
  }

  export type NestedEnumServiceStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.ServiceStatus | EnumServiceStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ServiceStatus[] | ListEnumServiceStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ServiceStatus[] | ListEnumServiceStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumServiceStatusFilter<$PrismaModel> | $Enums.ServiceStatus
  }

  export type NestedEnumServiceTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ServiceType | EnumServiceTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ServiceType[] | ListEnumServiceTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ServiceType[] | ListEnumServiceTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumServiceTypeWithAggregatesFilter<$PrismaModel> | $Enums.ServiceType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumServiceTypeFilter<$PrismaModel>
    _max?: NestedEnumServiceTypeFilter<$PrismaModel>
  }

  export type NestedEnumServiceStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ServiceStatus | EnumServiceStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ServiceStatus[] | ListEnumServiceStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ServiceStatus[] | ListEnumServiceStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumServiceStatusWithAggregatesFilter<$PrismaModel> | $Enums.ServiceStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumServiceStatusFilter<$PrismaModel>
    _max?: NestedEnumServiceStatusFilter<$PrismaModel>
  }

  export type NestedEnumSenderTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.SenderType | EnumSenderTypeFieldRefInput<$PrismaModel>
    in?: $Enums.SenderType[] | ListEnumSenderTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.SenderType[] | ListEnumSenderTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumSenderTypeFilter<$PrismaModel> | $Enums.SenderType
  }

  export type NestedEnumSenderTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.SenderType | EnumSenderTypeFieldRefInput<$PrismaModel>
    in?: $Enums.SenderType[] | ListEnumSenderTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.SenderType[] | ListEnumSenderTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumSenderTypeWithAggregatesFilter<$PrismaModel> | $Enums.SenderType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSenderTypeFilter<$PrismaModel>
    _max?: NestedEnumSenderTypeFilter<$PrismaModel>
  }

  export type NestedEnumPaymentStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentStatus | EnumPaymentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentStatus[] | ListEnumPaymentStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.PaymentStatus[] | ListEnumPaymentStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumPaymentStatusFilter<$PrismaModel> | $Enums.PaymentStatus
  }

  export type NestedEnumPaymentStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentStatus | EnumPaymentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentStatus[] | ListEnumPaymentStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.PaymentStatus[] | ListEnumPaymentStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumPaymentStatusWithAggregatesFilter<$PrismaModel> | $Enums.PaymentStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPaymentStatusFilter<$PrismaModel>
    _max?: NestedEnumPaymentStatusFilter<$PrismaModel>
  }

  export type NestedEnumSOSStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.SOSStatus | EnumSOSStatusFieldRefInput<$PrismaModel>
    in?: $Enums.SOSStatus[] | ListEnumSOSStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.SOSStatus[] | ListEnumSOSStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumSOSStatusFilter<$PrismaModel> | $Enums.SOSStatus
  }

  export type NestedEnumSOSStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.SOSStatus | EnumSOSStatusFieldRefInput<$PrismaModel>
    in?: $Enums.SOSStatus[] | ListEnumSOSStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.SOSStatus[] | ListEnumSOSStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumSOSStatusWithAggregatesFilter<$PrismaModel> | $Enums.SOSStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSOSStatusFilter<$PrismaModel>
    _max?: NestedEnumSOSStatusFilter<$PrismaModel>
  }

  export type CarCreateWithoutUserInput = {
    id?: string
    make: string
    model: string
    year: number
    licensePlate: string
  }

  export type CarUncheckedCreateWithoutUserInput = {
    id?: string
    make: string
    model: string
    year: number
    licensePlate: string
  }

  export type CarCreateOrConnectWithoutUserInput = {
    where: CarWhereUniqueInput
    create: XOR<CarCreateWithoutUserInput, CarUncheckedCreateWithoutUserInput>
  }

  export type CarCreateManyUserInputEnvelope = {
    data: CarCreateManyUserInput | CarCreateManyUserInput[]
  }

  export type ServiceRequestCreateWithoutUserInput = {
    id?: string
    serviceType: $Enums.ServiceType
    description?: string | null
    latitude: number
    longitude: number
    address?: string | null
    status?: $Enums.ServiceStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    mechanic?: MechanicCreateNestedOneWithoutServiceRequestsInput
    payment?: PaymentCreateNestedOneWithoutServiceRequestInput
    chat?: ChatCreateNestedOneWithoutServiceRequestInput
    confirmations?: MechanicConfirmationCreateNestedManyWithoutServiceRequestInput
    reviews?: ReviewCreateNestedManyWithoutServiceRequestInput
  }

  export type ServiceRequestUncheckedCreateWithoutUserInput = {
    id?: string
    mechanicId?: string | null
    serviceType: $Enums.ServiceType
    description?: string | null
    latitude: number
    longitude: number
    address?: string | null
    status?: $Enums.ServiceStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    payment?: PaymentUncheckedCreateNestedOneWithoutServiceRequestInput
    chat?: ChatUncheckedCreateNestedOneWithoutServiceRequestInput
    confirmations?: MechanicConfirmationUncheckedCreateNestedManyWithoutServiceRequestInput
    reviews?: ReviewUncheckedCreateNestedManyWithoutServiceRequestInput
  }

  export type ServiceRequestCreateOrConnectWithoutUserInput = {
    where: ServiceRequestWhereUniqueInput
    create: XOR<ServiceRequestCreateWithoutUserInput, ServiceRequestUncheckedCreateWithoutUserInput>
  }

  export type ServiceRequestCreateManyUserInputEnvelope = {
    data: ServiceRequestCreateManyUserInput | ServiceRequestCreateManyUserInput[]
  }

  export type EmergencyContactCreateWithoutUserInput = {
    id?: string
    name: string
    mobileNumber: string
    sosEvents?: SOSCreateNestedManyWithoutEmergencyContactInput
  }

  export type EmergencyContactUncheckedCreateWithoutUserInput = {
    id?: string
    name: string
    mobileNumber: string
    sosEvents?: SOSUncheckedCreateNestedManyWithoutEmergencyContactInput
  }

  export type EmergencyContactCreateOrConnectWithoutUserInput = {
    where: EmergencyContactWhereUniqueInput
    create: XOR<EmergencyContactCreateWithoutUserInput, EmergencyContactUncheckedCreateWithoutUserInput>
  }

  export type EmergencyContactCreateManyUserInputEnvelope = {
    data: EmergencyContactCreateManyUserInput | EmergencyContactCreateManyUserInput[]
  }

  export type MessageCreateWithoutUserInput = {
    id?: string
    senderType: string
    content: string
    createdAt?: Date | string
    chat: ChatCreateNestedOneWithoutMessagesInput
    mechanic?: MechanicCreateNestedOneWithoutSentMessagesInput
  }

  export type MessageUncheckedCreateWithoutUserInput = {
    id?: string
    chatId: string
    senderType: string
    content: string
    createdAt?: Date | string
  }

  export type MessageCreateOrConnectWithoutUserInput = {
    where: MessageWhereUniqueInput
    create: XOR<MessageCreateWithoutUserInput, MessageUncheckedCreateWithoutUserInput>
  }

  export type MessageCreateManyUserInputEnvelope = {
    data: MessageCreateManyUserInput | MessageCreateManyUserInput[]
  }

  export type SOSCreateWithoutUserInput = {
    id?: string
    latitude: number
    longitude: number
    createdAt?: Date | string
    customMessage?: string | null
    status?: $Enums.SOSStatus
    emergencyContact?: EmergencyContactCreateNestedOneWithoutSosEventsInput
  }

  export type SOSUncheckedCreateWithoutUserInput = {
    id?: string
    emergencyContactId?: string | null
    latitude: number
    longitude: number
    createdAt?: Date | string
    customMessage?: string | null
    status?: $Enums.SOSStatus
  }

  export type SOSCreateOrConnectWithoutUserInput = {
    where: SOSWhereUniqueInput
    create: XOR<SOSCreateWithoutUserInput, SOSUncheckedCreateWithoutUserInput>
  }

  export type SOSCreateManyUserInputEnvelope = {
    data: SOSCreateManyUserInput | SOSCreateManyUserInput[]
  }

  export type CarUpsertWithWhereUniqueWithoutUserInput = {
    where: CarWhereUniqueInput
    update: XOR<CarUpdateWithoutUserInput, CarUncheckedUpdateWithoutUserInput>
    create: XOR<CarCreateWithoutUserInput, CarUncheckedCreateWithoutUserInput>
  }

  export type CarUpdateWithWhereUniqueWithoutUserInput = {
    where: CarWhereUniqueInput
    data: XOR<CarUpdateWithoutUserInput, CarUncheckedUpdateWithoutUserInput>
  }

  export type CarUpdateManyWithWhereWithoutUserInput = {
    where: CarScalarWhereInput
    data: XOR<CarUpdateManyMutationInput, CarUncheckedUpdateManyWithoutUserInput>
  }

  export type CarScalarWhereInput = {
    AND?: CarScalarWhereInput | CarScalarWhereInput[]
    OR?: CarScalarWhereInput[]
    NOT?: CarScalarWhereInput | CarScalarWhereInput[]
    id?: StringFilter<"Car"> | string
    userId?: StringFilter<"Car"> | string
    make?: StringFilter<"Car"> | string
    model?: StringFilter<"Car"> | string
    year?: IntFilter<"Car"> | number
    licensePlate?: StringFilter<"Car"> | string
  }

  export type ServiceRequestUpsertWithWhereUniqueWithoutUserInput = {
    where: ServiceRequestWhereUniqueInput
    update: XOR<ServiceRequestUpdateWithoutUserInput, ServiceRequestUncheckedUpdateWithoutUserInput>
    create: XOR<ServiceRequestCreateWithoutUserInput, ServiceRequestUncheckedCreateWithoutUserInput>
  }

  export type ServiceRequestUpdateWithWhereUniqueWithoutUserInput = {
    where: ServiceRequestWhereUniqueInput
    data: XOR<ServiceRequestUpdateWithoutUserInput, ServiceRequestUncheckedUpdateWithoutUserInput>
  }

  export type ServiceRequestUpdateManyWithWhereWithoutUserInput = {
    where: ServiceRequestScalarWhereInput
    data: XOR<ServiceRequestUpdateManyMutationInput, ServiceRequestUncheckedUpdateManyWithoutUserInput>
  }

  export type ServiceRequestScalarWhereInput = {
    AND?: ServiceRequestScalarWhereInput | ServiceRequestScalarWhereInput[]
    OR?: ServiceRequestScalarWhereInput[]
    NOT?: ServiceRequestScalarWhereInput | ServiceRequestScalarWhereInput[]
    id?: StringFilter<"ServiceRequest"> | string
    userId?: StringFilter<"ServiceRequest"> | string
    mechanicId?: StringNullableFilter<"ServiceRequest"> | string | null
    serviceType?: EnumServiceTypeFilter<"ServiceRequest"> | $Enums.ServiceType
    description?: StringNullableFilter<"ServiceRequest"> | string | null
    latitude?: FloatFilter<"ServiceRequest"> | number
    longitude?: FloatFilter<"ServiceRequest"> | number
    address?: StringNullableFilter<"ServiceRequest"> | string | null
    status?: EnumServiceStatusFilter<"ServiceRequest"> | $Enums.ServiceStatus
    createdAt?: DateTimeFilter<"ServiceRequest"> | Date | string
    updatedAt?: DateTimeFilter<"ServiceRequest"> | Date | string
  }

  export type EmergencyContactUpsertWithWhereUniqueWithoutUserInput = {
    where: EmergencyContactWhereUniqueInput
    update: XOR<EmergencyContactUpdateWithoutUserInput, EmergencyContactUncheckedUpdateWithoutUserInput>
    create: XOR<EmergencyContactCreateWithoutUserInput, EmergencyContactUncheckedCreateWithoutUserInput>
  }

  export type EmergencyContactUpdateWithWhereUniqueWithoutUserInput = {
    where: EmergencyContactWhereUniqueInput
    data: XOR<EmergencyContactUpdateWithoutUserInput, EmergencyContactUncheckedUpdateWithoutUserInput>
  }

  export type EmergencyContactUpdateManyWithWhereWithoutUserInput = {
    where: EmergencyContactScalarWhereInput
    data: XOR<EmergencyContactUpdateManyMutationInput, EmergencyContactUncheckedUpdateManyWithoutUserInput>
  }

  export type EmergencyContactScalarWhereInput = {
    AND?: EmergencyContactScalarWhereInput | EmergencyContactScalarWhereInput[]
    OR?: EmergencyContactScalarWhereInput[]
    NOT?: EmergencyContactScalarWhereInput | EmergencyContactScalarWhereInput[]
    id?: StringFilter<"EmergencyContact"> | string
    userId?: StringFilter<"EmergencyContact"> | string
    name?: StringFilter<"EmergencyContact"> | string
    mobileNumber?: StringFilter<"EmergencyContact"> | string
  }

  export type MessageUpsertWithWhereUniqueWithoutUserInput = {
    where: MessageWhereUniqueInput
    update: XOR<MessageUpdateWithoutUserInput, MessageUncheckedUpdateWithoutUserInput>
    create: XOR<MessageCreateWithoutUserInput, MessageUncheckedCreateWithoutUserInput>
  }

  export type MessageUpdateWithWhereUniqueWithoutUserInput = {
    where: MessageWhereUniqueInput
    data: XOR<MessageUpdateWithoutUserInput, MessageUncheckedUpdateWithoutUserInput>
  }

  export type MessageUpdateManyWithWhereWithoutUserInput = {
    where: MessageScalarWhereInput
    data: XOR<MessageUpdateManyMutationInput, MessageUncheckedUpdateManyWithoutUserInput>
  }

  export type MessageScalarWhereInput = {
    AND?: MessageScalarWhereInput | MessageScalarWhereInput[]
    OR?: MessageScalarWhereInput[]
    NOT?: MessageScalarWhereInput | MessageScalarWhereInput[]
    id?: StringFilter<"Message"> | string
    chatId?: StringFilter<"Message"> | string
    senderId?: StringNullableFilter<"Message"> | string | null
    senderType?: StringFilter<"Message"> | string
    content?: StringFilter<"Message"> | string
    createdAt?: DateTimeFilter<"Message"> | Date | string
  }

  export type SOSUpsertWithWhereUniqueWithoutUserInput = {
    where: SOSWhereUniqueInput
    update: XOR<SOSUpdateWithoutUserInput, SOSUncheckedUpdateWithoutUserInput>
    create: XOR<SOSCreateWithoutUserInput, SOSUncheckedCreateWithoutUserInput>
  }

  export type SOSUpdateWithWhereUniqueWithoutUserInput = {
    where: SOSWhereUniqueInput
    data: XOR<SOSUpdateWithoutUserInput, SOSUncheckedUpdateWithoutUserInput>
  }

  export type SOSUpdateManyWithWhereWithoutUserInput = {
    where: SOSScalarWhereInput
    data: XOR<SOSUpdateManyMutationInput, SOSUncheckedUpdateManyWithoutUserInput>
  }

  export type SOSScalarWhereInput = {
    AND?: SOSScalarWhereInput | SOSScalarWhereInput[]
    OR?: SOSScalarWhereInput[]
    NOT?: SOSScalarWhereInput | SOSScalarWhereInput[]
    id?: StringFilter<"SOS"> | string
    userId?: StringFilter<"SOS"> | string
    emergencyContactId?: StringNullableFilter<"SOS"> | string | null
    latitude?: FloatFilter<"SOS"> | number
    longitude?: FloatFilter<"SOS"> | number
    createdAt?: DateTimeFilter<"SOS"> | Date | string
    customMessage?: StringNullableFilter<"SOS"> | string | null
    status?: EnumSOSStatusFilter<"SOS"> | $Enums.SOSStatus
  }

  export type MechanicCreateWithoutMechanicConfirmationInput = {
    id?: string
    name?: string | null
    email?: string | null
    phoneNumber: string
    services?: MechanicCreateservicesInput | $Enums.ServiceType[]
    latitude?: number | null
    longitude?: number | null
    location?: InputJsonValue | null
    expoToken?: string | null
    serviceRequests?: ServiceRequestCreateNestedManyWithoutMechanicInput
    reviews?: ReviewCreateNestedManyWithoutMechanicInput
    sentMessages?: MessageCreateNestedManyWithoutMechanicInput
  }

  export type MechanicUncheckedCreateWithoutMechanicConfirmationInput = {
    id?: string
    name?: string | null
    email?: string | null
    phoneNumber: string
    services?: MechanicCreateservicesInput | $Enums.ServiceType[]
    latitude?: number | null
    longitude?: number | null
    location?: InputJsonValue | null
    expoToken?: string | null
    serviceRequests?: ServiceRequestUncheckedCreateNestedManyWithoutMechanicInput
    reviews?: ReviewUncheckedCreateNestedManyWithoutMechanicInput
    sentMessages?: MessageUncheckedCreateNestedManyWithoutMechanicInput
  }

  export type MechanicCreateOrConnectWithoutMechanicConfirmationInput = {
    where: MechanicWhereUniqueInput
    create: XOR<MechanicCreateWithoutMechanicConfirmationInput, MechanicUncheckedCreateWithoutMechanicConfirmationInput>
  }

  export type ServiceRequestCreateWithoutConfirmationsInput = {
    id?: string
    serviceType: $Enums.ServiceType
    description?: string | null
    latitude: number
    longitude: number
    address?: string | null
    status?: $Enums.ServiceStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutServiceRequestsInput
    mechanic?: MechanicCreateNestedOneWithoutServiceRequestsInput
    payment?: PaymentCreateNestedOneWithoutServiceRequestInput
    chat?: ChatCreateNestedOneWithoutServiceRequestInput
    reviews?: ReviewCreateNestedManyWithoutServiceRequestInput
  }

  export type ServiceRequestUncheckedCreateWithoutConfirmationsInput = {
    id?: string
    userId: string
    mechanicId?: string | null
    serviceType: $Enums.ServiceType
    description?: string | null
    latitude: number
    longitude: number
    address?: string | null
    status?: $Enums.ServiceStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    payment?: PaymentUncheckedCreateNestedOneWithoutServiceRequestInput
    chat?: ChatUncheckedCreateNestedOneWithoutServiceRequestInput
    reviews?: ReviewUncheckedCreateNestedManyWithoutServiceRequestInput
  }

  export type ServiceRequestCreateOrConnectWithoutConfirmationsInput = {
    where: ServiceRequestWhereUniqueInput
    create: XOR<ServiceRequestCreateWithoutConfirmationsInput, ServiceRequestUncheckedCreateWithoutConfirmationsInput>
  }

  export type MechanicUpsertWithoutMechanicConfirmationInput = {
    update: XOR<MechanicUpdateWithoutMechanicConfirmationInput, MechanicUncheckedUpdateWithoutMechanicConfirmationInput>
    create: XOR<MechanicCreateWithoutMechanicConfirmationInput, MechanicUncheckedCreateWithoutMechanicConfirmationInput>
    where?: MechanicWhereInput
  }

  export type MechanicUpdateToOneWithWhereWithoutMechanicConfirmationInput = {
    where?: MechanicWhereInput
    data: XOR<MechanicUpdateWithoutMechanicConfirmationInput, MechanicUncheckedUpdateWithoutMechanicConfirmationInput>
  }

  export type MechanicUpdateWithoutMechanicConfirmationInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: StringFieldUpdateOperationsInput | string
    services?: MechanicUpdateservicesInput | $Enums.ServiceType[]
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    location?: InputJsonValue | InputJsonValue | null
    expoToken?: NullableStringFieldUpdateOperationsInput | string | null
    serviceRequests?: ServiceRequestUpdateManyWithoutMechanicNestedInput
    reviews?: ReviewUpdateManyWithoutMechanicNestedInput
    sentMessages?: MessageUpdateManyWithoutMechanicNestedInput
  }

  export type MechanicUncheckedUpdateWithoutMechanicConfirmationInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: StringFieldUpdateOperationsInput | string
    services?: MechanicUpdateservicesInput | $Enums.ServiceType[]
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    location?: InputJsonValue | InputJsonValue | null
    expoToken?: NullableStringFieldUpdateOperationsInput | string | null
    serviceRequests?: ServiceRequestUncheckedUpdateManyWithoutMechanicNestedInput
    reviews?: ReviewUncheckedUpdateManyWithoutMechanicNestedInput
    sentMessages?: MessageUncheckedUpdateManyWithoutMechanicNestedInput
  }

  export type ServiceRequestUpsertWithoutConfirmationsInput = {
    update: XOR<ServiceRequestUpdateWithoutConfirmationsInput, ServiceRequestUncheckedUpdateWithoutConfirmationsInput>
    create: XOR<ServiceRequestCreateWithoutConfirmationsInput, ServiceRequestUncheckedCreateWithoutConfirmationsInput>
    where?: ServiceRequestWhereInput
  }

  export type ServiceRequestUpdateToOneWithWhereWithoutConfirmationsInput = {
    where?: ServiceRequestWhereInput
    data: XOR<ServiceRequestUpdateWithoutConfirmationsInput, ServiceRequestUncheckedUpdateWithoutConfirmationsInput>
  }

  export type ServiceRequestUpdateWithoutConfirmationsInput = {
    serviceType?: EnumServiceTypeFieldUpdateOperationsInput | $Enums.ServiceType
    description?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: FloatFieldUpdateOperationsInput | number
    longitude?: FloatFieldUpdateOperationsInput | number
    address?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumServiceStatusFieldUpdateOperationsInput | $Enums.ServiceStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutServiceRequestsNestedInput
    mechanic?: MechanicUpdateOneWithoutServiceRequestsNestedInput
    payment?: PaymentUpdateOneWithoutServiceRequestNestedInput
    chat?: ChatUpdateOneWithoutServiceRequestNestedInput
    reviews?: ReviewUpdateManyWithoutServiceRequestNestedInput
  }

  export type ServiceRequestUncheckedUpdateWithoutConfirmationsInput = {
    userId?: StringFieldUpdateOperationsInput | string
    mechanicId?: NullableStringFieldUpdateOperationsInput | string | null
    serviceType?: EnumServiceTypeFieldUpdateOperationsInput | $Enums.ServiceType
    description?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: FloatFieldUpdateOperationsInput | number
    longitude?: FloatFieldUpdateOperationsInput | number
    address?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumServiceStatusFieldUpdateOperationsInput | $Enums.ServiceStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    payment?: PaymentUncheckedUpdateOneWithoutServiceRequestNestedInput
    chat?: ChatUncheckedUpdateOneWithoutServiceRequestNestedInput
    reviews?: ReviewUncheckedUpdateManyWithoutServiceRequestNestedInput
  }

  export type ServiceRequestCreateWithoutMechanicInput = {
    id?: string
    serviceType: $Enums.ServiceType
    description?: string | null
    latitude: number
    longitude: number
    address?: string | null
    status?: $Enums.ServiceStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutServiceRequestsInput
    payment?: PaymentCreateNestedOneWithoutServiceRequestInput
    chat?: ChatCreateNestedOneWithoutServiceRequestInput
    confirmations?: MechanicConfirmationCreateNestedManyWithoutServiceRequestInput
    reviews?: ReviewCreateNestedManyWithoutServiceRequestInput
  }

  export type ServiceRequestUncheckedCreateWithoutMechanicInput = {
    id?: string
    userId: string
    serviceType: $Enums.ServiceType
    description?: string | null
    latitude: number
    longitude: number
    address?: string | null
    status?: $Enums.ServiceStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    payment?: PaymentUncheckedCreateNestedOneWithoutServiceRequestInput
    chat?: ChatUncheckedCreateNestedOneWithoutServiceRequestInput
    confirmations?: MechanicConfirmationUncheckedCreateNestedManyWithoutServiceRequestInput
    reviews?: ReviewUncheckedCreateNestedManyWithoutServiceRequestInput
  }

  export type ServiceRequestCreateOrConnectWithoutMechanicInput = {
    where: ServiceRequestWhereUniqueInput
    create: XOR<ServiceRequestCreateWithoutMechanicInput, ServiceRequestUncheckedCreateWithoutMechanicInput>
  }

  export type ServiceRequestCreateManyMechanicInputEnvelope = {
    data: ServiceRequestCreateManyMechanicInput | ServiceRequestCreateManyMechanicInput[]
  }

  export type ReviewCreateWithoutMechanicInput = {
    id?: string
    reviewerType: $Enums.SenderType
    rating: number
    comment?: string | null
    createdAt?: Date | string
    serviceRequest: ServiceRequestCreateNestedOneWithoutReviewsInput
  }

  export type ReviewUncheckedCreateWithoutMechanicInput = {
    id?: string
    serviceRequestId: string
    reviewerType: $Enums.SenderType
    rating: number
    comment?: string | null
    createdAt?: Date | string
  }

  export type ReviewCreateOrConnectWithoutMechanicInput = {
    where: ReviewWhereUniqueInput
    create: XOR<ReviewCreateWithoutMechanicInput, ReviewUncheckedCreateWithoutMechanicInput>
  }

  export type ReviewCreateManyMechanicInputEnvelope = {
    data: ReviewCreateManyMechanicInput | ReviewCreateManyMechanicInput[]
  }

  export type MessageCreateWithoutMechanicInput = {
    id?: string
    senderType: string
    content: string
    createdAt?: Date | string
    chat: ChatCreateNestedOneWithoutMessagesInput
    user?: UserCreateNestedOneWithoutSentMessagesInput
  }

  export type MessageUncheckedCreateWithoutMechanicInput = {
    id?: string
    chatId: string
    senderType: string
    content: string
    createdAt?: Date | string
  }

  export type MessageCreateOrConnectWithoutMechanicInput = {
    where: MessageWhereUniqueInput
    create: XOR<MessageCreateWithoutMechanicInput, MessageUncheckedCreateWithoutMechanicInput>
  }

  export type MessageCreateManyMechanicInputEnvelope = {
    data: MessageCreateManyMechanicInput | MessageCreateManyMechanicInput[]
  }

  export type MechanicConfirmationCreateWithoutMechanicInput = {
    id?: string
    status?: $Enums.ConfirmationStatus
    distanceText: string
    distanceValue: number
    durationText: string
    durationValue: number
    estimatedCost: number
    respondedAt?: Date | string | null
    createdAt?: Date | string
    serviceRequest: ServiceRequestCreateNestedOneWithoutConfirmationsInput
  }

  export type MechanicConfirmationUncheckedCreateWithoutMechanicInput = {
    id?: string
    serviceRequestId: string
    status?: $Enums.ConfirmationStatus
    distanceText: string
    distanceValue: number
    durationText: string
    durationValue: number
    estimatedCost: number
    respondedAt?: Date | string | null
    createdAt?: Date | string
  }

  export type MechanicConfirmationCreateOrConnectWithoutMechanicInput = {
    where: MechanicConfirmationWhereUniqueInput
    create: XOR<MechanicConfirmationCreateWithoutMechanicInput, MechanicConfirmationUncheckedCreateWithoutMechanicInput>
  }

  export type MechanicConfirmationCreateManyMechanicInputEnvelope = {
    data: MechanicConfirmationCreateManyMechanicInput | MechanicConfirmationCreateManyMechanicInput[]
  }

  export type ServiceRequestUpsertWithWhereUniqueWithoutMechanicInput = {
    where: ServiceRequestWhereUniqueInput
    update: XOR<ServiceRequestUpdateWithoutMechanicInput, ServiceRequestUncheckedUpdateWithoutMechanicInput>
    create: XOR<ServiceRequestCreateWithoutMechanicInput, ServiceRequestUncheckedCreateWithoutMechanicInput>
  }

  export type ServiceRequestUpdateWithWhereUniqueWithoutMechanicInput = {
    where: ServiceRequestWhereUniqueInput
    data: XOR<ServiceRequestUpdateWithoutMechanicInput, ServiceRequestUncheckedUpdateWithoutMechanicInput>
  }

  export type ServiceRequestUpdateManyWithWhereWithoutMechanicInput = {
    where: ServiceRequestScalarWhereInput
    data: XOR<ServiceRequestUpdateManyMutationInput, ServiceRequestUncheckedUpdateManyWithoutMechanicInput>
  }

  export type ReviewUpsertWithWhereUniqueWithoutMechanicInput = {
    where: ReviewWhereUniqueInput
    update: XOR<ReviewUpdateWithoutMechanicInput, ReviewUncheckedUpdateWithoutMechanicInput>
    create: XOR<ReviewCreateWithoutMechanicInput, ReviewUncheckedCreateWithoutMechanicInput>
  }

  export type ReviewUpdateWithWhereUniqueWithoutMechanicInput = {
    where: ReviewWhereUniqueInput
    data: XOR<ReviewUpdateWithoutMechanicInput, ReviewUncheckedUpdateWithoutMechanicInput>
  }

  export type ReviewUpdateManyWithWhereWithoutMechanicInput = {
    where: ReviewScalarWhereInput
    data: XOR<ReviewUpdateManyMutationInput, ReviewUncheckedUpdateManyWithoutMechanicInput>
  }

  export type ReviewScalarWhereInput = {
    AND?: ReviewScalarWhereInput | ReviewScalarWhereInput[]
    OR?: ReviewScalarWhereInput[]
    NOT?: ReviewScalarWhereInput | ReviewScalarWhereInput[]
    id?: StringFilter<"Review"> | string
    serviceRequestId?: StringFilter<"Review"> | string
    reviewerType?: EnumSenderTypeFilter<"Review"> | $Enums.SenderType
    rating?: IntFilter<"Review"> | number
    comment?: StringNullableFilter<"Review"> | string | null
    createdAt?: DateTimeFilter<"Review"> | Date | string
    mechanicId?: StringNullableFilter<"Review"> | string | null
  }

  export type MessageUpsertWithWhereUniqueWithoutMechanicInput = {
    where: MessageWhereUniqueInput
    update: XOR<MessageUpdateWithoutMechanicInput, MessageUncheckedUpdateWithoutMechanicInput>
    create: XOR<MessageCreateWithoutMechanicInput, MessageUncheckedCreateWithoutMechanicInput>
  }

  export type MessageUpdateWithWhereUniqueWithoutMechanicInput = {
    where: MessageWhereUniqueInput
    data: XOR<MessageUpdateWithoutMechanicInput, MessageUncheckedUpdateWithoutMechanicInput>
  }

  export type MessageUpdateManyWithWhereWithoutMechanicInput = {
    where: MessageScalarWhereInput
    data: XOR<MessageUpdateManyMutationInput, MessageUncheckedUpdateManyWithoutMechanicInput>
  }

  export type MechanicConfirmationUpsertWithWhereUniqueWithoutMechanicInput = {
    where: MechanicConfirmationWhereUniqueInput
    update: XOR<MechanicConfirmationUpdateWithoutMechanicInput, MechanicConfirmationUncheckedUpdateWithoutMechanicInput>
    create: XOR<MechanicConfirmationCreateWithoutMechanicInput, MechanicConfirmationUncheckedCreateWithoutMechanicInput>
  }

  export type MechanicConfirmationUpdateWithWhereUniqueWithoutMechanicInput = {
    where: MechanicConfirmationWhereUniqueInput
    data: XOR<MechanicConfirmationUpdateWithoutMechanicInput, MechanicConfirmationUncheckedUpdateWithoutMechanicInput>
  }

  export type MechanicConfirmationUpdateManyWithWhereWithoutMechanicInput = {
    where: MechanicConfirmationScalarWhereInput
    data: XOR<MechanicConfirmationUpdateManyMutationInput, MechanicConfirmationUncheckedUpdateManyWithoutMechanicInput>
  }

  export type MechanicConfirmationScalarWhereInput = {
    AND?: MechanicConfirmationScalarWhereInput | MechanicConfirmationScalarWhereInput[]
    OR?: MechanicConfirmationScalarWhereInput[]
    NOT?: MechanicConfirmationScalarWhereInput | MechanicConfirmationScalarWhereInput[]
    id?: StringFilter<"MechanicConfirmation"> | string
    mechanicId?: StringFilter<"MechanicConfirmation"> | string
    serviceRequestId?: StringFilter<"MechanicConfirmation"> | string
    status?: EnumConfirmationStatusFilter<"MechanicConfirmation"> | $Enums.ConfirmationStatus
    distanceText?: StringFilter<"MechanicConfirmation"> | string
    distanceValue?: IntFilter<"MechanicConfirmation"> | number
    durationText?: StringFilter<"MechanicConfirmation"> | string
    durationValue?: IntFilter<"MechanicConfirmation"> | number
    estimatedCost?: FloatFilter<"MechanicConfirmation"> | number
    respondedAt?: DateTimeNullableFilter<"MechanicConfirmation"> | Date | string | null
    createdAt?: DateTimeFilter<"MechanicConfirmation"> | Date | string
  }

  export type UserCreateWithoutCarsInput = {
    id?: string
    phoneNumber: string
    name?: string | null
    email?: string | null
    password?: string | null
    serviceRequests?: ServiceRequestCreateNestedManyWithoutUserInput
    emergencyContacts?: EmergencyContactCreateNestedManyWithoutUserInput
    sentMessages?: MessageCreateNestedManyWithoutUserInput
    sosEvents?: SOSCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutCarsInput = {
    id?: string
    phoneNumber: string
    name?: string | null
    email?: string | null
    password?: string | null
    serviceRequests?: ServiceRequestUncheckedCreateNestedManyWithoutUserInput
    emergencyContacts?: EmergencyContactUncheckedCreateNestedManyWithoutUserInput
    sentMessages?: MessageUncheckedCreateNestedManyWithoutUserInput
    sosEvents?: SOSUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutCarsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutCarsInput, UserUncheckedCreateWithoutCarsInput>
  }

  export type UserUpsertWithoutCarsInput = {
    update: XOR<UserUpdateWithoutCarsInput, UserUncheckedUpdateWithoutCarsInput>
    create: XOR<UserCreateWithoutCarsInput, UserUncheckedCreateWithoutCarsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutCarsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutCarsInput, UserUncheckedUpdateWithoutCarsInput>
  }

  export type UserUpdateWithoutCarsInput = {
    phoneNumber?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    serviceRequests?: ServiceRequestUpdateManyWithoutUserNestedInput
    emergencyContacts?: EmergencyContactUpdateManyWithoutUserNestedInput
    sentMessages?: MessageUpdateManyWithoutUserNestedInput
    sosEvents?: SOSUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutCarsInput = {
    phoneNumber?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    serviceRequests?: ServiceRequestUncheckedUpdateManyWithoutUserNestedInput
    emergencyContacts?: EmergencyContactUncheckedUpdateManyWithoutUserNestedInput
    sentMessages?: MessageUncheckedUpdateManyWithoutUserNestedInput
    sosEvents?: SOSUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutServiceRequestsInput = {
    id?: string
    phoneNumber: string
    name?: string | null
    email?: string | null
    password?: string | null
    cars?: CarCreateNestedManyWithoutUserInput
    emergencyContacts?: EmergencyContactCreateNestedManyWithoutUserInput
    sentMessages?: MessageCreateNestedManyWithoutUserInput
    sosEvents?: SOSCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutServiceRequestsInput = {
    id?: string
    phoneNumber: string
    name?: string | null
    email?: string | null
    password?: string | null
    cars?: CarUncheckedCreateNestedManyWithoutUserInput
    emergencyContacts?: EmergencyContactUncheckedCreateNestedManyWithoutUserInput
    sentMessages?: MessageUncheckedCreateNestedManyWithoutUserInput
    sosEvents?: SOSUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutServiceRequestsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutServiceRequestsInput, UserUncheckedCreateWithoutServiceRequestsInput>
  }

  export type MechanicCreateWithoutServiceRequestsInput = {
    id?: string
    name?: string | null
    email?: string | null
    phoneNumber: string
    services?: MechanicCreateservicesInput | $Enums.ServiceType[]
    latitude?: number | null
    longitude?: number | null
    location?: InputJsonValue | null
    expoToken?: string | null
    reviews?: ReviewCreateNestedManyWithoutMechanicInput
    sentMessages?: MessageCreateNestedManyWithoutMechanicInput
    MechanicConfirmation?: MechanicConfirmationCreateNestedManyWithoutMechanicInput
  }

  export type MechanicUncheckedCreateWithoutServiceRequestsInput = {
    id?: string
    name?: string | null
    email?: string | null
    phoneNumber: string
    services?: MechanicCreateservicesInput | $Enums.ServiceType[]
    latitude?: number | null
    longitude?: number | null
    location?: InputJsonValue | null
    expoToken?: string | null
    reviews?: ReviewUncheckedCreateNestedManyWithoutMechanicInput
    sentMessages?: MessageUncheckedCreateNestedManyWithoutMechanicInput
    MechanicConfirmation?: MechanicConfirmationUncheckedCreateNestedManyWithoutMechanicInput
  }

  export type MechanicCreateOrConnectWithoutServiceRequestsInput = {
    where: MechanicWhereUniqueInput
    create: XOR<MechanicCreateWithoutServiceRequestsInput, MechanicUncheckedCreateWithoutServiceRequestsInput>
  }

  export type PaymentCreateWithoutServiceRequestInput = {
    id?: string
    amount: number
    status: $Enums.PaymentStatus
    razorpayOrderId?: string | null
    razorpayPaymentId?: string | null
    razorpaySignature?: string | null
    comment?: string | null
    createdAt?: Date | string
  }

  export type PaymentUncheckedCreateWithoutServiceRequestInput = {
    id?: string
    amount: number
    status: $Enums.PaymentStatus
    razorpayOrderId?: string | null
    razorpayPaymentId?: string | null
    razorpaySignature?: string | null
    comment?: string | null
    createdAt?: Date | string
  }

  export type PaymentCreateOrConnectWithoutServiceRequestInput = {
    where: PaymentWhereUniqueInput
    create: XOR<PaymentCreateWithoutServiceRequestInput, PaymentUncheckedCreateWithoutServiceRequestInput>
  }

  export type ChatCreateWithoutServiceRequestInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    messages?: MessageCreateNestedManyWithoutChatInput
  }

  export type ChatUncheckedCreateWithoutServiceRequestInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    messages?: MessageUncheckedCreateNestedManyWithoutChatInput
  }

  export type ChatCreateOrConnectWithoutServiceRequestInput = {
    where: ChatWhereUniqueInput
    create: XOR<ChatCreateWithoutServiceRequestInput, ChatUncheckedCreateWithoutServiceRequestInput>
  }

  export type MechanicConfirmationCreateWithoutServiceRequestInput = {
    id?: string
    status?: $Enums.ConfirmationStatus
    distanceText: string
    distanceValue: number
    durationText: string
    durationValue: number
    estimatedCost: number
    respondedAt?: Date | string | null
    createdAt?: Date | string
    mechanic: MechanicCreateNestedOneWithoutMechanicConfirmationInput
  }

  export type MechanicConfirmationUncheckedCreateWithoutServiceRequestInput = {
    id?: string
    mechanicId: string
    status?: $Enums.ConfirmationStatus
    distanceText: string
    distanceValue: number
    durationText: string
    durationValue: number
    estimatedCost: number
    respondedAt?: Date | string | null
    createdAt?: Date | string
  }

  export type MechanicConfirmationCreateOrConnectWithoutServiceRequestInput = {
    where: MechanicConfirmationWhereUniqueInput
    create: XOR<MechanicConfirmationCreateWithoutServiceRequestInput, MechanicConfirmationUncheckedCreateWithoutServiceRequestInput>
  }

  export type MechanicConfirmationCreateManyServiceRequestInputEnvelope = {
    data: MechanicConfirmationCreateManyServiceRequestInput | MechanicConfirmationCreateManyServiceRequestInput[]
  }

  export type ReviewCreateWithoutServiceRequestInput = {
    id?: string
    reviewerType: $Enums.SenderType
    rating: number
    comment?: string | null
    createdAt?: Date | string
    Mechanic?: MechanicCreateNestedOneWithoutReviewsInput
  }

  export type ReviewUncheckedCreateWithoutServiceRequestInput = {
    id?: string
    reviewerType: $Enums.SenderType
    rating: number
    comment?: string | null
    createdAt?: Date | string
    mechanicId?: string | null
  }

  export type ReviewCreateOrConnectWithoutServiceRequestInput = {
    where: ReviewWhereUniqueInput
    create: XOR<ReviewCreateWithoutServiceRequestInput, ReviewUncheckedCreateWithoutServiceRequestInput>
  }

  export type ReviewCreateManyServiceRequestInputEnvelope = {
    data: ReviewCreateManyServiceRequestInput | ReviewCreateManyServiceRequestInput[]
  }

  export type UserUpsertWithoutServiceRequestsInput = {
    update: XOR<UserUpdateWithoutServiceRequestsInput, UserUncheckedUpdateWithoutServiceRequestsInput>
    create: XOR<UserCreateWithoutServiceRequestsInput, UserUncheckedCreateWithoutServiceRequestsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutServiceRequestsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutServiceRequestsInput, UserUncheckedUpdateWithoutServiceRequestsInput>
  }

  export type UserUpdateWithoutServiceRequestsInput = {
    phoneNumber?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    cars?: CarUpdateManyWithoutUserNestedInput
    emergencyContacts?: EmergencyContactUpdateManyWithoutUserNestedInput
    sentMessages?: MessageUpdateManyWithoutUserNestedInput
    sosEvents?: SOSUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutServiceRequestsInput = {
    phoneNumber?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    cars?: CarUncheckedUpdateManyWithoutUserNestedInput
    emergencyContacts?: EmergencyContactUncheckedUpdateManyWithoutUserNestedInput
    sentMessages?: MessageUncheckedUpdateManyWithoutUserNestedInput
    sosEvents?: SOSUncheckedUpdateManyWithoutUserNestedInput
  }

  export type MechanicUpsertWithoutServiceRequestsInput = {
    update: XOR<MechanicUpdateWithoutServiceRequestsInput, MechanicUncheckedUpdateWithoutServiceRequestsInput>
    create: XOR<MechanicCreateWithoutServiceRequestsInput, MechanicUncheckedCreateWithoutServiceRequestsInput>
    where?: MechanicWhereInput
  }

  export type MechanicUpdateToOneWithWhereWithoutServiceRequestsInput = {
    where?: MechanicWhereInput
    data: XOR<MechanicUpdateWithoutServiceRequestsInput, MechanicUncheckedUpdateWithoutServiceRequestsInput>
  }

  export type MechanicUpdateWithoutServiceRequestsInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: StringFieldUpdateOperationsInput | string
    services?: MechanicUpdateservicesInput | $Enums.ServiceType[]
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    location?: InputJsonValue | InputJsonValue | null
    expoToken?: NullableStringFieldUpdateOperationsInput | string | null
    reviews?: ReviewUpdateManyWithoutMechanicNestedInput
    sentMessages?: MessageUpdateManyWithoutMechanicNestedInput
    MechanicConfirmation?: MechanicConfirmationUpdateManyWithoutMechanicNestedInput
  }

  export type MechanicUncheckedUpdateWithoutServiceRequestsInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: StringFieldUpdateOperationsInput | string
    services?: MechanicUpdateservicesInput | $Enums.ServiceType[]
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    location?: InputJsonValue | InputJsonValue | null
    expoToken?: NullableStringFieldUpdateOperationsInput | string | null
    reviews?: ReviewUncheckedUpdateManyWithoutMechanicNestedInput
    sentMessages?: MessageUncheckedUpdateManyWithoutMechanicNestedInput
    MechanicConfirmation?: MechanicConfirmationUncheckedUpdateManyWithoutMechanicNestedInput
  }

  export type PaymentUpsertWithoutServiceRequestInput = {
    update: XOR<PaymentUpdateWithoutServiceRequestInput, PaymentUncheckedUpdateWithoutServiceRequestInput>
    create: XOR<PaymentCreateWithoutServiceRequestInput, PaymentUncheckedCreateWithoutServiceRequestInput>
    where?: PaymentWhereInput
  }

  export type PaymentUpdateToOneWithWhereWithoutServiceRequestInput = {
    where?: PaymentWhereInput
    data: XOR<PaymentUpdateWithoutServiceRequestInput, PaymentUncheckedUpdateWithoutServiceRequestInput>
  }

  export type PaymentUpdateWithoutServiceRequestInput = {
    amount?: FloatFieldUpdateOperationsInput | number
    status?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    razorpayOrderId?: NullableStringFieldUpdateOperationsInput | string | null
    razorpayPaymentId?: NullableStringFieldUpdateOperationsInput | string | null
    razorpaySignature?: NullableStringFieldUpdateOperationsInput | string | null
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentUncheckedUpdateWithoutServiceRequestInput = {
    amount?: FloatFieldUpdateOperationsInput | number
    status?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    razorpayOrderId?: NullableStringFieldUpdateOperationsInput | string | null
    razorpayPaymentId?: NullableStringFieldUpdateOperationsInput | string | null
    razorpaySignature?: NullableStringFieldUpdateOperationsInput | string | null
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChatUpsertWithoutServiceRequestInput = {
    update: XOR<ChatUpdateWithoutServiceRequestInput, ChatUncheckedUpdateWithoutServiceRequestInput>
    create: XOR<ChatCreateWithoutServiceRequestInput, ChatUncheckedCreateWithoutServiceRequestInput>
    where?: ChatWhereInput
  }

  export type ChatUpdateToOneWithWhereWithoutServiceRequestInput = {
    where?: ChatWhereInput
    data: XOR<ChatUpdateWithoutServiceRequestInput, ChatUncheckedUpdateWithoutServiceRequestInput>
  }

  export type ChatUpdateWithoutServiceRequestInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    messages?: MessageUpdateManyWithoutChatNestedInput
  }

  export type ChatUncheckedUpdateWithoutServiceRequestInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    messages?: MessageUncheckedUpdateManyWithoutChatNestedInput
  }

  export type MechanicConfirmationUpsertWithWhereUniqueWithoutServiceRequestInput = {
    where: MechanicConfirmationWhereUniqueInput
    update: XOR<MechanicConfirmationUpdateWithoutServiceRequestInput, MechanicConfirmationUncheckedUpdateWithoutServiceRequestInput>
    create: XOR<MechanicConfirmationCreateWithoutServiceRequestInput, MechanicConfirmationUncheckedCreateWithoutServiceRequestInput>
  }

  export type MechanicConfirmationUpdateWithWhereUniqueWithoutServiceRequestInput = {
    where: MechanicConfirmationWhereUniqueInput
    data: XOR<MechanicConfirmationUpdateWithoutServiceRequestInput, MechanicConfirmationUncheckedUpdateWithoutServiceRequestInput>
  }

  export type MechanicConfirmationUpdateManyWithWhereWithoutServiceRequestInput = {
    where: MechanicConfirmationScalarWhereInput
    data: XOR<MechanicConfirmationUpdateManyMutationInput, MechanicConfirmationUncheckedUpdateManyWithoutServiceRequestInput>
  }

  export type ReviewUpsertWithWhereUniqueWithoutServiceRequestInput = {
    where: ReviewWhereUniqueInput
    update: XOR<ReviewUpdateWithoutServiceRequestInput, ReviewUncheckedUpdateWithoutServiceRequestInput>
    create: XOR<ReviewCreateWithoutServiceRequestInput, ReviewUncheckedCreateWithoutServiceRequestInput>
  }

  export type ReviewUpdateWithWhereUniqueWithoutServiceRequestInput = {
    where: ReviewWhereUniqueInput
    data: XOR<ReviewUpdateWithoutServiceRequestInput, ReviewUncheckedUpdateWithoutServiceRequestInput>
  }

  export type ReviewUpdateManyWithWhereWithoutServiceRequestInput = {
    where: ReviewScalarWhereInput
    data: XOR<ReviewUpdateManyMutationInput, ReviewUncheckedUpdateManyWithoutServiceRequestInput>
  }

  export type UserCreateWithoutEmergencyContactsInput = {
    id?: string
    phoneNumber: string
    name?: string | null
    email?: string | null
    password?: string | null
    cars?: CarCreateNestedManyWithoutUserInput
    serviceRequests?: ServiceRequestCreateNestedManyWithoutUserInput
    sentMessages?: MessageCreateNestedManyWithoutUserInput
    sosEvents?: SOSCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutEmergencyContactsInput = {
    id?: string
    phoneNumber: string
    name?: string | null
    email?: string | null
    password?: string | null
    cars?: CarUncheckedCreateNestedManyWithoutUserInput
    serviceRequests?: ServiceRequestUncheckedCreateNestedManyWithoutUserInput
    sentMessages?: MessageUncheckedCreateNestedManyWithoutUserInput
    sosEvents?: SOSUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutEmergencyContactsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutEmergencyContactsInput, UserUncheckedCreateWithoutEmergencyContactsInput>
  }

  export type SOSCreateWithoutEmergencyContactInput = {
    id?: string
    latitude: number
    longitude: number
    createdAt?: Date | string
    customMessage?: string | null
    status?: $Enums.SOSStatus
    user: UserCreateNestedOneWithoutSosEventsInput
  }

  export type SOSUncheckedCreateWithoutEmergencyContactInput = {
    id?: string
    userId: string
    latitude: number
    longitude: number
    createdAt?: Date | string
    customMessage?: string | null
    status?: $Enums.SOSStatus
  }

  export type SOSCreateOrConnectWithoutEmergencyContactInput = {
    where: SOSWhereUniqueInput
    create: XOR<SOSCreateWithoutEmergencyContactInput, SOSUncheckedCreateWithoutEmergencyContactInput>
  }

  export type SOSCreateManyEmergencyContactInputEnvelope = {
    data: SOSCreateManyEmergencyContactInput | SOSCreateManyEmergencyContactInput[]
  }

  export type UserUpsertWithoutEmergencyContactsInput = {
    update: XOR<UserUpdateWithoutEmergencyContactsInput, UserUncheckedUpdateWithoutEmergencyContactsInput>
    create: XOR<UserCreateWithoutEmergencyContactsInput, UserUncheckedCreateWithoutEmergencyContactsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutEmergencyContactsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutEmergencyContactsInput, UserUncheckedUpdateWithoutEmergencyContactsInput>
  }

  export type UserUpdateWithoutEmergencyContactsInput = {
    phoneNumber?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    cars?: CarUpdateManyWithoutUserNestedInput
    serviceRequests?: ServiceRequestUpdateManyWithoutUserNestedInput
    sentMessages?: MessageUpdateManyWithoutUserNestedInput
    sosEvents?: SOSUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutEmergencyContactsInput = {
    phoneNumber?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    cars?: CarUncheckedUpdateManyWithoutUserNestedInput
    serviceRequests?: ServiceRequestUncheckedUpdateManyWithoutUserNestedInput
    sentMessages?: MessageUncheckedUpdateManyWithoutUserNestedInput
    sosEvents?: SOSUncheckedUpdateManyWithoutUserNestedInput
  }

  export type SOSUpsertWithWhereUniqueWithoutEmergencyContactInput = {
    where: SOSWhereUniqueInput
    update: XOR<SOSUpdateWithoutEmergencyContactInput, SOSUncheckedUpdateWithoutEmergencyContactInput>
    create: XOR<SOSCreateWithoutEmergencyContactInput, SOSUncheckedCreateWithoutEmergencyContactInput>
  }

  export type SOSUpdateWithWhereUniqueWithoutEmergencyContactInput = {
    where: SOSWhereUniqueInput
    data: XOR<SOSUpdateWithoutEmergencyContactInput, SOSUncheckedUpdateWithoutEmergencyContactInput>
  }

  export type SOSUpdateManyWithWhereWithoutEmergencyContactInput = {
    where: SOSScalarWhereInput
    data: XOR<SOSUpdateManyMutationInput, SOSUncheckedUpdateManyWithoutEmergencyContactInput>
  }

  export type ServiceRequestCreateWithoutReviewsInput = {
    id?: string
    serviceType: $Enums.ServiceType
    description?: string | null
    latitude: number
    longitude: number
    address?: string | null
    status?: $Enums.ServiceStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutServiceRequestsInput
    mechanic?: MechanicCreateNestedOneWithoutServiceRequestsInput
    payment?: PaymentCreateNestedOneWithoutServiceRequestInput
    chat?: ChatCreateNestedOneWithoutServiceRequestInput
    confirmations?: MechanicConfirmationCreateNestedManyWithoutServiceRequestInput
  }

  export type ServiceRequestUncheckedCreateWithoutReviewsInput = {
    id?: string
    userId: string
    mechanicId?: string | null
    serviceType: $Enums.ServiceType
    description?: string | null
    latitude: number
    longitude: number
    address?: string | null
    status?: $Enums.ServiceStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    payment?: PaymentUncheckedCreateNestedOneWithoutServiceRequestInput
    chat?: ChatUncheckedCreateNestedOneWithoutServiceRequestInput
    confirmations?: MechanicConfirmationUncheckedCreateNestedManyWithoutServiceRequestInput
  }

  export type ServiceRequestCreateOrConnectWithoutReviewsInput = {
    where: ServiceRequestWhereUniqueInput
    create: XOR<ServiceRequestCreateWithoutReviewsInput, ServiceRequestUncheckedCreateWithoutReviewsInput>
  }

  export type MechanicCreateWithoutReviewsInput = {
    id?: string
    name?: string | null
    email?: string | null
    phoneNumber: string
    services?: MechanicCreateservicesInput | $Enums.ServiceType[]
    latitude?: number | null
    longitude?: number | null
    location?: InputJsonValue | null
    expoToken?: string | null
    serviceRequests?: ServiceRequestCreateNestedManyWithoutMechanicInput
    sentMessages?: MessageCreateNestedManyWithoutMechanicInput
    MechanicConfirmation?: MechanicConfirmationCreateNestedManyWithoutMechanicInput
  }

  export type MechanicUncheckedCreateWithoutReviewsInput = {
    id?: string
    name?: string | null
    email?: string | null
    phoneNumber: string
    services?: MechanicCreateservicesInput | $Enums.ServiceType[]
    latitude?: number | null
    longitude?: number | null
    location?: InputJsonValue | null
    expoToken?: string | null
    serviceRequests?: ServiceRequestUncheckedCreateNestedManyWithoutMechanicInput
    sentMessages?: MessageUncheckedCreateNestedManyWithoutMechanicInput
    MechanicConfirmation?: MechanicConfirmationUncheckedCreateNestedManyWithoutMechanicInput
  }

  export type MechanicCreateOrConnectWithoutReviewsInput = {
    where: MechanicWhereUniqueInput
    create: XOR<MechanicCreateWithoutReviewsInput, MechanicUncheckedCreateWithoutReviewsInput>
  }

  export type ServiceRequestUpsertWithoutReviewsInput = {
    update: XOR<ServiceRequestUpdateWithoutReviewsInput, ServiceRequestUncheckedUpdateWithoutReviewsInput>
    create: XOR<ServiceRequestCreateWithoutReviewsInput, ServiceRequestUncheckedCreateWithoutReviewsInput>
    where?: ServiceRequestWhereInput
  }

  export type ServiceRequestUpdateToOneWithWhereWithoutReviewsInput = {
    where?: ServiceRequestWhereInput
    data: XOR<ServiceRequestUpdateWithoutReviewsInput, ServiceRequestUncheckedUpdateWithoutReviewsInput>
  }

  export type ServiceRequestUpdateWithoutReviewsInput = {
    serviceType?: EnumServiceTypeFieldUpdateOperationsInput | $Enums.ServiceType
    description?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: FloatFieldUpdateOperationsInput | number
    longitude?: FloatFieldUpdateOperationsInput | number
    address?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumServiceStatusFieldUpdateOperationsInput | $Enums.ServiceStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutServiceRequestsNestedInput
    mechanic?: MechanicUpdateOneWithoutServiceRequestsNestedInput
    payment?: PaymentUpdateOneWithoutServiceRequestNestedInput
    chat?: ChatUpdateOneWithoutServiceRequestNestedInput
    confirmations?: MechanicConfirmationUpdateManyWithoutServiceRequestNestedInput
  }

  export type ServiceRequestUncheckedUpdateWithoutReviewsInput = {
    userId?: StringFieldUpdateOperationsInput | string
    mechanicId?: NullableStringFieldUpdateOperationsInput | string | null
    serviceType?: EnumServiceTypeFieldUpdateOperationsInput | $Enums.ServiceType
    description?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: FloatFieldUpdateOperationsInput | number
    longitude?: FloatFieldUpdateOperationsInput | number
    address?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumServiceStatusFieldUpdateOperationsInput | $Enums.ServiceStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    payment?: PaymentUncheckedUpdateOneWithoutServiceRequestNestedInput
    chat?: ChatUncheckedUpdateOneWithoutServiceRequestNestedInput
    confirmations?: MechanicConfirmationUncheckedUpdateManyWithoutServiceRequestNestedInput
  }

  export type MechanicUpsertWithoutReviewsInput = {
    update: XOR<MechanicUpdateWithoutReviewsInput, MechanicUncheckedUpdateWithoutReviewsInput>
    create: XOR<MechanicCreateWithoutReviewsInput, MechanicUncheckedCreateWithoutReviewsInput>
    where?: MechanicWhereInput
  }

  export type MechanicUpdateToOneWithWhereWithoutReviewsInput = {
    where?: MechanicWhereInput
    data: XOR<MechanicUpdateWithoutReviewsInput, MechanicUncheckedUpdateWithoutReviewsInput>
  }

  export type MechanicUpdateWithoutReviewsInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: StringFieldUpdateOperationsInput | string
    services?: MechanicUpdateservicesInput | $Enums.ServiceType[]
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    location?: InputJsonValue | InputJsonValue | null
    expoToken?: NullableStringFieldUpdateOperationsInput | string | null
    serviceRequests?: ServiceRequestUpdateManyWithoutMechanicNestedInput
    sentMessages?: MessageUpdateManyWithoutMechanicNestedInput
    MechanicConfirmation?: MechanicConfirmationUpdateManyWithoutMechanicNestedInput
  }

  export type MechanicUncheckedUpdateWithoutReviewsInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: StringFieldUpdateOperationsInput | string
    services?: MechanicUpdateservicesInput | $Enums.ServiceType[]
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    location?: InputJsonValue | InputJsonValue | null
    expoToken?: NullableStringFieldUpdateOperationsInput | string | null
    serviceRequests?: ServiceRequestUncheckedUpdateManyWithoutMechanicNestedInput
    sentMessages?: MessageUncheckedUpdateManyWithoutMechanicNestedInput
    MechanicConfirmation?: MechanicConfirmationUncheckedUpdateManyWithoutMechanicNestedInput
  }

  export type ServiceRequestCreateWithoutPaymentInput = {
    id?: string
    serviceType: $Enums.ServiceType
    description?: string | null
    latitude: number
    longitude: number
    address?: string | null
    status?: $Enums.ServiceStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutServiceRequestsInput
    mechanic?: MechanicCreateNestedOneWithoutServiceRequestsInput
    chat?: ChatCreateNestedOneWithoutServiceRequestInput
    confirmations?: MechanicConfirmationCreateNestedManyWithoutServiceRequestInput
    reviews?: ReviewCreateNestedManyWithoutServiceRequestInput
  }

  export type ServiceRequestUncheckedCreateWithoutPaymentInput = {
    id?: string
    userId: string
    mechanicId?: string | null
    serviceType: $Enums.ServiceType
    description?: string | null
    latitude: number
    longitude: number
    address?: string | null
    status?: $Enums.ServiceStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    chat?: ChatUncheckedCreateNestedOneWithoutServiceRequestInput
    confirmations?: MechanicConfirmationUncheckedCreateNestedManyWithoutServiceRequestInput
    reviews?: ReviewUncheckedCreateNestedManyWithoutServiceRequestInput
  }

  export type ServiceRequestCreateOrConnectWithoutPaymentInput = {
    where: ServiceRequestWhereUniqueInput
    create: XOR<ServiceRequestCreateWithoutPaymentInput, ServiceRequestUncheckedCreateWithoutPaymentInput>
  }

  export type ServiceRequestUpsertWithoutPaymentInput = {
    update: XOR<ServiceRequestUpdateWithoutPaymentInput, ServiceRequestUncheckedUpdateWithoutPaymentInput>
    create: XOR<ServiceRequestCreateWithoutPaymentInput, ServiceRequestUncheckedCreateWithoutPaymentInput>
    where?: ServiceRequestWhereInput
  }

  export type ServiceRequestUpdateToOneWithWhereWithoutPaymentInput = {
    where?: ServiceRequestWhereInput
    data: XOR<ServiceRequestUpdateWithoutPaymentInput, ServiceRequestUncheckedUpdateWithoutPaymentInput>
  }

  export type ServiceRequestUpdateWithoutPaymentInput = {
    serviceType?: EnumServiceTypeFieldUpdateOperationsInput | $Enums.ServiceType
    description?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: FloatFieldUpdateOperationsInput | number
    longitude?: FloatFieldUpdateOperationsInput | number
    address?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumServiceStatusFieldUpdateOperationsInput | $Enums.ServiceStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutServiceRequestsNestedInput
    mechanic?: MechanicUpdateOneWithoutServiceRequestsNestedInput
    chat?: ChatUpdateOneWithoutServiceRequestNestedInput
    confirmations?: MechanicConfirmationUpdateManyWithoutServiceRequestNestedInput
    reviews?: ReviewUpdateManyWithoutServiceRequestNestedInput
  }

  export type ServiceRequestUncheckedUpdateWithoutPaymentInput = {
    userId?: StringFieldUpdateOperationsInput | string
    mechanicId?: NullableStringFieldUpdateOperationsInput | string | null
    serviceType?: EnumServiceTypeFieldUpdateOperationsInput | $Enums.ServiceType
    description?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: FloatFieldUpdateOperationsInput | number
    longitude?: FloatFieldUpdateOperationsInput | number
    address?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumServiceStatusFieldUpdateOperationsInput | $Enums.ServiceStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    chat?: ChatUncheckedUpdateOneWithoutServiceRequestNestedInput
    confirmations?: MechanicConfirmationUncheckedUpdateManyWithoutServiceRequestNestedInput
    reviews?: ReviewUncheckedUpdateManyWithoutServiceRequestNestedInput
  }

  export type ServiceRequestCreateWithoutChatInput = {
    id?: string
    serviceType: $Enums.ServiceType
    description?: string | null
    latitude: number
    longitude: number
    address?: string | null
    status?: $Enums.ServiceStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutServiceRequestsInput
    mechanic?: MechanicCreateNestedOneWithoutServiceRequestsInput
    payment?: PaymentCreateNestedOneWithoutServiceRequestInput
    confirmations?: MechanicConfirmationCreateNestedManyWithoutServiceRequestInput
    reviews?: ReviewCreateNestedManyWithoutServiceRequestInput
  }

  export type ServiceRequestUncheckedCreateWithoutChatInput = {
    id?: string
    userId: string
    mechanicId?: string | null
    serviceType: $Enums.ServiceType
    description?: string | null
    latitude: number
    longitude: number
    address?: string | null
    status?: $Enums.ServiceStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    payment?: PaymentUncheckedCreateNestedOneWithoutServiceRequestInput
    confirmations?: MechanicConfirmationUncheckedCreateNestedManyWithoutServiceRequestInput
    reviews?: ReviewUncheckedCreateNestedManyWithoutServiceRequestInput
  }

  export type ServiceRequestCreateOrConnectWithoutChatInput = {
    where: ServiceRequestWhereUniqueInput
    create: XOR<ServiceRequestCreateWithoutChatInput, ServiceRequestUncheckedCreateWithoutChatInput>
  }

  export type MessageCreateWithoutChatInput = {
    id?: string
    senderType: string
    content: string
    createdAt?: Date | string
    user?: UserCreateNestedOneWithoutSentMessagesInput
    mechanic?: MechanicCreateNestedOneWithoutSentMessagesInput
  }

  export type MessageUncheckedCreateWithoutChatInput = {
    id?: string
    senderId?: string | null
    senderType: string
    content: string
    createdAt?: Date | string
  }

  export type MessageCreateOrConnectWithoutChatInput = {
    where: MessageWhereUniqueInput
    create: XOR<MessageCreateWithoutChatInput, MessageUncheckedCreateWithoutChatInput>
  }

  export type MessageCreateManyChatInputEnvelope = {
    data: MessageCreateManyChatInput | MessageCreateManyChatInput[]
  }

  export type ServiceRequestUpsertWithoutChatInput = {
    update: XOR<ServiceRequestUpdateWithoutChatInput, ServiceRequestUncheckedUpdateWithoutChatInput>
    create: XOR<ServiceRequestCreateWithoutChatInput, ServiceRequestUncheckedCreateWithoutChatInput>
    where?: ServiceRequestWhereInput
  }

  export type ServiceRequestUpdateToOneWithWhereWithoutChatInput = {
    where?: ServiceRequestWhereInput
    data: XOR<ServiceRequestUpdateWithoutChatInput, ServiceRequestUncheckedUpdateWithoutChatInput>
  }

  export type ServiceRequestUpdateWithoutChatInput = {
    serviceType?: EnumServiceTypeFieldUpdateOperationsInput | $Enums.ServiceType
    description?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: FloatFieldUpdateOperationsInput | number
    longitude?: FloatFieldUpdateOperationsInput | number
    address?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumServiceStatusFieldUpdateOperationsInput | $Enums.ServiceStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutServiceRequestsNestedInput
    mechanic?: MechanicUpdateOneWithoutServiceRequestsNestedInput
    payment?: PaymentUpdateOneWithoutServiceRequestNestedInput
    confirmations?: MechanicConfirmationUpdateManyWithoutServiceRequestNestedInput
    reviews?: ReviewUpdateManyWithoutServiceRequestNestedInput
  }

  export type ServiceRequestUncheckedUpdateWithoutChatInput = {
    userId?: StringFieldUpdateOperationsInput | string
    mechanicId?: NullableStringFieldUpdateOperationsInput | string | null
    serviceType?: EnumServiceTypeFieldUpdateOperationsInput | $Enums.ServiceType
    description?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: FloatFieldUpdateOperationsInput | number
    longitude?: FloatFieldUpdateOperationsInput | number
    address?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumServiceStatusFieldUpdateOperationsInput | $Enums.ServiceStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    payment?: PaymentUncheckedUpdateOneWithoutServiceRequestNestedInput
    confirmations?: MechanicConfirmationUncheckedUpdateManyWithoutServiceRequestNestedInput
    reviews?: ReviewUncheckedUpdateManyWithoutServiceRequestNestedInput
  }

  export type MessageUpsertWithWhereUniqueWithoutChatInput = {
    where: MessageWhereUniqueInput
    update: XOR<MessageUpdateWithoutChatInput, MessageUncheckedUpdateWithoutChatInput>
    create: XOR<MessageCreateWithoutChatInput, MessageUncheckedCreateWithoutChatInput>
  }

  export type MessageUpdateWithWhereUniqueWithoutChatInput = {
    where: MessageWhereUniqueInput
    data: XOR<MessageUpdateWithoutChatInput, MessageUncheckedUpdateWithoutChatInput>
  }

  export type MessageUpdateManyWithWhereWithoutChatInput = {
    where: MessageScalarWhereInput
    data: XOR<MessageUpdateManyMutationInput, MessageUncheckedUpdateManyWithoutChatInput>
  }

  export type ChatCreateWithoutMessagesInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    serviceRequest: ServiceRequestCreateNestedOneWithoutChatInput
  }

  export type ChatUncheckedCreateWithoutMessagesInput = {
    id?: string
    serviceRequestId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ChatCreateOrConnectWithoutMessagesInput = {
    where: ChatWhereUniqueInput
    create: XOR<ChatCreateWithoutMessagesInput, ChatUncheckedCreateWithoutMessagesInput>
  }

  export type UserCreateWithoutSentMessagesInput = {
    id?: string
    phoneNumber: string
    name?: string | null
    email?: string | null
    password?: string | null
    cars?: CarCreateNestedManyWithoutUserInput
    serviceRequests?: ServiceRequestCreateNestedManyWithoutUserInput
    emergencyContacts?: EmergencyContactCreateNestedManyWithoutUserInput
    sosEvents?: SOSCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutSentMessagesInput = {
    id?: string
    phoneNumber: string
    name?: string | null
    email?: string | null
    password?: string | null
    cars?: CarUncheckedCreateNestedManyWithoutUserInput
    serviceRequests?: ServiceRequestUncheckedCreateNestedManyWithoutUserInput
    emergencyContacts?: EmergencyContactUncheckedCreateNestedManyWithoutUserInput
    sosEvents?: SOSUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutSentMessagesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutSentMessagesInput, UserUncheckedCreateWithoutSentMessagesInput>
  }

  export type MechanicCreateWithoutSentMessagesInput = {
    id?: string
    name?: string | null
    email?: string | null
    phoneNumber: string
    services?: MechanicCreateservicesInput | $Enums.ServiceType[]
    latitude?: number | null
    longitude?: number | null
    location?: InputJsonValue | null
    expoToken?: string | null
    serviceRequests?: ServiceRequestCreateNestedManyWithoutMechanicInput
    reviews?: ReviewCreateNestedManyWithoutMechanicInput
    MechanicConfirmation?: MechanicConfirmationCreateNestedManyWithoutMechanicInput
  }

  export type MechanicUncheckedCreateWithoutSentMessagesInput = {
    id?: string
    name?: string | null
    email?: string | null
    phoneNumber: string
    services?: MechanicCreateservicesInput | $Enums.ServiceType[]
    latitude?: number | null
    longitude?: number | null
    location?: InputJsonValue | null
    expoToken?: string | null
    serviceRequests?: ServiceRequestUncheckedCreateNestedManyWithoutMechanicInput
    reviews?: ReviewUncheckedCreateNestedManyWithoutMechanicInput
    MechanicConfirmation?: MechanicConfirmationUncheckedCreateNestedManyWithoutMechanicInput
  }

  export type MechanicCreateOrConnectWithoutSentMessagesInput = {
    where: MechanicWhereUniqueInput
    create: XOR<MechanicCreateWithoutSentMessagesInput, MechanicUncheckedCreateWithoutSentMessagesInput>
  }

  export type ChatUpsertWithoutMessagesInput = {
    update: XOR<ChatUpdateWithoutMessagesInput, ChatUncheckedUpdateWithoutMessagesInput>
    create: XOR<ChatCreateWithoutMessagesInput, ChatUncheckedCreateWithoutMessagesInput>
    where?: ChatWhereInput
  }

  export type ChatUpdateToOneWithWhereWithoutMessagesInput = {
    where?: ChatWhereInput
    data: XOR<ChatUpdateWithoutMessagesInput, ChatUncheckedUpdateWithoutMessagesInput>
  }

  export type ChatUpdateWithoutMessagesInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    serviceRequest?: ServiceRequestUpdateOneRequiredWithoutChatNestedInput
  }

  export type ChatUncheckedUpdateWithoutMessagesInput = {
    serviceRequestId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUpsertWithoutSentMessagesInput = {
    update: XOR<UserUpdateWithoutSentMessagesInput, UserUncheckedUpdateWithoutSentMessagesInput>
    create: XOR<UserCreateWithoutSentMessagesInput, UserUncheckedCreateWithoutSentMessagesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutSentMessagesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutSentMessagesInput, UserUncheckedUpdateWithoutSentMessagesInput>
  }

  export type UserUpdateWithoutSentMessagesInput = {
    phoneNumber?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    cars?: CarUpdateManyWithoutUserNestedInput
    serviceRequests?: ServiceRequestUpdateManyWithoutUserNestedInput
    emergencyContacts?: EmergencyContactUpdateManyWithoutUserNestedInput
    sosEvents?: SOSUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutSentMessagesInput = {
    phoneNumber?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    cars?: CarUncheckedUpdateManyWithoutUserNestedInput
    serviceRequests?: ServiceRequestUncheckedUpdateManyWithoutUserNestedInput
    emergencyContacts?: EmergencyContactUncheckedUpdateManyWithoutUserNestedInput
    sosEvents?: SOSUncheckedUpdateManyWithoutUserNestedInput
  }

  export type MechanicUpsertWithoutSentMessagesInput = {
    update: XOR<MechanicUpdateWithoutSentMessagesInput, MechanicUncheckedUpdateWithoutSentMessagesInput>
    create: XOR<MechanicCreateWithoutSentMessagesInput, MechanicUncheckedCreateWithoutSentMessagesInput>
    where?: MechanicWhereInput
  }

  export type MechanicUpdateToOneWithWhereWithoutSentMessagesInput = {
    where?: MechanicWhereInput
    data: XOR<MechanicUpdateWithoutSentMessagesInput, MechanicUncheckedUpdateWithoutSentMessagesInput>
  }

  export type MechanicUpdateWithoutSentMessagesInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: StringFieldUpdateOperationsInput | string
    services?: MechanicUpdateservicesInput | $Enums.ServiceType[]
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    location?: InputJsonValue | InputJsonValue | null
    expoToken?: NullableStringFieldUpdateOperationsInput | string | null
    serviceRequests?: ServiceRequestUpdateManyWithoutMechanicNestedInput
    reviews?: ReviewUpdateManyWithoutMechanicNestedInput
    MechanicConfirmation?: MechanicConfirmationUpdateManyWithoutMechanicNestedInput
  }

  export type MechanicUncheckedUpdateWithoutSentMessagesInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: StringFieldUpdateOperationsInput | string
    services?: MechanicUpdateservicesInput | $Enums.ServiceType[]
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    location?: InputJsonValue | InputJsonValue | null
    expoToken?: NullableStringFieldUpdateOperationsInput | string | null
    serviceRequests?: ServiceRequestUncheckedUpdateManyWithoutMechanicNestedInput
    reviews?: ReviewUncheckedUpdateManyWithoutMechanicNestedInput
    MechanicConfirmation?: MechanicConfirmationUncheckedUpdateManyWithoutMechanicNestedInput
  }

  export type UserCreateWithoutSosEventsInput = {
    id?: string
    phoneNumber: string
    name?: string | null
    email?: string | null
    password?: string | null
    cars?: CarCreateNestedManyWithoutUserInput
    serviceRequests?: ServiceRequestCreateNestedManyWithoutUserInput
    emergencyContacts?: EmergencyContactCreateNestedManyWithoutUserInput
    sentMessages?: MessageCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutSosEventsInput = {
    id?: string
    phoneNumber: string
    name?: string | null
    email?: string | null
    password?: string | null
    cars?: CarUncheckedCreateNestedManyWithoutUserInput
    serviceRequests?: ServiceRequestUncheckedCreateNestedManyWithoutUserInput
    emergencyContacts?: EmergencyContactUncheckedCreateNestedManyWithoutUserInput
    sentMessages?: MessageUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutSosEventsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutSosEventsInput, UserUncheckedCreateWithoutSosEventsInput>
  }

  export type EmergencyContactCreateWithoutSosEventsInput = {
    id?: string
    name: string
    mobileNumber: string
    user: UserCreateNestedOneWithoutEmergencyContactsInput
  }

  export type EmergencyContactUncheckedCreateWithoutSosEventsInput = {
    id?: string
    userId: string
    name: string
    mobileNumber: string
  }

  export type EmergencyContactCreateOrConnectWithoutSosEventsInput = {
    where: EmergencyContactWhereUniqueInput
    create: XOR<EmergencyContactCreateWithoutSosEventsInput, EmergencyContactUncheckedCreateWithoutSosEventsInput>
  }

  export type UserUpsertWithoutSosEventsInput = {
    update: XOR<UserUpdateWithoutSosEventsInput, UserUncheckedUpdateWithoutSosEventsInput>
    create: XOR<UserCreateWithoutSosEventsInput, UserUncheckedCreateWithoutSosEventsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutSosEventsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutSosEventsInput, UserUncheckedUpdateWithoutSosEventsInput>
  }

  export type UserUpdateWithoutSosEventsInput = {
    phoneNumber?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    cars?: CarUpdateManyWithoutUserNestedInput
    serviceRequests?: ServiceRequestUpdateManyWithoutUserNestedInput
    emergencyContacts?: EmergencyContactUpdateManyWithoutUserNestedInput
    sentMessages?: MessageUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutSosEventsInput = {
    phoneNumber?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    cars?: CarUncheckedUpdateManyWithoutUserNestedInput
    serviceRequests?: ServiceRequestUncheckedUpdateManyWithoutUserNestedInput
    emergencyContacts?: EmergencyContactUncheckedUpdateManyWithoutUserNestedInput
    sentMessages?: MessageUncheckedUpdateManyWithoutUserNestedInput
  }

  export type EmergencyContactUpsertWithoutSosEventsInput = {
    update: XOR<EmergencyContactUpdateWithoutSosEventsInput, EmergencyContactUncheckedUpdateWithoutSosEventsInput>
    create: XOR<EmergencyContactCreateWithoutSosEventsInput, EmergencyContactUncheckedCreateWithoutSosEventsInput>
    where?: EmergencyContactWhereInput
  }

  export type EmergencyContactUpdateToOneWithWhereWithoutSosEventsInput = {
    where?: EmergencyContactWhereInput
    data: XOR<EmergencyContactUpdateWithoutSosEventsInput, EmergencyContactUncheckedUpdateWithoutSosEventsInput>
  }

  export type EmergencyContactUpdateWithoutSosEventsInput = {
    name?: StringFieldUpdateOperationsInput | string
    mobileNumber?: StringFieldUpdateOperationsInput | string
    user?: UserUpdateOneRequiredWithoutEmergencyContactsNestedInput
  }

  export type EmergencyContactUncheckedUpdateWithoutSosEventsInput = {
    userId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    mobileNumber?: StringFieldUpdateOperationsInput | string
  }

  export type CarCreateManyUserInput = {
    id?: string
    make: string
    model: string
    year: number
    licensePlate: string
  }

  export type ServiceRequestCreateManyUserInput = {
    id?: string
    mechanicId?: string | null
    serviceType: $Enums.ServiceType
    description?: string | null
    latitude: number
    longitude: number
    address?: string | null
    status?: $Enums.ServiceStatus
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EmergencyContactCreateManyUserInput = {
    id?: string
    name: string
    mobileNumber: string
  }

  export type MessageCreateManyUserInput = {
    id?: string
    chatId: string
    senderType: string
    content: string
    createdAt?: Date | string
  }

  export type SOSCreateManyUserInput = {
    id?: string
    emergencyContactId?: string | null
    latitude: number
    longitude: number
    createdAt?: Date | string
    customMessage?: string | null
    status?: $Enums.SOSStatus
  }

  export type CarUpdateWithoutUserInput = {
    make?: StringFieldUpdateOperationsInput | string
    model?: StringFieldUpdateOperationsInput | string
    year?: IntFieldUpdateOperationsInput | number
    licensePlate?: StringFieldUpdateOperationsInput | string
  }

  export type CarUncheckedUpdateWithoutUserInput = {
    make?: StringFieldUpdateOperationsInput | string
    model?: StringFieldUpdateOperationsInput | string
    year?: IntFieldUpdateOperationsInput | number
    licensePlate?: StringFieldUpdateOperationsInput | string
  }

  export type CarUncheckedUpdateManyWithoutUserInput = {
    make?: StringFieldUpdateOperationsInput | string
    model?: StringFieldUpdateOperationsInput | string
    year?: IntFieldUpdateOperationsInput | number
    licensePlate?: StringFieldUpdateOperationsInput | string
  }

  export type ServiceRequestUpdateWithoutUserInput = {
    serviceType?: EnumServiceTypeFieldUpdateOperationsInput | $Enums.ServiceType
    description?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: FloatFieldUpdateOperationsInput | number
    longitude?: FloatFieldUpdateOperationsInput | number
    address?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumServiceStatusFieldUpdateOperationsInput | $Enums.ServiceStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    mechanic?: MechanicUpdateOneWithoutServiceRequestsNestedInput
    payment?: PaymentUpdateOneWithoutServiceRequestNestedInput
    chat?: ChatUpdateOneWithoutServiceRequestNestedInput
    confirmations?: MechanicConfirmationUpdateManyWithoutServiceRequestNestedInput
    reviews?: ReviewUpdateManyWithoutServiceRequestNestedInput
  }

  export type ServiceRequestUncheckedUpdateWithoutUserInput = {
    mechanicId?: NullableStringFieldUpdateOperationsInput | string | null
    serviceType?: EnumServiceTypeFieldUpdateOperationsInput | $Enums.ServiceType
    description?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: FloatFieldUpdateOperationsInput | number
    longitude?: FloatFieldUpdateOperationsInput | number
    address?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumServiceStatusFieldUpdateOperationsInput | $Enums.ServiceStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    payment?: PaymentUncheckedUpdateOneWithoutServiceRequestNestedInput
    chat?: ChatUncheckedUpdateOneWithoutServiceRequestNestedInput
    confirmations?: MechanicConfirmationUncheckedUpdateManyWithoutServiceRequestNestedInput
    reviews?: ReviewUncheckedUpdateManyWithoutServiceRequestNestedInput
  }

  export type ServiceRequestUncheckedUpdateManyWithoutUserInput = {
    mechanicId?: NullableStringFieldUpdateOperationsInput | string | null
    serviceType?: EnumServiceTypeFieldUpdateOperationsInput | $Enums.ServiceType
    description?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: FloatFieldUpdateOperationsInput | number
    longitude?: FloatFieldUpdateOperationsInput | number
    address?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumServiceStatusFieldUpdateOperationsInput | $Enums.ServiceStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmergencyContactUpdateWithoutUserInput = {
    name?: StringFieldUpdateOperationsInput | string
    mobileNumber?: StringFieldUpdateOperationsInput | string
    sosEvents?: SOSUpdateManyWithoutEmergencyContactNestedInput
  }

  export type EmergencyContactUncheckedUpdateWithoutUserInput = {
    name?: StringFieldUpdateOperationsInput | string
    mobileNumber?: StringFieldUpdateOperationsInput | string
    sosEvents?: SOSUncheckedUpdateManyWithoutEmergencyContactNestedInput
  }

  export type EmergencyContactUncheckedUpdateManyWithoutUserInput = {
    name?: StringFieldUpdateOperationsInput | string
    mobileNumber?: StringFieldUpdateOperationsInput | string
  }

  export type MessageUpdateWithoutUserInput = {
    senderType?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    chat?: ChatUpdateOneRequiredWithoutMessagesNestedInput
    mechanic?: MechanicUpdateOneWithoutSentMessagesNestedInput
  }

  export type MessageUncheckedUpdateWithoutUserInput = {
    chatId?: StringFieldUpdateOperationsInput | string
    senderType?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MessageUncheckedUpdateManyWithoutUserInput = {
    chatId?: StringFieldUpdateOperationsInput | string
    senderType?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SOSUpdateWithoutUserInput = {
    latitude?: FloatFieldUpdateOperationsInput | number
    longitude?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    customMessage?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumSOSStatusFieldUpdateOperationsInput | $Enums.SOSStatus
    emergencyContact?: EmergencyContactUpdateOneWithoutSosEventsNestedInput
  }

  export type SOSUncheckedUpdateWithoutUserInput = {
    emergencyContactId?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: FloatFieldUpdateOperationsInput | number
    longitude?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    customMessage?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumSOSStatusFieldUpdateOperationsInput | $Enums.SOSStatus
  }

  export type SOSUncheckedUpdateManyWithoutUserInput = {
    emergencyContactId?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: FloatFieldUpdateOperationsInput | number
    longitude?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    customMessage?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumSOSStatusFieldUpdateOperationsInput | $Enums.SOSStatus
  }

  export type ServiceRequestCreateManyMechanicInput = {
    id?: string
    userId: string
    serviceType: $Enums.ServiceType
    description?: string | null
    latitude: number
    longitude: number
    address?: string | null
    status?: $Enums.ServiceStatus
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ReviewCreateManyMechanicInput = {
    id?: string
    serviceRequestId: string
    reviewerType: $Enums.SenderType
    rating: number
    comment?: string | null
    createdAt?: Date | string
  }

  export type MessageCreateManyMechanicInput = {
    id?: string
    chatId: string
    senderType: string
    content: string
    createdAt?: Date | string
  }

  export type MechanicConfirmationCreateManyMechanicInput = {
    id?: string
    serviceRequestId: string
    status?: $Enums.ConfirmationStatus
    distanceText: string
    distanceValue: number
    durationText: string
    durationValue: number
    estimatedCost: number
    respondedAt?: Date | string | null
    createdAt?: Date | string
  }

  export type ServiceRequestUpdateWithoutMechanicInput = {
    serviceType?: EnumServiceTypeFieldUpdateOperationsInput | $Enums.ServiceType
    description?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: FloatFieldUpdateOperationsInput | number
    longitude?: FloatFieldUpdateOperationsInput | number
    address?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumServiceStatusFieldUpdateOperationsInput | $Enums.ServiceStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutServiceRequestsNestedInput
    payment?: PaymentUpdateOneWithoutServiceRequestNestedInput
    chat?: ChatUpdateOneWithoutServiceRequestNestedInput
    confirmations?: MechanicConfirmationUpdateManyWithoutServiceRequestNestedInput
    reviews?: ReviewUpdateManyWithoutServiceRequestNestedInput
  }

  export type ServiceRequestUncheckedUpdateWithoutMechanicInput = {
    userId?: StringFieldUpdateOperationsInput | string
    serviceType?: EnumServiceTypeFieldUpdateOperationsInput | $Enums.ServiceType
    description?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: FloatFieldUpdateOperationsInput | number
    longitude?: FloatFieldUpdateOperationsInput | number
    address?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumServiceStatusFieldUpdateOperationsInput | $Enums.ServiceStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    payment?: PaymentUncheckedUpdateOneWithoutServiceRequestNestedInput
    chat?: ChatUncheckedUpdateOneWithoutServiceRequestNestedInput
    confirmations?: MechanicConfirmationUncheckedUpdateManyWithoutServiceRequestNestedInput
    reviews?: ReviewUncheckedUpdateManyWithoutServiceRequestNestedInput
  }

  export type ServiceRequestUncheckedUpdateManyWithoutMechanicInput = {
    userId?: StringFieldUpdateOperationsInput | string
    serviceType?: EnumServiceTypeFieldUpdateOperationsInput | $Enums.ServiceType
    description?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: FloatFieldUpdateOperationsInput | number
    longitude?: FloatFieldUpdateOperationsInput | number
    address?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumServiceStatusFieldUpdateOperationsInput | $Enums.ServiceStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReviewUpdateWithoutMechanicInput = {
    reviewerType?: EnumSenderTypeFieldUpdateOperationsInput | $Enums.SenderType
    rating?: IntFieldUpdateOperationsInput | number
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    serviceRequest?: ServiceRequestUpdateOneRequiredWithoutReviewsNestedInput
  }

  export type ReviewUncheckedUpdateWithoutMechanicInput = {
    serviceRequestId?: StringFieldUpdateOperationsInput | string
    reviewerType?: EnumSenderTypeFieldUpdateOperationsInput | $Enums.SenderType
    rating?: IntFieldUpdateOperationsInput | number
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReviewUncheckedUpdateManyWithoutMechanicInput = {
    serviceRequestId?: StringFieldUpdateOperationsInput | string
    reviewerType?: EnumSenderTypeFieldUpdateOperationsInput | $Enums.SenderType
    rating?: IntFieldUpdateOperationsInput | number
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MessageUpdateWithoutMechanicInput = {
    senderType?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    chat?: ChatUpdateOneRequiredWithoutMessagesNestedInput
    user?: UserUpdateOneWithoutSentMessagesNestedInput
  }

  export type MessageUncheckedUpdateWithoutMechanicInput = {
    chatId?: StringFieldUpdateOperationsInput | string
    senderType?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MessageUncheckedUpdateManyWithoutMechanicInput = {
    chatId?: StringFieldUpdateOperationsInput | string
    senderType?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MechanicConfirmationUpdateWithoutMechanicInput = {
    status?: EnumConfirmationStatusFieldUpdateOperationsInput | $Enums.ConfirmationStatus
    distanceText?: StringFieldUpdateOperationsInput | string
    distanceValue?: IntFieldUpdateOperationsInput | number
    durationText?: StringFieldUpdateOperationsInput | string
    durationValue?: IntFieldUpdateOperationsInput | number
    estimatedCost?: FloatFieldUpdateOperationsInput | number
    respondedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    serviceRequest?: ServiceRequestUpdateOneRequiredWithoutConfirmationsNestedInput
  }

  export type MechanicConfirmationUncheckedUpdateWithoutMechanicInput = {
    serviceRequestId?: StringFieldUpdateOperationsInput | string
    status?: EnumConfirmationStatusFieldUpdateOperationsInput | $Enums.ConfirmationStatus
    distanceText?: StringFieldUpdateOperationsInput | string
    distanceValue?: IntFieldUpdateOperationsInput | number
    durationText?: StringFieldUpdateOperationsInput | string
    durationValue?: IntFieldUpdateOperationsInput | number
    estimatedCost?: FloatFieldUpdateOperationsInput | number
    respondedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MechanicConfirmationUncheckedUpdateManyWithoutMechanicInput = {
    serviceRequestId?: StringFieldUpdateOperationsInput | string
    status?: EnumConfirmationStatusFieldUpdateOperationsInput | $Enums.ConfirmationStatus
    distanceText?: StringFieldUpdateOperationsInput | string
    distanceValue?: IntFieldUpdateOperationsInput | number
    durationText?: StringFieldUpdateOperationsInput | string
    durationValue?: IntFieldUpdateOperationsInput | number
    estimatedCost?: FloatFieldUpdateOperationsInput | number
    respondedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MechanicConfirmationCreateManyServiceRequestInput = {
    id?: string
    mechanicId: string
    status?: $Enums.ConfirmationStatus
    distanceText: string
    distanceValue: number
    durationText: string
    durationValue: number
    estimatedCost: number
    respondedAt?: Date | string | null
    createdAt?: Date | string
  }

  export type ReviewCreateManyServiceRequestInput = {
    id?: string
    reviewerType: $Enums.SenderType
    rating: number
    comment?: string | null
    createdAt?: Date | string
    mechanicId?: string | null
  }

  export type MechanicConfirmationUpdateWithoutServiceRequestInput = {
    status?: EnumConfirmationStatusFieldUpdateOperationsInput | $Enums.ConfirmationStatus
    distanceText?: StringFieldUpdateOperationsInput | string
    distanceValue?: IntFieldUpdateOperationsInput | number
    durationText?: StringFieldUpdateOperationsInput | string
    durationValue?: IntFieldUpdateOperationsInput | number
    estimatedCost?: FloatFieldUpdateOperationsInput | number
    respondedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    mechanic?: MechanicUpdateOneRequiredWithoutMechanicConfirmationNestedInput
  }

  export type MechanicConfirmationUncheckedUpdateWithoutServiceRequestInput = {
    mechanicId?: StringFieldUpdateOperationsInput | string
    status?: EnumConfirmationStatusFieldUpdateOperationsInput | $Enums.ConfirmationStatus
    distanceText?: StringFieldUpdateOperationsInput | string
    distanceValue?: IntFieldUpdateOperationsInput | number
    durationText?: StringFieldUpdateOperationsInput | string
    durationValue?: IntFieldUpdateOperationsInput | number
    estimatedCost?: FloatFieldUpdateOperationsInput | number
    respondedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MechanicConfirmationUncheckedUpdateManyWithoutServiceRequestInput = {
    mechanicId?: StringFieldUpdateOperationsInput | string
    status?: EnumConfirmationStatusFieldUpdateOperationsInput | $Enums.ConfirmationStatus
    distanceText?: StringFieldUpdateOperationsInput | string
    distanceValue?: IntFieldUpdateOperationsInput | number
    durationText?: StringFieldUpdateOperationsInput | string
    durationValue?: IntFieldUpdateOperationsInput | number
    estimatedCost?: FloatFieldUpdateOperationsInput | number
    respondedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReviewUpdateWithoutServiceRequestInput = {
    reviewerType?: EnumSenderTypeFieldUpdateOperationsInput | $Enums.SenderType
    rating?: IntFieldUpdateOperationsInput | number
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Mechanic?: MechanicUpdateOneWithoutReviewsNestedInput
  }

  export type ReviewUncheckedUpdateWithoutServiceRequestInput = {
    reviewerType?: EnumSenderTypeFieldUpdateOperationsInput | $Enums.SenderType
    rating?: IntFieldUpdateOperationsInput | number
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    mechanicId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ReviewUncheckedUpdateManyWithoutServiceRequestInput = {
    reviewerType?: EnumSenderTypeFieldUpdateOperationsInput | $Enums.SenderType
    rating?: IntFieldUpdateOperationsInput | number
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    mechanicId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SOSCreateManyEmergencyContactInput = {
    id?: string
    userId: string
    latitude: number
    longitude: number
    createdAt?: Date | string
    customMessage?: string | null
    status?: $Enums.SOSStatus
  }

  export type SOSUpdateWithoutEmergencyContactInput = {
    latitude?: FloatFieldUpdateOperationsInput | number
    longitude?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    customMessage?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumSOSStatusFieldUpdateOperationsInput | $Enums.SOSStatus
    user?: UserUpdateOneRequiredWithoutSosEventsNestedInput
  }

  export type SOSUncheckedUpdateWithoutEmergencyContactInput = {
    userId?: StringFieldUpdateOperationsInput | string
    latitude?: FloatFieldUpdateOperationsInput | number
    longitude?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    customMessage?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumSOSStatusFieldUpdateOperationsInput | $Enums.SOSStatus
  }

  export type SOSUncheckedUpdateManyWithoutEmergencyContactInput = {
    userId?: StringFieldUpdateOperationsInput | string
    latitude?: FloatFieldUpdateOperationsInput | number
    longitude?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    customMessage?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumSOSStatusFieldUpdateOperationsInput | $Enums.SOSStatus
  }

  export type MessageCreateManyChatInput = {
    id?: string
    senderId?: string | null
    senderType: string
    content: string
    createdAt?: Date | string
  }

  export type MessageUpdateWithoutChatInput = {
    senderType?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneWithoutSentMessagesNestedInput
    mechanic?: MechanicUpdateOneWithoutSentMessagesNestedInput
  }

  export type MessageUncheckedUpdateWithoutChatInput = {
    senderId?: NullableStringFieldUpdateOperationsInput | string | null
    senderType?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MessageUncheckedUpdateManyWithoutChatInput = {
    senderId?: NullableStringFieldUpdateOperationsInput | string | null
    senderType?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}